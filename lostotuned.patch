Only in tuned-kernel-LOS-s5: anykernel_boeffla
diff -ruBb android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974.dtsi tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974.dtsi
--- android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974.dtsi	2018-03-05 17:54:31.879647982 -0300
+++ tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974.dtsi	2018-01-05 16:45:55.833812666 -0300
@@ -2323,13 +2323,13 @@
 		compatible = "qcom,msm-thermal";
 		qcom,sensor-id = <5>;
 		qcom,poll-ms = <250>;
-		qcom,limit-temp = <60>;
-		qcom,temp-hysteresis = <10>;
+		qcom,limit-temp = <80>;
+		qcom,temp-hysteresis = <5>;
 		qcom,therm-reset-temp = <115>;
 		qcom,freq-step = <2>;
 		qcom,freq-control-mask = <0xf>;
-		qcom,core-limit-temp = <80>;
-		qcom,core-temp-hysteresis = <10>;
+		qcom,core-limit-temp = <90>;
+		qcom,core-temp-hysteresis = <5>;
 		qcom,core-control-mask = <0xe>;
 		qcom,hotplug-temp = <110>;
 		qcom,hotplug-temp-hysteresis = <20>;
@@ -2341,8 +2341,8 @@
 		qcom,freq-mitigation-control-mask = <0x01>;
 		qcom,vdd-restriction-temp = <5>;
 		qcom,vdd-restriction-temp-hysteresis = <10>;
-		qcom,pmic-sw-mode-temp = <85>;
-		qcom,pmic-sw-mode-temp-hysteresis = <75>;
+		qcom,pmic-sw-mode-temp = <90>;
+		qcom,pmic-sw-mode-temp-hysteresis = <85>;
 		qcom,pmic-sw-mode-regs = "vdd-dig";
 		vdd-dig-supply = <&pm8841_s2_floor_corner>;
 		vdd-gfx-supply = <&pm8841_s4_floor_corner>;
@@ -2361,7 +2361,7 @@
 
 		qcom,vdd-apps-rstr{
 			qcom,vdd-rstr-reg = "vdd-apps";
-			qcom,levels = <1881600 1958400 2265600>;
+			qcom,levels = <1728000 1958400 2265600 2342400 2419200 2457600>;
 			qcom,freq-req;
 		};
 	};
diff -ruBb android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/core/msm8974pro-pma8084-regulator.dtsi tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/core/msm8974pro-pma8084-regulator.dtsi
--- android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/core/msm8974pro-pma8084-regulator.dtsi	2018-03-05 17:54:31.923648243 -0300
+++ tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/core/msm8974pro-pma8084-regulator.dtsi	2017-10-20 13:09:45.351689013 -0300
@@ -492,7 +492,7 @@
 				<0xf908a800 0x1000>; /* APCS_ALIAS0_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -508,7 +508,7 @@
 				<0xf909a800 0x1000>; /* APCS_ALIAS1_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -524,7 +524,7 @@
 				<0xf90aa800 0x1000>; /* APCS_ALIAS2_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -540,7 +540,7 @@
 				<0xf90ba800 0x1000>; /* APCS_ALIAS3_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
diff -ruBb android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/core/msm8974-regulator.dtsi tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/core/msm8974-regulator.dtsi
--- android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/core/msm8974-regulator.dtsi	2018-03-05 17:54:31.919648220 -0300
+++ tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/core/msm8974-regulator.dtsi	2017-10-20 13:09:45.351689013 -0300
@@ -473,7 +473,7 @@
 				<0xf908a800 0x1000>; /* APCS_ALIAS0_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1100000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -489,7 +489,7 @@
 				<0xf909a800 0x1000>; /* APCS_ALIAS1_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1100000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -505,7 +505,7 @@
 				<0xf90aa800 0x1000>; /* APCS_ALIAS2_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1100000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -521,7 +521,7 @@
 				<0xf90ba800 0x1000>; /* APCS_ALIAS3_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1100000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
diff -ruBb android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/msm8974pro-core-sec.dtsi tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/msm8974pro-core-sec.dtsi
--- android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/msm8974pro-core-sec.dtsi	2018-03-05 17:54:31.959648457 -0300
+++ tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/msm8974pro-core-sec.dtsi	2017-10-20 13:09:45.379689294 -0300
@@ -1615,7 +1615,8 @@
 			< 3509 /* 460 MHz */ >,
 			< 4684 /* 614 MHz */ >,
 			< 6103 /* 800 MHz */ >,
-			< 7102 /* 931 MHz */ >;
+			< 7102 /* 931 MHz */ >,
+			< 7674 /* 1006 MHz */ >;
 	};
 
 	qcom,kraitbw-l2pm {
@@ -1642,7 +1643,11 @@
 			< 1728000 1651200 6103 >,
 			< 1958400 1728000 7102 >,
 			< 2265600 1728000 7102 >,
-			< 2457600 1728000 7102 >;
+			< 2457600 2419200 7102 >,
+			< 2534400 2457600 7674 >,
+			< 2611200 2534400 7674 >,
+			< 2764800 2688000 7674 >,
+			< 2841600 2764800 7674 >;
 	};
 
 	usb3: qcom,ssusb@f9200000 {
diff -ruBb android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/msm8974pro-pm8941.dtsi tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/msm8974pro-pm8941.dtsi
--- android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/msm8974pro-pm8941.dtsi	2018-03-05 17:54:31.963648481 -0300
+++ tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/msm8974pro-pm8941.dtsi	2017-10-20 13:09:45.383689334 -0300
@@ -37,22 +37,22 @@
 };
 
 &krait0_vreg {
-		regulator-max-microvolt = <1120000>;
+		regulator-max-microvolt = <1300000>;
 		qcom,ldo-delta-voltage = <12500>;
 };
 
 &krait1_vreg {
-		regulator-max-microvolt = <1120000>;
+		regulator-max-microvolt = <1300000>;
 		qcom,ldo-delta-voltage = <12500>;
 };
 
 &krait2_vreg {
-		regulator-max-microvolt = <1120000>;
+		regulator-max-microvolt = <1300000>;
 		qcom,ldo-delta-voltage = <12500>;
 };
 
 &krait3_vreg {
-		regulator-max-microvolt = <1120000>;
+		regulator-max-microvolt = <1300000>;
 		qcom,ldo-delta-voltage = <12500>;
 };
 
diff -ruBb android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/msm8974pro-pma8084-regulator.dtsi tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/msm8974pro-pma8084-regulator.dtsi
--- android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/msm8974pro-pma8084-regulator.dtsi	2018-03-05 17:54:31.963648481 -0300
+++ tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/msm8974pro-pma8084-regulator.dtsi	2017-10-20 13:09:45.383689334 -0300
@@ -492,7 +492,7 @@
 				<0xf908a800 0x1000>; /* APCS_ALIAS0_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -508,7 +508,7 @@
 				<0xf909a800 0x1000>; /* APCS_ALIAS1_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -524,7 +524,7 @@
 				<0xf90aa800 0x1000>; /* APCS_ALIAS2_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -540,7 +540,7 @@
 				<0xf90ba800 0x1000>; /* APCS_ALIAS3_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
diff -ruBb android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/msm8974pro-sec.dtsi tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/msm8974pro-sec.dtsi
--- android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/msm8974pro-sec.dtsi	2018-03-05 17:54:31.963648481 -0300
+++ tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/msm8974pro-sec.dtsi	2017-10-20 13:09:45.383689334 -0300
@@ -1049,7 +1049,12 @@
 			< 2265600000 1085000  716 >,
 			< 2342400000 1100000  751 >,
 			< 2419200000 1115000  786 >,
-			< 2457600000 1120000  802 >;
+			< 2457600000 1120000  802 >,
+			< 2534400000 1135000  847 >,
+			< 2611200000 1140000  882 >,
+			< 2688000000 1155000  917 >,
+			< 2764800000 1170000  952 >,
+			< 2841600000 1185000  987 >;
 
 		qcom,speed3-pvs1-bin-v1 =
 			<          0       0    0 >,
@@ -1083,7 +1088,12 @@
 			< 2265600000 1075000  716 >,
 			< 2342400000 1090000  751 >,
 			< 2419200000 1105000  786 >,
-			< 2457600000 1110000  802 >;
+			< 2457600000 1110000  802 >,
+			< 2534400000 1125000  847 >,
+			< 2611200000 1130000  882 >,
+			< 2688000000 1145000  917 >,
+			< 2764800000 1160000  952 >,
+			< 2841600000 1175000  987 >;
 
 		qcom,speed3-pvs2-bin-v1 =
 			<          0       0    0 >,
@@ -1117,7 +1127,12 @@
 			< 2265600000 1065000  716 >,
 			< 2342400000 1080000  751 >,
 			< 2419200000 1095000  786 >,
-			< 2457600000 1100000  802 >;
+			< 2457600000 1100000  802 >,
+			< 2534400000 1115000  847 >,
+			< 2611200000 1130000  882 >,
+			< 2688000000 1145000  917 >,
+			< 2764800000 1160000  952 >,
+			< 2841600000 1175000  987 >;
 
 		qcom,speed3-pvs3-bin-v1 =
 			<          0       0    0 >,
@@ -1151,7 +1166,12 @@
 			< 2265600000 1055000  716 >,
 			< 2342400000 1070000  751 >,
 			< 2419200000 1085000  786 >,
-			< 2457600000 1090000  802 >;
+			< 2457600000 1090000  802 >,
+			< 2534400000 1105000  847 >,
+			< 2611200000 1110000  882 >,
+			< 2688000000 1125000  917 >,
+			< 2764800000 1140000  952 >,
+			< 2841600000 1155000  987 >;
 
 		qcom,speed3-pvs4-bin-v1 =
 			<          0       0    0 >,
@@ -1185,7 +1205,12 @@
 			< 2265600000 1045000  716 >,
 			< 2342400000 1060000  751 >,
 			< 2419200000 1075000  786 >,
-			< 2457600000 1080000  802 >;
+			< 2457600000 1080000  802 >,
+			< 2534400000 1095000  847 >,
+			< 2611200000 1100000  882 >,
+			< 2688000000 1115000  917 >,
+			< 2764800000 1130000  952 >,
+			< 2841600000 1145000  987 >;
 
 		qcom,speed3-pvs5-bin-v1 =
 			<          0       0    0 >,
@@ -1219,7 +1244,12 @@
 			< 2265600000 1035000  716 >,
 			< 2342400000 1050000  751 >,
 			< 2419200000 1065000  786 >,
-			< 2457600000 1070000  802 >;
+			< 2457600000 1070000  802 >,
+			< 2534400000 1085000  847 >,
+			< 2611200000 1090000  882 >,
+			< 2688000000 1105000  917 >,
+			< 2764800000 1120000  952 >,
+			< 2841600000 1135000  987 >;
 
 		qcom,speed3-pvs6-bin-v1 =
 			<          0       0    0 >,
@@ -1253,7 +1283,12 @@
 			< 2265600000 1025000  716 >,
 			< 2342400000 1040000  751 >,
 			< 2419200000 1055000  786 >,
-			< 2457600000 1060000  802 >;
+			< 2457600000 1060000  802 >,
+			< 2534400000 1075000  847 >,
+			< 2611200000 1080000  882 >,
+			< 2688000000 1095000  917 >,
+			< 2764800000 1110000  952 >,
+			< 2841600000 1125000  987 >;
 
 		qcom,speed3-pvs7-bin-v1 =
 			<          0       0    0 >,
@@ -1287,7 +1322,12 @@
 			< 2265600000 1015000  716 >,
 			< 2342400000 1030000  751 >,
 			< 2419200000 1045000  786 >,
-			< 2457600000 1050000  802 >;
+			< 2457600000 1050000  802 >,
+			< 2534400000 1065000  847 >,
+			< 2611200000 1070000  882 >,
+			< 2688000000 1085000  917 >,
+			< 2764800000 1100000  952 >,
+			< 2841600000 1115000  987 >;
 
 		qcom,speed3-pvs8-bin-v1 =
 			<          0       0    0 >,
@@ -1321,7 +1361,12 @@
 			< 2265600000 1005000  716 >,
 			< 2342400000 1020000  751 >,
 			< 2419200000 1035000  786 >,
-			< 2457600000 1040000  802 >;
+			< 2457600000 1040000  802 >,
+			< 2534400000 1055000  847 >,
+			< 2611200000 1060000  882 >,
+			< 2688000000 1075000  917 >,
+			< 2764800000 1090000  952 >,
+			< 2841600000 1105000  987 >;
 
 		qcom,speed3-pvs9-bin-v1 =
 			<          0       0    0 >,
@@ -1355,7 +1400,12 @@
 			< 2265600000  995000  716 >,
 			< 2342400000 1010000  751 >,
 			< 2419200000 1025000  786 >,
-			< 2457600000 1030000  802 >;
+			< 2457600000 1030000  802 >,
+			< 2534400000 1045000  847 >,
+			< 2611200000 1050000  882 >,
+			< 2688000000 1065000  917 >,
+			< 2764800000 1080000  952 >,
+			< 2841600000 1095000  987 >;
 
 		qcom,speed3-pvs10-bin-v1 =
 			<          0       0    0 >,
@@ -1389,7 +1439,12 @@
 			< 2265600000  985000  716 >,
 			< 2342400000 1000000  751 >,
 			< 2419200000 1015000  786 >,
-			< 2457600000 1020000  802 >;
+			< 2457600000 1020000  802 >,
+			< 2534400000 1035000  847 >,
+			< 2611200000 1040000  882 >,
+			< 2688000000 1055000  917 >,
+			< 2764800000 1070000  952 >,
+			< 2841600000 1085000  987 >;
 
 		qcom,speed3-pvs11-bin-v1 =
 			<          0       0    0 >,
@@ -1423,7 +1478,12 @@
 			< 2265600000  975000  716 >,
 			< 2342400000  990000  751 >,
 			< 2419200000 1005000  786 >,
-			< 2457600000 1010000  802 >;
+			< 2457600000 1010000  802 >,
+			< 2534400000 1025000  847 >,
+			< 2611200000 1030000  882 >,
+			< 2688000000 1045000  917 >,
+			< 2764800000 1060000  952 >,
+			< 2841600000 1075000  987 >;
 
 		qcom,speed3-pvs12-bin-v1 =
 			<          0       0    0 >,
@@ -1457,7 +1517,12 @@
 			< 2265600000  965000  716 >,
 			< 2342400000  980000  751 >,
 			< 2419200000  995000  786 >,
-			< 2457600000 1000000  802 >;
+			< 2457600000 1000000  802 >,
+			< 2534400000 1015000  847 >,
+			< 2611200000 1020000  882 >,
+			< 2688000000 1035000  917 >,
+			< 2764800000 1050000  952 >,
+			< 2841600000 1065000  987 >;
 
 		qcom,speed3-pvs13-bin-v1 =
 			<          0       0    0 >,
@@ -1491,7 +1556,12 @@
 			< 2265600000  955000  716 >,
 			< 2342400000  970000  751 >,
 			< 2419200000  985000  786 >,
-			< 2457600000  990000  802 >;
+			< 2457600000  990000  802 >,
+			< 2534400000 1005000  847 >,
+			< 2611200000 1010000  882 >,
+			< 2688000000 1025000  917 >,
+			< 2764800000 1040000  952 >,
+			< 2841600000 1055000  987 >;
 
 		qcom,speed3-pvs14-bin-v1 =
 			<          0       0    0 >,
@@ -1525,7 +1595,12 @@
 			< 2265600000  945000  716 >,
 			< 2342400000  960000  751 >,
 			< 2419200000  975000  786 >,
-			< 2457600000  980000  802 >;
+			< 2457600000  980000  802 >,
+			< 2534400000  995000  847 >,
+			< 2611200000 1000000  882 >,
+			< 2688000000 1015000  917 >,
+			< 2764800000 1030000  952 >,
+			< 2841600000 1045000  987 >;
 
 		qcom,speed3-pvs15-bin-v1 =
 			<          0       0    0 >,
@@ -1559,7 +1634,12 @@
 			< 2265600000  935000  716 >,
 			< 2342400000  950000  751 >,
 			< 2419200000  965000  786 >,
-			< 2457600000  970000  802 >;
+			< 2457600000  970000  802 >,
+			< 2534400000  985000  847 >,
+			< 2611200000 1000000  882 >,
+			< 2688000000 1015000  917 >,
+			< 2764800000 1030000  952 >,
+			< 2841600000 1045000  987 >;
 	};
 
 
@@ -1571,7 +1651,7 @@
 	qcom,chipid = <0x03030002>;
 	qcom,msm-bus,num-cases = <15>;
 	qcom,bus-control;
-	qcom,initial-pwrlevel = <4>;
+	qcom,initial-pwrlevel = <6>;
 
 	/* Updated bus bandwidth requirements */
 	qcom,msm-bus,vectors-KBps =
@@ -1659,6 +1739,15 @@
                        qcom,gpu-freq = <27000000>;
                        qcom,bus-freq = <0>;
                        qcom,io-fraction = <0>;
+               };
+
+				/* this dummy power level is implemented to make
+				the system use the power level before; it is never actively used */
+               qcom,gpu-pwrlevel@7 {
+                       reg = <7>;
+                       qcom,gpu-freq = <27000000>;
+                       qcom,bus-freq = <0>;
+                       qcom,io-fraction = <0>;
                };
        };
 };
diff -ruBb android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/msm8974-regulator.dtsi tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/msm8974-regulator.dtsi
--- android_kernel_samsung_msm8974/arch/arm/boot/dts/msm8974pro/msm8974-regulator.dtsi	2018-03-05 17:54:31.931648290 -0300
+++ tuned-kernel-LOS-s5/arch/arm/boot/dts/msm8974pro/msm8974-regulator.dtsi	2017-10-20 13:09:45.367689173 -0300
@@ -473,7 +473,7 @@
 				<0xf908a800 0x1000>; /* APCS_ALIAS0_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1100000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -489,7 +489,7 @@
 				<0xf909a800 0x1000>; /* APCS_ALIAS1_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1100000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -505,7 +505,7 @@
 				<0xf90aa800 0x1000>; /* APCS_ALIAS2_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1100000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
@@ -521,7 +521,7 @@
 				<0xf90ba800 0x1000>; /* APCS_ALIAS3_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1100000>;
+			regulator-max-microvolt = <1300000>;
 			qcom,headroom-voltage = <150000>;
 			qcom,retention-voltage = <675000>;
 			qcom,ldo-default-voltage = <750000>;
Only in tuned-kernel-LOS-s5/arch/arm/configs: boeffla_defconfig
Only in tuned-kernel-LOS-s5/arch/arm/configs: boeffla_defconfig_variant
diff -ruBb android_kernel_samsung_msm8974/arch/arm/configs/lineage_kltechnduo_defconfig tuned-kernel-LOS-s5/arch/arm/configs/lineage_kltechnduo_defconfig
--- android_kernel_samsung_msm8974/arch/arm/configs/lineage_kltechnduo_defconfig	2018-03-05 17:54:31.999648695 -0300
+++ tuned-kernel-LOS-s5/arch/arm/configs/lineage_kltechnduo_defconfig	2017-11-26 13:01:33.756573900 -0300
@@ -4312,7 +4312,7 @@
 # CONFIG_HARDLOCKUP_DETECTOR_OTHER_CPU is not set
 # CONFIG_HARDLOCKUP_DETECTOR is not set
 # CONFIG_DETECT_HUNG_TASK is not set
-CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_DEBUG=n
 # CONFIG_SYSRQ_SCHED_DEBUG is not set
 CONFIG_SCHEDSTATS=y
 # CONFIG_DEBUG_OBJECTS is not set
diff -ruBb android_kernel_samsung_msm8974/arch/arm/configs/lineage_kltekdi_defconfig tuned-kernel-LOS-s5/arch/arm/configs/lineage_kltekdi_defconfig
--- android_kernel_samsung_msm8974/arch/arm/configs/lineage_kltekdi_defconfig	2018-03-05 17:54:31.999648695 -0300
+++ tuned-kernel-LOS-s5/arch/arm/configs/lineage_kltekdi_defconfig	2018-02-07 19:01:54.189564621 -0300
@@ -53,7 +53,7 @@
 CONFIG_KERNEL_XZ=y
 # CONFIG_KERNEL_LZO is not set
 CONFIG_DEFAULT_HOSTNAME="(none)"
-CONFIG_SWAP=y
+###CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
@@ -61,9 +61,9 @@
 # CONFIG_FHANDLE is not set
 # CONFIG_TASKSTATS is not set
 CONFIG_AUDIT=y
-CONFIG_AUDITSYSCALL=y
-CONFIG_AUDIT_WATCH=y
-CONFIG_AUDIT_TREE=y
+###CONFIG_AUDITSYSCALL=y
+###CONFIG_AUDIT_WATCH=y
+###CONFIG_AUDIT_TREE=y
 # CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
 CONFIG_HAVE_GENERIC_HARDIRQS=y
 
@@ -127,7 +127,7 @@
 # CONFIG_RD_XZ is not set
 # CONFIG_RD_LZO is not set
 # CONFIG_RD_LZ4 is not set
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=n
 CONFIG_SYSCTL=y
 CONFIG_ANON_INODES=y
 CONFIG_PANIC_TIMEOUT=5
@@ -165,10 +165,10 @@
 CONFIG_SLUB=y
 # CONFIG_SLOB is not set
 CONFIG_DEFERRED_INITCALLS=y
-CONFIG_PROFILING=y
-CONFIG_TRACEPOINTS=y
-CONFIG_OPROFILE=y
-CONFIG_HAVE_OPROFILE=y
+###CONFIG_PROFILING=y
+###CONFIG_TRACEPOINTS=y
+###CONFIG_OPROFILE=y
+###CONFIG_HAVE_OPROFILE=y
 # CONFIG_JUMP_LABEL is not set
 CONFIG_HAVE_KPROBES=y
 CONFIG_HAVE_KRETPROBES=y
@@ -185,7 +185,7 @@
 CONFIG_ARCH_MMAP_RND_BITS_MAX=16
 CONFIG_ARCH_MMAP_RND_BITS=8
 CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
-CONFIG_SECCOMP_FILTER=y
+###CONFIG_SECCOMP_FILTER=y
 
 #
 # GCOV-based kernel profiling
@@ -235,12 +235,15 @@
 CONFIG_IOSCHED_CFQ=y
 CONFIG_IOSCHED_BFQ=y
 CONFIG_CGROUP_BFQIO=y
+CONFIG_IOSCHED_FIOPS=n
+CONFIG_IOSCHED_ZEN=n
+CONFIG_IOSCHED_TRIPNDROID=n
 # CONFIG_DEFAULT_DEADLINE is not set
 # CONFIG_DEFAULT_ROW is not set
-CONFIG_DEFAULT_CFQ=y
-# CONFIG_DEFAULT_BFQ is not set
+CONFIG_DEFAULT_CFQ=n
+CONFIG_DEFAULT_BFQ=y
 # CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_DEFAULT_IOSCHED="bfq"
 # CONFIG_INLINE_SPIN_TRYLOCK is not set
 # CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
 # CONFIG_INLINE_SPIN_LOCK is not set
@@ -684,8 +687,11 @@
 CONFIG_MSM_QMI_INTERFACE=y
 # CONFIG_MSM_TEST_QMI_CLIENT is not set
 # CONFIG_MSM_DALRPC is not set
-# CONFIG_MSM_CPU_FREQ_SET_MIN_MAX is not set
+CONFIG_MSM_CPU_FREQ_SET_MIN_MAX=y
+CONFIG_MSM_CPU_FREQ_MAX=2457600
+CONFIG_MSM_CPU_FREQ_MIN=300000
 CONFIG_MSM_DEVFREQ_CPUBW=y
+CONFIG_CPU_VOLTAGE_TABLE=y
 # CONFIG_MSM_AVS_HW is not set
 # CONFIG_MSM_HW3D is not set
 CONFIG_AMSS_7X25_VERSION_2009=y
@@ -766,7 +772,7 @@
 CONFIG_MSM_MULTIMEDIA_USE_ION=y
 CONFIG_MSM_OCMEM=y
 CONFIG_MSM_OCMEM_LOCAL_POWER_CTRL=y
-CONFIG_MSM_OCMEM_DEBUG=y
+###CONFIG_MSM_OCMEM_DEBUG=y
 # CONFIG_MSM_OCMEM_NONSECURE is not set
 # CONFIG_MSM_OCMEM_POWER_DEBUG is not set
 # CONFIG_MSM_OCMEM_DEBUG_ALWAYS_ON is not set
@@ -813,6 +819,8 @@
 # CONFIG_MUIC_RESET_PIN_ENABLE is not set
 # CONFIG_TERT_MI2S_ENABLE is not set
 CONFIG_SEC_SMART_MGR_RUNQUEUE_AVG=y
+CONFIG_PVS_LEVEL_INTERFACE=y
+CONFIG_CHARGE_LEVEL=n
 # CONFIG_KERNEL_TEXT_MPU_PROT is not set
 
 #
@@ -937,15 +945,15 @@
 CONFIG_VIRT_TO_BUS=y
 # CONFIG_KSM is not set
 CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-CONFIG_CLEANCACHE=y
+###CONFIG_CLEANCACHE=y
 # CONFIG_FRONTSWAP is not set
 CONFIG_SWAP_ENABLE_READAHEAD=y
 CONFIG_MEMORY_HOLE_CARVEOUT=y
 # CONFIG_USE_USER_ACCESSIBLE_TIMERS is not set
 CONFIG_MIN_DIRTY_THRESH_PAGES=2560
-CONFIG_ZBUD=y
-CONFIG_ZCACHE=y
-CONFIG_ZSMALLOC=y
+###CONFIG_ZBUD=y
+###CONFIG_ZCACHE=y
+###CONFIG_ZSMALLOC=y
 # CONFIG_ARCH_MEMORY_PROBE is not set
 # CONFIG_ARCH_MEMORY_REMOVE is not set
 # CONFIG_ENABLE_DMM is not set
@@ -955,8 +963,8 @@
 CONFIG_FORCE_MAX_ZONEORDER=11
 CONFIG_ALIGNMENT_TRAP=y
 # CONFIG_UACCESS_WITH_MEMCPY is not set
-CONFIG_SECCOMP=y
-CONFIG_CC_STACKPROTECTOR=y
+###CONFIG_SECCOMP=y
+###CONFIG_CC_STACKPROTECTOR=y
 # CONFIG_DEPRECATED_PARAM_STRUCT is not set
 # CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART is not set
 # CONFIG_CP_ACCESS is not set
@@ -1001,7 +1009,9 @@
 CONFIG_CPU_FREQ_GOV_USERSPACE=y
 CONFIG_CPU_FREQ_GOV_ONDEMAND=y
 CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_LIONHEART=y
+CONFIG_CPU_FREQ_GOV_NIGHTMARE=y
+###CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
 
 #
 # ARM CPU frequency scaling drivers
@@ -1014,6 +1024,7 @@
 CONFIG_CPU_IDLE_GOV_MENU=y
 # CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
 CONFIG_CPU_FREQ_MSM=y
+CONFIG_TUNED_PLUG=y
 
 #
 # Floating point emulation
@@ -1106,7 +1117,7 @@
 # CONFIG_INET_DIAG_DESTROY is not set
 # CONFIG_TCP_CONG_ADVANCED is not set
 CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_DEFAULT_TCP_CONG="htcp"
 # CONFIG_TCP_MD5SIG is not set
 CONFIG_IPV6=y
 CONFIG_IPV6_PRIVACY=y
@@ -1533,7 +1544,7 @@
 #
 # Default contiguous memory area size:
 #
-CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_CMA_SIZE_MBYTES=32
 CONFIG_CMA_SIZE_SEL_MBYTES=y
 # CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
 # CONFIG_CMA_SIZE_SEL_MIN is not set
@@ -1583,8 +1594,8 @@
 # CONFIG_ATA_OVER_ETH is not set
 # CONFIG_MG_DISK is not set
 # CONFIG_BLK_DEV_RBD is not set
-CONFIG_ZRAM=y
-CONFIG_ZRAM_LZ4_COMPRESS=y
+###CONFIG_ZRAM=y
+###CONFIG_ZRAM_LZ4_COMPRESS=y
 # CONFIG_ZRAM_DEBUG is not set
 
 #
@@ -1951,12 +1962,12 @@
 # CONFIG_KEYBOARD_CYPRESS_TOUCHKEY_KS01 is not set
 # CONFIG_KEYBOARD_CYPRESS_TKEY_HL is not set
 # CONFIG_KEYBOARD_CYPRESS_TOUCHKEY_S3 is not set
-CONFIG_INPUT_MOUSE=y
-CONFIG_MOUSE_PS2=y
-CONFIG_MOUSE_PS2_ALPS=y
-CONFIG_MOUSE_PS2_LOGIPS2PP=y
-CONFIG_MOUSE_PS2_SYNAPTICS=y
-CONFIG_MOUSE_PS2_TRACKPOINT=y
+###CONFIG_INPUT_MOUSE=y
+###CONFIG_MOUSE_PS2=y
+###CONFIG_MOUSE_PS2_ALPS=y
+###CONFIG_MOUSE_PS2_LOGIPS2PP=y
+###CONFIG_MOUSE_PS2_SYNAPTICS=y
+###CONFIG_MOUSE_PS2_TRACKPOINT=y
 # CONFIG_MOUSE_PS2_ELANTECH is not set
 # CONFIG_MOUSE_PS2_SENTELIC is not set
 # CONFIG_MOUSE_PS2_TOUCHKIT is not set
@@ -2657,28 +2668,29 @@
 #
 # Customize TV tuners
 #
-CONFIG_MEDIA_TUNER_SIMPLE=y
-CONFIG_MEDIA_TUNER_TDA8290=y
-CONFIG_MEDIA_TUNER_TDA827X=y
-CONFIG_MEDIA_TUNER_TDA18271=y
-CONFIG_MEDIA_TUNER_TDA9887=y
-CONFIG_MEDIA_TUNER_TEA5761=y
-CONFIG_MEDIA_TUNER_TEA5767=y
-CONFIG_MEDIA_TUNER_MT20XX=y
-CONFIG_MEDIA_TUNER_MT2060=y
-CONFIG_MEDIA_TUNER_MT2063=y
-CONFIG_MEDIA_TUNER_MT2266=y
-CONFIG_MEDIA_TUNER_MT2131=y
-CONFIG_MEDIA_TUNER_QT1010=y
-CONFIG_MEDIA_TUNER_XC2028=y
-CONFIG_MEDIA_TUNER_XC5000=y
-CONFIG_MEDIA_TUNER_XC4000=y
-CONFIG_MEDIA_TUNER_MXL5005S=y
-CONFIG_MEDIA_TUNER_MXL5007T=y
-CONFIG_MEDIA_TUNER_MC44S803=y
-CONFIG_MEDIA_TUNER_MAX2165=y
-CONFIG_MEDIA_TUNER_TDA18218=y
-CONFIG_MEDIA_TUNER_TDA18212=y
+CONFIG_MEDIA_TUNER_SIMPLE=n
+CONFIG_MEDIA_TUNER_TDA8290=n
+CONFIG_MEDIA_TUNER_TDA827X=n
+CONFIG_MEDIA_TUNER_TDA18271=n
+CONFIG_MEDIA_TUNER_TDA9887=n
+CONFIG_MEDIA_TUNER_TEA5761=n
+CONFIG_MEDIA_TUNER_TEA5767=n
+CONFIG_MEDIA_TUNER_MT20XX=n
+CONFIG_MEDIA_TUNER_MT2060=n
+CONFIG_MEDIA_TUNER_MT2063=n
+CONFIG_MEDIA_TUNER_MT2266=n
+CONFIG_MEDIA_TUNER_MT2131=n
+CONFIG_MEDIA_TUNER_QT1010=n
+CONFIG_MEDIA_TUNER_XC2028=n
+CONFIG_MEDIA_TUNER_XC5000=n
+CONFIG_MEDIA_TUNER_XC4000=n
+CONFIG_MEDIA_TUNER_MXL5005S=n
+CONFIG_MEDIA_TUNER_MXL5007T=n
+CONFIG_MEDIA_TUNER_MC44S803=n
+CONFIG_MEDIA_TUNER_MAX2165=n
+CONFIG_MEDIA_TUNER_TDA18218=n
+CONFIG_MEDIA_TUNER_TDA18212=n
+
 CONFIG_VIDEO_V4L2=y
 CONFIG_VIDEOBUF2_CORE=y
 CONFIG_VIDEOBUF2_MEMOPS=y
@@ -3197,6 +3209,7 @@
 CONFIG_SND_SOC_ES705=y
 CONFIG_SND_SOC_MSM_STUB=y
 CONFIG_SND_SOC_MSM_HDMI_CODEC_RX=y
+CONFIG_BOEFFLA_SOUND=y
 
 #
 # eS705 Bus Interface
@@ -4296,7 +4309,7 @@
 CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
 CONFIG_ENABLE_WARN_DEPRECATED=y
 CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
+CONFIG_FRAME_WARN=1400
 CONFIG_MAGIC_SYSRQ=y
 # CONFIG_STRIP_ASM_SYMS is not set
 # CONFIG_UNUSED_SYMBOLS is not set
@@ -4460,7 +4473,7 @@
 CONFIG_SECURITY_SELINUX_AVC_STATS=y
 CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
 # CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
-CONFIG_SEC_SELINUX=y
+CONFIG_SEC_SELINUX=n
 # CONFIG_SECURITY_TOMOYO is not set
 # CONFIG_SECURITY_APPARMOR is not set
 # CONFIG_SECURITY_YAMA is not set
@@ -4472,7 +4485,7 @@
 #
 CONFIG_TZ_ICCC=y
 # CONFIG_TZ_ICCC_DEBUG is not set
-CONFIG_DEFAULT_SECURITY_SELINUX=y
+CONFIG_DEFAULT_SECURITY_SELINUX=n
 # CONFIG_DEFAULT_SECURITY_DAC is not set
 CONFIG_DEFAULT_SECURITY="selinux"
 CONFIG_CRYPTO=y
@@ -4622,7 +4635,7 @@
 # CONFIG_CRC7 is not set
 CONFIG_LIBCRC32C=y
 # CONFIG_CRC8 is not set
-CONFIG_AUDIT_GENERIC=y
+###CONFIG_AUDIT_GENERIC=y
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
 CONFIG_LZO_COMPRESS=y
diff -ruBb android_kernel_samsung_msm8974/arch/arm/include/asm/ftrace.h tuned-kernel-LOS-s5/arch/arm/include/asm/ftrace.h
--- android_kernel_samsung_msm8974/arch/arm/include/asm/ftrace.h	2018-03-05 17:54:32.015648790 -0300
+++ tuned-kernel-LOS-s5/arch/arm/include/asm/ftrace.h	2017-11-08 18:16:30.544240465 -0300
@@ -45,7 +45,7 @@
 
 #else
 
-extern inline void *return_address(unsigned int level)
+static inline void *return_address(unsigned int level)
 {
 	return NULL;
 }
diff -ruBb android_kernel_samsung_msm8974/arch/arm/kernel/perf_event.c tuned-kernel-LOS-s5/arch/arm/kernel/perf_event.c
--- android_kernel_samsung_msm8974/arch/arm/kernel/perf_event.c	2018-03-05 17:54:32.035648909 -0300
+++ tuned-kernel-LOS-s5/arch/arm/kernel/perf_event.c	2017-10-31 15:41:49.475973660 -0300
@@ -503,7 +503,7 @@
 	int i, irq, irqs;
 	struct platform_device *pmu_device = armpmu->plat_device;
 
-	irqs = min(pmu_device->num_resources, num_possible_cpus());
+	irqs = min((int)pmu_device->num_resources, num_possible_cpus());
 
 	for (i = 0; i < irqs; ++i) {
 		if (!cpumask_test_and_clear_cpu(i, &armpmu->active_irqs))
@@ -548,7 +548,7 @@
 	else if (!armpmu->free_pmu_irq)
 		armpmu->free_pmu_irq = armpmu_generic_free_irq;
 
-	irqs = min(pmu_device->num_resources, num_possible_cpus());
+	irqs = min((int)pmu_device->num_resources, num_possible_cpus());
 	if (irqs < 1) {
 		pr_err("no irqs for PMUs defined\n");
 		return -ENODEV;
diff -ruBb android_kernel_samsung_msm8974/arch/arm/kernel/return_address.c tuned-kernel-LOS-s5/arch/arm/kernel/return_address.c
--- android_kernel_samsung_msm8974/arch/arm/kernel/return_address.c	2018-03-05 17:54:32.035648909 -0300
+++ tuned-kernel-LOS-s5/arch/arm/kernel/return_address.c	2017-11-08 18:16:48.904378333 -0300
@@ -58,10 +58,6 @@
 
 #else /* if defined(CONFIG_FRAME_POINTER) && !defined(CONFIG_ARM_UNWIND) */
 
-void *return_address(unsigned int level)
-{
-	return NULL;
-}
 
 #endif /* if defined(CONFIG_FRAME_POINTER) && !defined(CONFIG_ARM_UNWIND) / else */
 
Only in tuned-kernel-LOS-s5/arch/arm/mach-msm: charge_level.c
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/clock-krait-8974.c tuned-kernel-LOS-s5/arch/arm/mach-msm/clock-krait-8974.c
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/clock-krait-8974.c	2018-03-05 17:54:32.151649599 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/clock-krait-8974.c	2017-10-20 13:09:45.623691749 -0300
@@ -22,6 +22,10 @@
 #include <linux/of.h>
 #include <linux/cpumask.h>
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+#include <linux/cpufreq.h>
+#endif
+
 #include <asm/cputype.h>
 
 #include <mach/rpm-regulator-smd.h>
@@ -31,6 +35,11 @@
 #include "clock-krait.h"
 #include "clock.h"
 
+#ifdef CONFIG_PVS_LEVEL_INTERFACE
+int pvs_level = -1;
+module_param(pvs_level, int, S_IRUGO); 
+#endif
+
 /* Clock inputs coming into Krait subsystem */
 DEFINE_FIXED_DIV_CLK(hfpll_src_clk, 1, NULL);
 DEFINE_FIXED_DIV_CLK(acpu_aux_clk, 2, NULL);
@@ -471,6 +480,10 @@
 		*pvs = 0;
 	}
 
+#ifdef CONFIG_PVS_LEVEL_INTERFACE
+	pvs_level = *pvs;
+#endif
+
 	dev_info(&pdev->dev, "PVS version: %d\n", *pvs_ver);
 
 	devm_iounmap(&pdev->dev, base);
@@ -600,6 +613,86 @@
 static unsigned int pvs_config_ver;
 module_param(pvs_config_ver, uint, S_IRUGO);
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+
+#define CPU_VDD_MIN	 600
+#define CPU_VDD_MAX	1450
+
+extern bool is_used_by_scaling(unsigned int freq);
+
+static unsigned int cnt;
+
+ssize_t show_UV_mV_table(struct cpufreq_policy *policy, char *buf)
+{
+	int i, freq, len = 0;
+	/* use only master core 0 */
+	int num_levels = cpu_clk[0]->vdd_class->num_levels;
+
+	/* sanity checks */
+	if (num_levels < 0)
+		return -EINVAL;
+
+	if (!buf)
+		return -EINVAL;
+
+	/* format UV_mv table */
+	for (i = 0; i < num_levels; i++) {
+		/* show only those used in scaling */
+		if (!is_used_by_scaling(freq = cpu_clk[0]->fmax[i] / 1000))
+			continue;
+
+		len += sprintf(buf + len, "%dmhz: %u mV\n", freq / 1000,
+			       cpu_clk[0]->vdd_class->vdd_uv[i] / 1000);
+	}
+	return len;
+}
+
+ssize_t store_UV_mV_table(struct cpufreq_policy *policy, char *buf,
+				size_t count)
+{
+	int i, j;
+	int ret = 0;
+	unsigned int val;
+	char size_cur[8];
+	/* use only master core 0 */
+	int num_levels = cpu_clk[0]->vdd_class->num_levels;
+
+	if (cnt) {
+		cnt = 0;
+		return -EINVAL;
+	}
+
+	/* sanity checks */
+	if (num_levels < 0)
+		return -1;
+
+	for (i = 0; i < num_levels; i++) {
+		if (!is_used_by_scaling(cpu_clk[0]->fmax[i] / 1000))
+			continue;
+
+		ret = sscanf(buf, "%u", &val);
+		if (!ret)
+			return -EINVAL;
+
+		/* bounds check */
+		val = min( max((unsigned int)val, (unsigned int)CPU_VDD_MIN),
+			(unsigned int)CPU_VDD_MAX);
+
+		/* apply it to all available cores */
+		for (j = 0; j < NR_CPUS; j++)
+			cpu_clk[j]->vdd_class->vdd_uv[i] = val * 1000;
+
+		/* Non-standard sysfs interface: advance buf */
+		ret = sscanf(buf, "%s", size_cur);
+		cnt = strlen(size_cur);
+		buf += cnt + 1;
+	}
+	pr_warn("faux123: user voltage table modified!\n");
+
+	return ret;
+}
+#endif
+
 static int clock_krait_8974_driver_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/cpufreq.c tuned-kernel-LOS-s5/arch/arm/mach-msm/cpufreq.c
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/cpufreq.c	2018-03-05 17:54:32.155649622 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/cpufreq.c	2017-10-20 13:09:45.627691789 -0300
@@ -42,6 +42,10 @@
 #include <asm/div64.h>
 #endif
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+static struct cpufreq_frequency_table *dts_freq_table;
+#endif
+
 static DEFINE_MUTEX(l2bw_lock);
 
 static struct clk *cpu_clk[NR_CPUS];
@@ -595,11 +599,41 @@
 	freq_table[i].index = i;
 	freq_table[i].frequency = CPUFREQ_TABLE_END;
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+	dts_freq_table =
+		devm_kzalloc(dev, (nf + 1) *
+			sizeof(struct cpufreq_frequency_table),
+			GFP_KERNEL);
+
+	if (!dts_freq_table)
+		return -ENOMEM;
+
+	for (i = 0, j = 0; i < nf; i++, j += 3)
+		dts_freq_table[i].frequency = data[j];
+	dts_freq_table[i].frequency = CPUFREQ_TABLE_END;
+#endif
+
 	devm_kfree(dev, data);
 
 	return 0;
 }
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+bool is_used_by_scaling(unsigned int freq)
+{
+	unsigned int i, cpu_freq;
+
+	for (i = 0; dts_freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		cpu_freq = dts_freq_table[i].frequency;
+		if (cpu_freq == CPUFREQ_ENTRY_INVALID)
+			continue;
+		if (freq == cpu_freq)
+			return true;
+	}
+	return false;
+}
+#endif
+
 #ifdef CONFIG_DEBUG_FS
 static int msm_cpufreq_show(struct seq_file *m, void *unused)
 {
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/ext-buck-control.c tuned-kernel-LOS-s5/arch/arm/mach-msm/ext-buck-control.c
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/ext-buck-control.c	2018-03-05 17:54:32.163649669 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/ext-buck-control.c	2017-11-10 14:00:47.997864964 -0300
@@ -105,7 +105,7 @@
 	{},
 };
 
-static struct platform_driver msm_ext_buck_driver = {
+static struct platform_driver __refdata msm_ext_buck_driver = {
 	.probe = msm_ext_buck_probe,
 	.driver = {
 		.name = "ext-buck-control",
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/gdsc.c tuned-kernel-LOS-s5/arch/arm/mach-msm/gdsc.c
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/gdsc.c	2018-03-05 17:54:32.163649669 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/gdsc.c	2017-11-10 13:20:28.340129350 -0300
@@ -279,7 +279,7 @@
 	{}
 };
 
-static struct platform_driver gdsc_driver = {
+static struct platform_driver __refdata gdsc_driver = {
 	.probe		= gdsc_probe,
 	.remove		= __devexit_p(gdsc_remove),
 	.driver		= {
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/include/mach/qdsp6v2/apr.h tuned-kernel-LOS-s5/arch/arm/mach-msm/include/mach/qdsp6v2/apr.h
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/include/mach/qdsp6v2/apr.h	2018-03-05 17:54:32.179649765 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/include/mach/qdsp6v2/apr.h	2017-11-08 20:46:43.538486594 -0300
@@ -153,9 +153,9 @@
 void apr_cb_func(void *buf, int len, void *priv);
 struct apr_svc *apr_register(char *dest, char *svc_name, apr_fn svc_fn,
 					uint32_t src_port, void *priv);
-inline int apr_fill_hdr(void *handle, uint32_t *buf, uint16_t src_port,
+/*inline int apr_fill_hdr(void *handle, uint32_t *buf, uint16_t src_port,
 			uint16_t msg_type, uint16_t dest_port,
-			uint32_t token, uint32_t opcode, uint16_t len);
+			uint32_t token, uint32_t opcode, uint16_t len);*/
 
 int apr_send_pkt(void *handle, uint32_t *buf);
 int apr_deregister(void *handle);
Only in tuned-kernel-LOS-s5/arch/arm/mach-msm: intelli_plug.c.bkp
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/Kconfig tuned-kernel-LOS-s5/arch/arm/mach-msm/Kconfig
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/Kconfig	2018-03-05 17:54:32.115649385 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/Kconfig	2017-10-31 16:26:14.912175405 -0300
@@ -2,6 +2,10 @@
 
 menu "MSM SoC Type"
 
+config TUNED_PLUG
+	bool "Enable tuned-plug cpu hotplug driver"
+	default n
+
 config ARCH_MSM7X01A
 	bool "MSM7x00A / MSM7x01A"
 	select ARCH_MSM_ARM11
@@ -3546,6 +3550,12 @@
 	  agnostic interface to so that some of the devfreq governors can be
 	  shared across SoCs.
 
+config CPU_VOLTAGE_TABLE
+	bool "Enable CPU Voltage Table via sysfs"
+	default n
+	help
+	  DTS based kernel User Voltage Control
+
 config MSM_AVS_HW
 	bool "Enable Adaptive Voltage Scaling (AVS)"
 	default n
@@ -4918,6 +4928,18 @@
 	bool "Samsung added for read current run queue"
 	help
 	  Support for Smart MGR function.
+	  
+config PVS_LEVEL_INTERFACE
+	bool "Expose PVS level information in sys fs (Boeffla-Kernel)"
+	help
+	 Allow PVS level to be shown in Boeffla-Config app
+
+config CHARGE_LEVEL
+	bool "Charge level interface"
+	default y
+	help
+	  Allows configuration of ac, usb and wireless charging levels
+
 endif
 
 config KERNEL_TEXT_MPU_PROT
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/krait-regulator.c tuned-kernel-LOS-s5/arch/arm/mach-msm/krait-regulator.c
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/krait-regulator.c	2018-03-05 17:54:32.187649813 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/krait-regulator.c	2017-11-10 13:28:20.771594422 -0300
@@ -1432,7 +1432,7 @@
 	{}
 };
 
-static struct platform_driver krait_power_driver = {
+static struct platform_driver __refdata krait_power_driver = {
 	.probe	= krait_power_probe,
 	.remove	= __devexit_p(krait_power_remove),
 	.driver	= {
@@ -1647,7 +1647,7 @@
 	return 0;
 }
 
-static struct platform_driver krait_pdn_driver = {
+static struct platform_driver __refdata krait_pdn_driver = {
 	.probe	= krait_pdn_probe,
 	.remove	= __devexit_p(krait_pdn_remove),
 	.driver	= {
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/krait-regulator-pmic.c tuned-kernel-LOS-s5/arch/arm/mach-msm/krait-regulator-pmic.c
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/krait-regulator-pmic.c	2018-03-05 17:54:32.183649788 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/krait-regulator-pmic.c	2017-11-10 13:42:17.585727976 -0300
@@ -388,7 +388,7 @@
 	return 0;
 }
 
-static struct spmi_driver qpnp_revid_driver = {
+static struct spmi_driver __refdata qpnp_revid_driver = {
 	.probe	= krait_vreg_pmic_probe,
 	.driver	= {
 		.name		= KRAIT_REG_PMIC_DEV_NAME,
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/lpm_levels.c tuned-kernel-LOS-s5/arch/arm/mach-msm/lpm_levels.c
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/lpm_levels.c	2018-03-05 17:54:32.187649813 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/lpm_levels.c	2017-11-10 14:02:11.050473536 -0300
@@ -1154,7 +1154,7 @@
 	{},
 };
 
-static struct platform_driver cpu_modes_driver = {
+static struct platform_driver __refdata cpu_modes_driver = {
 	.probe = lpm_cpu_probe,
 	.driver = {
 		.name = "cpu-modes",
@@ -1168,7 +1168,7 @@
 	{},
 };
 
-static struct platform_driver system_modes_driver = {
+static struct platform_driver __refdata system_modes_driver = {
 	.probe = lpm_system_probe,
 	.driver = {
 		.name = "system-modes",
@@ -1182,7 +1182,7 @@
 	{},
 };
 
-static struct platform_driver lpm_levels_driver = {
+static struct platform_driver __refdata lpm_levels_driver = {
 	.probe = lpm_probe,
 	.driver = {
 		.name = "lpm-levels",
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/Makefile tuned-kernel-LOS-s5/arch/arm/mach-msm/Makefile
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/Makefile	2018-03-05 17:54:32.119649408 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/Makefile	2017-10-31 16:33:38.011533718 -0300
@@ -493,6 +493,7 @@
 obj-$(CONFIG_ARCH_MSM8974) += msm_mpmctr.o
 obj-$(CONFIG_MSM_CPR_REGULATOR) += cpr-regulator.o
 obj-$(CONFIG_CPU_FREQ_MSM) += cpufreq.o
+obj-$(CONFIG_TUNED_PLUG) += tuned_plug.o
 obj-$(CONFIG_MSM_DEVFREQ_CPUBW) += devfreq_cpubw.o
 
 obj-$(CONFIG_WALL_CLK) += wallclk.o
@@ -518,3 +519,5 @@
 obj-$(CONFIG_SEC_THERMISTOR) += sec_thermistor.o msm8974-thermistor.o
 endif
 obj-$(CONFIG_GSM_MODEM_SPRD6500) += board-sprd6500-spi.o board-sprd6500-modems.o
+
+obj-$(CONFIG_CHARGE_LEVEL) += charge_level.o
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/msm_bus/msm_bus_arb.c tuned-kernel-LOS-s5/arch/arm/mach-msm/msm_bus/msm_bus_arb.c
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/msm_bus/msm_bus_arb.c	2018-03-05 17:54:32.187649813 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/msm_bus/msm_bus_arb.c	2017-10-20 13:09:45.663692152 -0300
@@ -656,8 +656,8 @@
 	static int log_cnt = 0;
 #endif
 	if (IS_ERR_OR_NULL(client)) {
-		MSM_BUS_ERR("msm_bus_scale_client update req error %d\n",
-				(uint32_t)client);
+		// MSM_BUS_ERR("msm_bus_scale_client update req error %d\n",
+		//		(uint32_t)client);
 		return -ENXIO;
 	}
 #ifdef SEC_FEATURE_USE_RT_MUTEX
@@ -671,14 +671,14 @@
 	curr = client->curr;
 	pdata = client->pdata;
 	if (!pdata) {
-		MSM_BUS_ERR("Null pdata passed to update-request\n");
+		// MSM_BUS_ERR("Null pdata passed to update-request\n");
 		ret = -ENXIO;
 		goto err;
 	}
 
 	if (index >= pdata->num_usecases) {
-		MSM_BUS_ERR("Client %u passed invalid index: %d\n",
-			(uint32_t)client, index);
+		// MSM_BUS_ERR("Client %u passed invalid index: %d\n",
+		// 	(uint32_t)client, index);
 		ret = -ENXIO;
 		goto err;
 	}
@@ -690,17 +690,17 @@
 		src = msm_bus_board_get_iid(client->pdata->usecase[index].
 			vectors[i].src);
 		if (src == -ENXIO) {
-			MSM_BUS_ERR("Master %d not supported. Request cannot"
-				" be updated\n", client->pdata->usecase->
-				vectors[i].src);
+			// MSM_BUS_ERR("Master %d not supported. Request cannot"
+			//	" be updated\n", client->pdata->usecase->
+			//	vectors[i].src);
 			goto err;
 		}
 
 		if (msm_bus_board_get_iid(client->pdata->usecase[index].
 			vectors[i].dst) == -ENXIO) {
-			MSM_BUS_ERR("Slave %d not supported. Request cannot"
-				" be updated\n", client->pdata->usecase->
-				vectors[i].dst);
+			// MSM_BUS_ERR("Slave %d not supported. Request cannot"
+			// 	" be updated\n", client->pdata->usecase->
+			// 	vectors[i].dst);
 		}
 
 		pnode = client->src_pnode[i];
@@ -737,14 +737,14 @@
 		} else {
 			curr_clk = client->pdata->usecase[curr].vectors[i].ib;
 			curr_bw = client->pdata->usecase[curr].vectors[i].ab;
-			MSM_BUS_DBG("ab: %llu ib: %llu\n", curr_bw, curr_clk);
+			// MSM_BUS_DBG("ab: %llu ib: %llu\n", curr_bw, curr_clk);
 		}
 
 		if (!pdata->active_only) {
 			ret = update_path(src, pnode, req_clk, req_bw,
 				curr_clk, curr_bw, 0, pdata->active_only);
 			if (ret) {
-				MSM_BUS_ERR("Update path failed! %d\n", ret);
+				// MSM_BUS_ERR("Update path failed! %d\n", ret);
 				goto err;
 			}
 		}
@@ -752,7 +752,7 @@
 		ret = update_path(src, pnode, req_clk, req_bw, curr_clk,
 				curr_bw, ACTIVE_CTX, pdata->active_only);
 		if (ret) {
-			MSM_BUS_ERR("Update Path failed! %d\n", ret);
+			// MSM_BUS_ERR("Update Path failed! %d\n", ret);
 			goto err;
 		}
 	}
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/msm-pm.c tuned-kernel-LOS-s5/arch/arm/mach-msm/msm-pm.c
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/msm-pm.c	2018-03-05 17:54:32.187649813 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/msm-pm.c	2017-11-10 13:56:03.579780829 -0300
@@ -1028,7 +1028,7 @@
 	{},
 };
 
-static struct platform_driver msm_cpu_status_driver = {
+static struct platform_driver __refdata msm_cpu_status_driver = {
 	.probe = msm_cpu_status_probe,
 	.driver = {
 		.name = "cpu_slp_status",
@@ -1042,7 +1042,7 @@
 	{},
 };
 
-static struct platform_driver msm_cpu_pm_snoc_client_driver = {
+static struct platform_driver __refdata msm_cpu_pm_snoc_client_driver = {
 	.probe = msm_pm_snoc_client_probe,
 	.driver = {
 		.name = "pm_snoc_client",
@@ -1309,7 +1309,7 @@
 	{},
 };
 
-static struct platform_driver msm_cpu_pm_driver = {
+static struct platform_driver __refdata msm_cpu_pm_driver = {
 	.probe = msm_cpu_pm_probe,
 	.driver = {
 		.name = "pm-8x60",
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/msm_rq_stats.c tuned-kernel-LOS-s5/arch/arm/mach-msm/msm_rq_stats.c
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/msm_rq_stats.c	2018-03-05 17:54:32.195649860 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/msm_rq_stats.c	2017-10-24 12:59:51.250204187 -0300
@@ -33,8 +33,8 @@
 #include <linux/suspend.h>
 
 #define MAX_LONG_SIZE 24
-#define DEFAULT_RQ_POLL_JIFFIES 1
-#define DEFAULT_DEF_TIMER_JIFFIES 5
+#define DEFAULT_RQ_POLL_JIFFIES 2
+#define DEFAULT_DEF_TIMER_JIFFIES 8
 
 struct notifier_block freq_transition;
 struct notifier_block cpu_hotplug;
diff -ruBb android_kernel_samsung_msm8974/arch/arm/mach-msm/rpm-smd.c tuned-kernel-LOS-s5/arch/arm/mach-msm/rpm-smd.c
--- android_kernel_samsung_msm8974/arch/arm/mach-msm/rpm-smd.c	2018-03-05 17:54:32.215649979 -0300
+++ tuned-kernel-LOS-s5/arch/arm/mach-msm/rpm-smd.c	2017-11-10 14:01:10.942033093 -0300
@@ -1412,7 +1412,7 @@
 	{},
 };
 
-static struct platform_driver msm_rpm_device_driver = {
+static struct platform_driver __refdata msm_rpm_device_driver = {
 	.probe = msm_rpm_dev_probe,
 	.driver = {
 		.name = "rpm-smd",
Only in tuned-kernel-LOS-s5/arch/arm/mach-msm: tuned_plug.c
Only in tuned-kernel-LOS-s5/arch/arm/mach-msm: tuned_plug.c.save
Only in tuned-kernel-LOS-s5/arch/arm/mach-omap2: twl-common.c.orig
diff -ruBb android_kernel_samsung_msm8974/arch/arm/Makefile tuned-kernel-LOS-s5/arch/arm/Makefile
--- android_kernel_samsung_msm8974/arch/arm/Makefile	2018-03-05 17:54:31.787647435 -0300
+++ tuned-kernel-LOS-s5/arch/arm/Makefile	2017-12-30 01:07:31.838927178 -0300
@@ -134,8 +134,12 @@
 endif
 
 # Need -Uarm for gcc < 3.x
-KBUILD_CFLAGS	+=$(CFLAGS_ABI) $(CFLAGS_THUMB2) $(arch-y) $(tune-y) $(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,)) -msoft-float -Uarm
-KBUILD_AFLAGS	+=$(CFLAGS_ABI) $(AFLAGS_THUMB2) $(arch-y) $(tune-y) -include asm/unified.h -msoft-float
+###
+###KBUILD_CFLAGS	+=$(CFLAGS_ABI) $(CFLAGS_THUMB2) $(arch-y) $(tune-y) $(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,)) -msoft-float -Uarm
+###KBUILD_AFLAGS	+=$(CFLAGS_ABI) $(AFLAGS_THUMB2) $(arch-y) $(tune-y) -include asm/unified.h -msoft-float
+
+KBUILD_CFLAGS        +=$(CFLAGS_ABI) $(CFLAGS_THUMB2) $(arch-y) $(tune-y) $(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,)) -mfpu=neon-vfpv4 -mfloat-abi=soft -Uarm
+KBUILD_AFLAGS        +=$(CFLAGS_ABI) $(AFLAGS_THUMB2) $(arch-y) $(tune-y) -include asm/unified.h -mfpu=neon-vfpv4 -mfloat-abi=soft
 
 CHECKFLAGS	+= -D__arm__
 
diff -ruBb android_kernel_samsung_msm8974/arch/arm/vfp/Makefile tuned-kernel-LOS-s5/arch/arm/vfp/Makefile
--- android_kernel_samsung_msm8974/arch/arm/vfp/Makefile	2018-03-05 17:54:32.411651144 -0300
+++ tuned-kernel-LOS-s5/arch/arm/vfp/Makefile	2017-12-30 01:02:24.540949792 -0300
@@ -7,7 +7,7 @@
 # ccflags-y := -DDEBUG
 # asflags-y := -DDEBUG
 
-KBUILD_AFLAGS	:=$(KBUILD_AFLAGS:-msoft-float=-Wa,-mfpu=softvfp+vfp -mfloat-abi=soft)
+KBUILD_AFLAGS	:=$(KBUILD_AFLAGS:-msoft-float=-Wa,-mfpu=softvfp+vfp -mfloat-abi=softfp)
 LDFLAGS		+=--no-warn-mismatch
 
 obj-y			+= vfp.o
diff -ruBb android_kernel_samsung_msm8974/arch/Kconfig tuned-kernel-LOS-s5/arch/Kconfig
--- android_kernel_samsung_msm8974/arch/Kconfig	2018-03-05 17:54:31.751647221 -0300
+++ tuned-kernel-LOS-s5/arch/Kconfig	2017-11-29 13:27:54.478221881 -0300
@@ -76,6 +76,23 @@
 	depends on KPROBES && HAVE_OPTPROBES
 	depends on !PREEMPT
 
+config UPROBES
+	bool "Transparent user-space probes (EXPERIMENTAL)"
+	depends on ARCH_SUPPORTS_UPROBES && PERF_EVENTS
+	default n
+	help
+	  Uprobes is the user-space counterpart to kprobes: they
+	  enable instrumentation applications (such as 'perf probe')
+	  to establish unintrusive probes in user-space binaries and
+	  libraries, by executing handler functions when the probes
+	  are hit by user-space applications.
+
+	  ( These probes come in the form of single-byte breakpoints,
+	    managed by the kernel and kept transparent to the probed
+	    application. )
+
+	  If in doubt, say "N".
+
 config HAVE_EFFICIENT_UNALIGNED_ACCESS
 	bool
 	help
diff -ruBb android_kernel_samsung_msm8974/arch/sparc/kernel/ds.c tuned-kernel-LOS-s5/arch/sparc/kernel/ds.c
--- android_kernel_samsung_msm8974/arch/sparc/kernel/ds.c	2018-03-05 17:54:33.175655687 -0300
+++ tuned-kernel-LOS-s5/arch/sparc/kernel/ds.c	2017-11-29 13:27:57.042221863 -0300
@@ -868,7 +868,7 @@
 
 static void ds_conn_reset(struct ds_info *dp)
 {
-	printk(KERN_ERR "ds-%llu: ds_conn_reset() from %p\n",
+	printk(KERN_ERR "ds-%llu: ds_conn_reset() from %pf\n",
 	       dp->id, __builtin_return_address(0));
 }
 
diff -ruBb android_kernel_samsung_msm8974/arch/sparc/kernel/unaligned_64.c tuned-kernel-LOS-s5/arch/sparc/kernel/unaligned_64.c
--- android_kernel_samsung_msm8974/arch/sparc/kernel/unaligned_64.c	2018-03-05 17:54:33.191655782 -0300
+++ tuned-kernel-LOS-s5/arch/sparc/kernel/unaligned_64.c	2017-11-29 13:27:52.598221873 -0300
@@ -21,7 +21,6 @@
 #include <linux/bitops.h>
 #include <linux/perf_event.h>
 #include <linux/ratelimit.h>
-#include <linux/bitops.h>
 #include <asm/fpumacro.h>
 #include <asm/cacheflush.h>
 
diff -ruBb android_kernel_samsung_msm8974/arch/sparc/mm/srmmu.c tuned-kernel-LOS-s5/arch/sparc/mm/srmmu.c
--- android_kernel_samsung_msm8974/arch/sparc/mm/srmmu.c	2018-03-05 17:54:33.199655829 -0300
+++ tuned-kernel-LOS-s5/arch/sparc/mm/srmmu.c	2017-11-29 13:27:56.934221864 -0300
@@ -705,7 +705,7 @@
 		val = srmmu_hwprobe(address);
 		if (val != 0 && pte_val(*ptep) != val) {
 			printk("swift_update_mmu_cache: "
-			    "addr %lx put %08x probed %08x from %p\n",
+			    "addr %lx put %08x probed %08x from %pf\n",
 			    address, pte_val(*ptep), val,
 			    __builtin_return_address(0));
 			srmmu_flush_whole_tlb();
Only in tuned-kernel-LOS-s5/arch/x86/include/asm: uprobes.h
diff -ruBb android_kernel_samsung_msm8974/arch/x86/Kconfig tuned-kernel-LOS-s5/arch/x86/Kconfig
--- android_kernel_samsung_msm8974/arch/x86/Kconfig	2018-03-05 17:54:33.251656139 -0300
+++ tuned-kernel-LOS-s5/arch/x86/Kconfig	2017-11-29 13:27:53.342221878 -0300
@@ -88,7 +88,7 @@
 	select HAVE_ARCH_SECCOMP_FILTER
 
 config INSTRUCTION_DECODER
-	def_bool (KPROBES || PERF_EVENTS)
+	def_bool (KPROBES || PERF_EVENTS || UPROBES)
 
 config OUTPUT_FORMAT
 	string
@@ -261,6 +261,9 @@
 	def_bool y
 	depends on HOTPLUG_CPU
 
+config ARCH_SUPPORTS_UPROBES
+	def_bool y
+
 source "init/Kconfig"
 source "kernel/Kconfig.freezer"
 
diff -ruBb android_kernel_samsung_msm8974/arch/x86/kernel/Makefile tuned-kernel-LOS-s5/arch/x86/kernel/Makefile
--- android_kernel_samsung_msm8974/arch/x86/kernel/Makefile	2018-03-05 17:54:33.279656306 -0300
+++ tuned-kernel-LOS-s5/arch/x86/kernel/Makefile	2017-11-29 13:27:53.334221878 -0300
@@ -102,6 +102,7 @@
 
 obj-$(CONFIG_SWIOTLB)			+= pci-swiotlb.o
 obj-$(CONFIG_OF)			+= devicetree.o
+obj-$(CONFIG_UPROBES)			+= uprobes.o
 
 ###
 # 64 bit specific files
diff -ruBb android_kernel_samsung_msm8974/arch/x86/kernel/reboot.c tuned-kernel-LOS-s5/arch/x86/kernel/reboot.c
--- android_kernel_samsung_msm8974/arch/x86/kernel/reboot.c	2018-03-05 17:54:33.303656448 -0300
+++ tuned-kernel-LOS-s5/arch/x86/kernel/reboot.c	2017-11-29 13:13:43.406816434 -0300
@@ -39,7 +39,8 @@
 enum reboot_type reboot_type = BOOT_ACPI;
 int reboot_force;
 
-/* This variable is used privately to keep track of whether or not
+/*
+ * This variable is used privately to keep track of whether or not
  * reboot_type is still set to its default value (i.e., reboot= hasn't
  * been set on the command line).  This is needed so that we can
  * suppress DMI scanning for reboot quirks.  Without it, it's
@@ -51,7 +52,8 @@
 static int reboot_cpu = -1;
 #endif
 
-/* This is set if we need to go through the 'emergency' path.
+/*
+ * This is set if we need to go through the 'emergency' path.
  * When machine_emergency_restart() is called, we may be on
  * an inconsistent state and won't be able to do a clean cleanup
  */
@@ -60,22 +62,24 @@
 /* This is set by the PCI code if either type 1 or type 2 PCI is detected */
 bool port_cf9_safe = false;
 
-/* reboot=b[ios] | s[mp] | t[riple] | k[bd] | e[fi] [, [w]arm | [c]old] | p[ci]
-   warm   Don't set the cold reboot flag
-   cold   Set the cold reboot flag
-   bios   Reboot by jumping through the BIOS (only for X86_32)
-   smp    Reboot by executing reset on BSP or other CPU (only for X86_32)
-   triple Force a triple fault (init)
-   kbd    Use the keyboard controller. cold reset (default)
-   acpi   Use the RESET_REG in the FADT
-   efi    Use efi reset_system runtime service
-   pci    Use the so-called "PCI reset register", CF9
-   force  Avoid anything that could hang.
+/*
+ * reboot=b[ios] | s[mp] | t[riple] | k[bd] | e[fi] [, [w]arm | [c]old] | p[ci]
+ * warm   Don't set the cold reboot flag
+ * cold   Set the cold reboot flag
+ * bios   Reboot by jumping through the BIOS (only for X86_32)
+ * smp    Reboot by executing reset on BSP or other CPU (only for X86_32)
+ * triple Force a triple fault (init)
+ * kbd    Use the keyboard controller. cold reset (default)
+ * acpi   Use the RESET_REG in the FADT
+ * efi    Use efi reset_system runtime service
+ * pci    Use the so-called "PCI reset register", CF9
+ * force  Avoid anything that could hang.
  */
 static int __init reboot_setup(char *str)
 {
 	for (;;) {
-		/* Having anything passed on the command line via
+		/*
+		 * Having anything passed on the command line via
 		 * reboot= will cause us to disable DMI checking
 		 * below.
 		 */
@@ -98,9 +102,11 @@
 				if (isdigit(*(str+2)))
 					reboot_cpu = reboot_cpu*10 + (int)(*(str+2) - '0');
 			}
-				/* we will leave sorting out the final value
-				   when we are ready to reboot, since we might not
-				   have detected BSP APIC ID or smp_num_cpu */
+			/*
+			 * We will leave sorting out the final value
+			 * when we are ready to reboot, since we might not
+			 * have detected BSP APIC ID or smp_num_cpu
+			 */
 			break;
 #endif /* CONFIG_SMP */
 
@@ -150,6 +156,82 @@
 	return 0;
 }
 
+extern const unsigned char machine_real_restart_asm[];
+extern const u64 machine_real_restart_gdt[3];
+
+void machine_real_restart(unsigned int type)
+{
+	void *restart_va;
+	unsigned long restart_pa;
+	void (*restart_lowmem)(unsigned int);
+	u64 *lowmem_gdt;
+
+	local_irq_disable();
+
+	/*
+	 * Write zero to CMOS register number 0x0f, which the BIOS POST
+	 * routine will recognize as telling it to do a proper reboot.  (Well
+	 * that's what this book in front of me says -- it may only apply to
+	 * the Phoenix BIOS though, it's not clear).  At the same time,
+	 * disable NMIs by setting the top bit in the CMOS address register,
+	 * as we're about to do peculiar things to the CPU.  I'm not sure if
+	 * `outb_p' is needed instead of just `outb'.  Use it to be on the
+	 * safe side.  (Yes, CMOS_WRITE does outb_p's. -  Paul G.)
+	 */
+	spin_lock(&rtc_lock);
+	CMOS_WRITE(0x00, 0x8f);
+	spin_unlock(&rtc_lock);
+
+	/*
+	 * Switch back to the initial page table.
+	 */
+	load_cr3(initial_page_table);
+
+	/*
+	 * Write 0x1234 to absolute memory location 0x472.  The BIOS reads
+	 * this on booting to tell it to "Bypass memory test (also warm
+	 * boot)".  This seems like a fairly standard thing that gets set by
+	 * REBOOT.COM programs, and the previous reset routine did this
+	 * too. */
+	*((unsigned short *)0x472) = reboot_mode;
+
+	/* Patch the GDT in the low memory trampoline */
+	lowmem_gdt = TRAMPOLINE_SYM(machine_real_restart_gdt);
+
+	restart_va = TRAMPOLINE_SYM(machine_real_restart_asm);
+	restart_pa = virt_to_phys(restart_va);
+	restart_lowmem = (void (*)(unsigned int))restart_pa;
+
+	/* GDT[0]: GDT self-pointer */
+	lowmem_gdt[0] =
+		(u64)(sizeof(machine_real_restart_gdt) - 1) +
+		((u64)virt_to_phys(lowmem_gdt) << 16);
+	/* GDT[1]: 64K real mode code segment */
+	lowmem_gdt[1] =
+		GDT_ENTRY(0x009b, restart_pa, 0xffff);
+
+	/* Jump to the identity-mapped low memory code */
+	restart_lowmem(type);
+}
+#ifdef CONFIG_APM_MODULE
+EXPORT_SYMBOL(machine_real_restart);
+#endif
+
+#endif /* CONFIG_X86_32 */
+
+/*
+ * Some Apple MacBook and MacBookPro's needs reboot=p to be able to reboot
+ */
+static int __init set_pci_reboot(const struct dmi_system_id *d)
+{
+	if (reboot_type != BOOT_CF9) {
+		reboot_type = BOOT_CF9;
+		printk(KERN_INFO "%s series board detected. "
+		       "Selecting PCI-method for reboots.\n", d->ident);
+	}
+	return 0;
+}
+
 static int __init set_kbd_reboot(const struct dmi_system_id *d)
 {
 	if (reboot_type != BOOT_KBD) {
@@ -159,7 +241,12 @@
 	return 0;
 }
 
+/*
+ * This is a single dmi_table handling all reboot quirks.  Note that
+ * REBOOT_BIOS is only available for 32bit
+ */
 static struct dmi_system_id __initdata reboot_dmi_table[] = {
+#ifdef CONFIG_X86_32
 	{	/* Handle problems with rebooting on Dell E520's */
 		.callback = set_bios_reboot,
 		.ident = "Dell E520",
@@ -184,7 +271,7 @@
 			DMI_MATCH(DMI_PRODUCT_NAME, "PowerEdge 300/"),
 		},
 	},
-	{       /* Handle problems with rebooting on Dell Optiplex 745's SFF*/
+	{	/* Handle problems with rebooting on Dell Optiplex 745's SFF */
 		.callback = set_bios_reboot,
 		.ident = "Dell OptiPlex 745",
 		.matches = {
@@ -192,7 +279,7 @@
 			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 745"),
 		},
 	},
-	{       /* Handle problems with rebooting on Dell Optiplex 745's DFF*/
+	{	/* Handle problems with rebooting on Dell Optiplex 745's DFF */
 		.callback = set_bios_reboot,
 		.ident = "Dell OptiPlex 745",
 		.matches = {
@@ -228,7 +315,7 @@
 			DMI_MATCH(DMI_BOARD_NAME, "0T656F"),
 		},
 	},
-	{	/* Handle problems with rebooting on Dell OptiPlex 760 with 0G919G*/
+	{	/* Handle problems with rebooting on Dell OptiPlex 760 with 0G919G */
 		.callback = set_bios_reboot,
 		.ident = "Dell OptiPlex 760",
 		.matches = {
@@ -309,6 +396,8 @@
 			DMI_MATCH(DMI_BOARD_NAME, "P4S800"),
 		},
 	},
+#endif /* CONFIG_X86_32 */
+
 	{ /* Handle reboot issue on Acer Aspire one */
 		.callback = set_kbd_reboot,
 		.ident = "Acer Aspire One A110",
@@ -317,96 +406,6 @@
 			DMI_MATCH(DMI_PRODUCT_NAME, "AOA110"),
 		},
 	},
-	{ }
-};
-
-static int __init reboot_init(void)
-{
-	/* Only do the DMI check if reboot_type hasn't been overridden
-	 * on the command line
-	 */
-	if (reboot_default) {
-		dmi_check_system(reboot_dmi_table);
-	}
-	return 0;
-}
-core_initcall(reboot_init);
-
-extern const unsigned char machine_real_restart_asm[];
-extern const u64 machine_real_restart_gdt[3];
-
-void machine_real_restart(unsigned int type)
-{
-	void *restart_va;
-	unsigned long restart_pa;
-	void (*restart_lowmem)(unsigned int);
-	u64 *lowmem_gdt;
-
-	local_irq_disable();
-
-	/* Write zero to CMOS register number 0x0f, which the BIOS POST
-	   routine will recognize as telling it to do a proper reboot.  (Well
-	   that's what this book in front of me says -- it may only apply to
-	   the Phoenix BIOS though, it's not clear).  At the same time,
-	   disable NMIs by setting the top bit in the CMOS address register,
-	   as we're about to do peculiar things to the CPU.  I'm not sure if
-	   `outb_p' is needed instead of just `outb'.  Use it to be on the
-	   safe side.  (Yes, CMOS_WRITE does outb_p's. -  Paul G.)
-	 */
-	spin_lock(&rtc_lock);
-	CMOS_WRITE(0x00, 0x8f);
-	spin_unlock(&rtc_lock);
-
-	/*
-	 * Switch back to the initial page table.
-	 */
-	load_cr3(initial_page_table);
-
-	/* Write 0x1234 to absolute memory location 0x472.  The BIOS reads
-	   this on booting to tell it to "Bypass memory test (also warm
-	   boot)".  This seems like a fairly standard thing that gets set by
-	   REBOOT.COM programs, and the previous reset routine did this
-	   too. */
-	*((unsigned short *)0x472) = reboot_mode;
-
-	/* Patch the GDT in the low memory trampoline */
-	lowmem_gdt = TRAMPOLINE_SYM(machine_real_restart_gdt);
-
-	restart_va = TRAMPOLINE_SYM(machine_real_restart_asm);
-	restart_pa = virt_to_phys(restart_va);
-	restart_lowmem = (void (*)(unsigned int))restart_pa;
-
-	/* GDT[0]: GDT self-pointer */
-	lowmem_gdt[0] =
-		(u64)(sizeof(machine_real_restart_gdt) - 1) +
-		((u64)virt_to_phys(lowmem_gdt) << 16);
-	/* GDT[1]: 64K real mode code segment */
-	lowmem_gdt[1] =
-		GDT_ENTRY(0x009b, restart_pa, 0xffff);
-
-	/* Jump to the identity-mapped low memory code */
-	restart_lowmem(type);
-}
-#ifdef CONFIG_APM_MODULE
-EXPORT_SYMBOL(machine_real_restart);
-#endif
-
-#endif /* CONFIG_X86_32 */
-
-/*
- * Some Apple MacBook and MacBookPro's needs reboot=p to be able to reboot
- */
-static int __init set_pci_reboot(const struct dmi_system_id *d)
-{
-	if (reboot_type != BOOT_CF9) {
-		reboot_type = BOOT_CF9;
-		printk(KERN_INFO "%s series board detected. "
-		       "Selecting PCI-method for reboots.\n", d->ident);
-	}
-	return 0;
-}
-
-static struct dmi_system_id __initdata pci_reboot_dmi_table[] = {
 	{	/* Handle problems with rebooting on Apple MacBook5 */
 		.callback = set_pci_reboot,
 		.ident = "Apple MacBook5",
@@ -509,17 +508,17 @@
 	{ }
 };
 
-static int __init pci_reboot_init(void)
+static int __init reboot_init(void)
 {
-	/* Only do the DMI check if reboot_type hasn't been overridden
+	/*
+	 * Only do the DMI check if reboot_type hasn't been overridden
 	 * on the command line
 	 */
-	if (reboot_default) {
-		dmi_check_system(pci_reboot_dmi_table);
-	}
+	if (reboot_default)
+		dmi_check_system(reboot_dmi_table);
 	return 0;
 }
-core_initcall(pci_reboot_init);
+core_initcall(reboot_init);
 
 static inline void kb_wait(void)
 {
@@ -537,14 +536,14 @@
 	cpu_emergency_vmxoff();
 }
 
-/* Use NMIs as IPIs to tell all CPUs to disable virtualization
- */
+/* Use NMIs as IPIs to tell all CPUs to disable virtualization */
 static void emergency_vmx_disable_all(void)
 {
 	/* Just make sure we won't change CPUs while doing this */
 	local_irq_disable();
 
-	/* We need to disable VMX on all CPUs before rebooting, otherwise
+	/*
+	 * We need to disable VMX on all CPUs before rebooting, otherwise
 	 * we risk hanging up the machine, because the CPU ignore INIT
 	 * signals when VMX is enabled.
 	 *
@@ -563,8 +562,7 @@
 	 * is still enabling VMX.
 	 */
 	if (cpu_has_vmx() && cpu_vmx_enabled()) {
-		/* Disable VMX on this CPU.
-		 */
+		/* Disable VMX on this CPU. */
 		cpu_vmxoff();
 
 		/* Halt and disable VMX on the other CPUs */
@@ -609,12 +607,12 @@
 		/* Could also try the reset bit in the Hammer NB */
 		switch (reboot_type) {
 		case BOOT_KBD:
-			mach_reboot_fixups(); /* for board specific fixups */
+			mach_reboot_fixups(); /* For board specific fixups */
 
 			for (i = 0; i < 10; i++) {
 				kb_wait();
 				udelay(50);
-				outb(0xfe, 0x64); /* pulse reset low */
+				outb(0xfe, 0x64); /* Pulse reset low */
 				udelay(50);
 			}
 			if (attempt == 0 && orig_reboot_type == BOOT_ACPI) {
@@ -656,7 +654,7 @@
 
 		case BOOT_CF9:
 			port_cf9_safe = true;
-			/* fall through */
+			/* Fall through */
 
 		case BOOT_CF9_COND:
 			if (port_cf9_safe) {
@@ -702,9 +700,14 @@
 	set_cpus_allowed_ptr(current, cpumask_of(reboot_cpu_id));
 
 	/*
+<<<<<<< HEAD
 	 * O.K Now that I'm on the appropriate processor, stop all of the
 	 * others. Also disable the local irq to not receive the per-cpu
 	 * timer interrupt which may trigger scheduler's load balance.
+=======
+	 * O.K Now that I'm on the appropriate processor,
+	 * stop all of the others.
+>>>>>>> 144d102b926f... x86/reboot: Clean up coding style
 	 */
 	local_irq_disable();
 	stop_other_cpus();
@@ -738,12 +741,11 @@
 
 static void native_machine_halt(void)
 {
-	/* stop other cpus and apics */
+	/* Stop other cpus and apics */
 	machine_shutdown();
 
 	tboot_shutdown(TB_SHUTDOWN_HALT);
 
-	/* stop this cpu */
 	stop_this_cpu(NULL);
 }
 
@@ -754,7 +756,7 @@
 			machine_shutdown();
 		pm_power_off();
 	}
-	/* a fallback in case there is no PM info available */
+	/* A fallback in case there is no PM info available */
 	tboot_shutdown(TB_SHUTDOWN_HALT);
 }
 
@@ -816,7 +818,8 @@
 
 	cpu = raw_smp_processor_id();
 
-	/* Don't do anything if this handler is invoked on crashing cpu.
+	/*
+	 * Don't do anything if this handler is invoked on crashing cpu.
 	 * Otherwise, system will completely hang. Crashing cpu can get
 	 * an NMI if system was initially booted with nmi_watchdog parameter.
 	 */
@@ -840,7 +843,8 @@
 	apic->send_IPI_allbutself(NMI_VECTOR);
 }
 
-/* Halt all other CPUs, calling the specified function on each of them
+/*
+ * Halt all other CPUs, calling the specified function on each of them
  *
  * This function can be used to halt all other CPUs on crash
  * or emergency reboot time. The function passed as parameter
@@ -851,7 +855,7 @@
 	unsigned long msecs;
 	local_irq_disable();
 
-	/* Make a note of crashing cpu. Will be used in NMI callback.*/
+	/* Make a note of crashing cpu. Will be used in NMI callback. */
 	crashing_cpu = safe_smp_processor_id();
 
 	shootdown_callback = callback;
@@ -860,8 +864,9 @@
 	/* Would it be better to replace the trap vector here? */
 	if (register_nmi_handler(NMI_LOCAL, crash_nmi_callback,
 				 NMI_FLAG_FIRST, "crash"))
-		return;		/* return what? */
-	/* Ensure the new callback function is set before sending
+		return;		/* Return what? */
+	/*
+	 * Ensure the new callback function is set before sending
 	 * out the NMI
 	 */
 	wmb();
Only in tuned-kernel-LOS-s5/arch/x86/kernel: reboot.c.orig
Only in tuned-kernel-LOS-s5/arch/x86/kernel: uprobes.c
diff -ruBb android_kernel_samsung_msm8974/arch/x86/mm/init.c tuned-kernel-LOS-s5/arch/x86/mm/init.c
--- android_kernel_samsung_msm8974/arch/x86/mm/init.c	2018-03-05 17:54:33.323656567 -0300
+++ tuned-kernel-LOS-s5/arch/x86/mm/init.c	2017-11-29 13:37:09.481670911 -0300
@@ -35,12 +35,17 @@
 	unsigned page_size_mask;
 };
 
+<<<<<<< HEAD
 /*
  * First calculate space needed for kernel direct mapping page tables to cover
  * mr[0].start to mr[nr_range - 1].end, while accounting for possible 2M and 1GB
  * pages. Then find enough contiguous space for those page tables.
  */
 static void __init find_early_table_space(struct map_range *mr, int nr_range)
+=======
+static void __init find_early_table_space(struct map_range *mr, unsigned long end,
+					  int use_pse, int use_gbpages)
+>>>>>>> 722bc6b16771... x86/mm: Fix the size calculation of mapping tables
 {
 	int i;
 	unsigned long puds = 0, pmds = 0, ptes = 0, tables;
@@ -69,11 +74,20 @@
 #ifdef CONFIG_X86_32
 			extra += PMD_SIZE;
 #endif
+<<<<<<< HEAD
 			ptes += (extra + PAGE_SIZE - 1) >> PAGE_SHIFT;
 		} else {
 			ptes += (range + PAGE_SIZE - 1) >> PAGE_SHIFT;
 		}
 	}
+=======
+		/* The first 2/4M doesn't use large pages. */
+		extra += mr->end - mr->start;
+
+		ptes = (extra + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	} else
+		ptes = (end + PAGE_SIZE - 1) >> PAGE_SHIFT;
+>>>>>>> 722bc6b16771... x86/mm: Fix the size calculation of mapping tables
 
 	tables = roundup(puds * sizeof(pud_t), PAGE_SIZE);
 	tables += roundup(pmds * sizeof(pmd_t), PAGE_SIZE);
@@ -275,7 +289,11 @@
 	 * nodes are discovered.
 	 */
 	if (!after_bootmem)
+<<<<<<< HEAD
 		find_early_table_space(mr, nr_range);
+=======
+		find_early_table_space(&mr[0], end, use_pse, use_gbpages);
+>>>>>>> 722bc6b16771... x86/mm: Fix the size calculation of mapping tables
 
 	for (i = 0; i < nr_range; i++)
 		ret = kernel_physical_mapping_init(mr[i].start, mr[i].end,
Only in tuned-kernel-LOS-s5/arch/x86/mm: init.c.orig
Only in tuned-kernel-LOS-s5: attr
Only in tuned-kernel-LOS-s5: bbuild-anykernel.sh
diff -ruBb android_kernel_samsung_msm8974/block/bfq-iosched.c tuned-kernel-LOS-s5/block/bfq-iosched.c
--- android_kernel_samsung_msm8974/block/bfq-iosched.c	2018-03-05 17:54:33.363656805 -0300
+++ tuned-kernel-LOS-s5/block/bfq-iosched.c	2017-10-21 02:01:29.114524344 -0300
@@ -74,10 +74,10 @@
 static const int bfq_fifo_expire[2] = { HZ / 4, HZ / 8 };
 
 /* Maximum backwards seek, in KiB. */
-static const int bfq_back_max = 16 * 1024;
+//static const int bfq_back_max = 16 * 1024;
 
 /* Penalty of a backwards seek, in number of sectors. */
-static const int bfq_back_penalty = 2;
+//static const int bfq_back_penalty = 2;
 
 /* Idling period duration, in jiffies. */
 static int bfq_slice_idle = HZ / 125;
@@ -224,12 +224,13 @@
 				      struct request *rq2,
 				      sector_t last)
 {
+#if 0
 	sector_t s1, s2, d1 = 0, d2 = 0;
 	unsigned long back_max;
 #define BFQ_RQ1_WRAP	0x01 /* request 1 wraps */
 #define BFQ_RQ2_WRAP	0x02 /* request 2 wraps */
 	unsigned wrap = 0; /* bit mask: requests behind the disk head? */
-
+#endif
 	if (rq1 == NULL || rq1 == rq2)
 		return rq2;
 	if (rq2 == NULL)
@@ -244,6 +245,8 @@
 	else if ((rq2->cmd_flags & REQ_META) && !(rq1->cmd_flags & REQ_META))
 		return rq2;
 
+	return rq1;
+#if 0
 	s1 = blk_rq_pos(rq1);
 	s2 = blk_rq_pos(rq2);
 
@@ -307,6 +310,7 @@
 		else
 			return rq2;
 	}
+#endif
 }
 
 static struct bfq_queue *
@@ -3842,8 +3846,8 @@
 
 	bfqd->bfq_fifo_expire[0] = bfq_fifo_expire[0];
 	bfqd->bfq_fifo_expire[1] = bfq_fifo_expire[1];
-	bfqd->bfq_back_max = bfq_back_max;
-	bfqd->bfq_back_penalty = bfq_back_penalty;
+//	bfqd->bfq_back_max = bfq_back_max;
+//	bfqd->bfq_back_penalty = bfq_back_penalty;
 	bfqd->bfq_slice_idle = bfq_slice_idle;
 	bfqd->bfq_class_idle_last_service = 0;
 	bfqd->bfq_max_budget_async_rq = bfq_max_budget_async_rq;
@@ -3975,8 +3979,8 @@
 }
 SHOW_FUNCTION(bfq_fifo_expire_sync_show, bfqd->bfq_fifo_expire[1], 1);
 SHOW_FUNCTION(bfq_fifo_expire_async_show, bfqd->bfq_fifo_expire[0], 1);
-SHOW_FUNCTION(bfq_back_seek_max_show, bfqd->bfq_back_max, 0);
-SHOW_FUNCTION(bfq_back_seek_penalty_show, bfqd->bfq_back_penalty, 0);
+//SHOW_FUNCTION(bfq_back_seek_max_show, bfqd->bfq_back_max, 0);
+//SHOW_FUNCTION(bfq_back_seek_penalty_show, bfqd->bfq_back_penalty, 0);
 SHOW_FUNCTION(bfq_slice_idle_show, bfqd->bfq_slice_idle, 1);
 SHOW_FUNCTION(bfq_max_budget_show, bfqd->bfq_user_max_budget, 0);
 SHOW_FUNCTION(bfq_max_budget_async_rq_show,
@@ -4013,9 +4017,9 @@
 		INT_MAX, 1);
 STORE_FUNCTION(bfq_fifo_expire_async_store, &bfqd->bfq_fifo_expire[0], 1,
 		INT_MAX, 1);
-STORE_FUNCTION(bfq_back_seek_max_store, &bfqd->bfq_back_max, 0, INT_MAX, 0);
-STORE_FUNCTION(bfq_back_seek_penalty_store, &bfqd->bfq_back_penalty, 1,
-		INT_MAX, 0);
+//STORE_FUNCTION(bfq_back_seek_max_store, &bfqd->bfq_back_max, 0, INT_MAX, 0);
+//STORE_FUNCTION(bfq_back_seek_penalty_store, &bfqd->bfq_back_penalty, 1,
+//		INT_MAX, 0);
 STORE_FUNCTION(bfq_slice_idle_store, &bfqd->bfq_slice_idle, 0, INT_MAX, 1);
 STORE_FUNCTION(bfq_max_budget_async_rq_store, &bfqd->bfq_max_budget_async_rq,
 		1, INT_MAX, 0);
@@ -4111,8 +4115,8 @@
 static struct elv_fs_entry bfq_attrs[] = {
 	BFQ_ATTR(fifo_expire_sync),
 	BFQ_ATTR(fifo_expire_async),
-	BFQ_ATTR(back_seek_max),
-	BFQ_ATTR(back_seek_penalty),
+//	BFQ_ATTR(back_seek_max),
+//	BFQ_ATTR(back_seek_penalty),
 	BFQ_ATTR(slice_idle),
 	BFQ_ATTR(max_budget),
 	BFQ_ATTR(max_budget_async_rq),
diff -ruBb android_kernel_samsung_msm8974/block/blk-cgroup.c tuned-kernel-LOS-s5/block/blk-cgroup.c
--- android_kernel_samsung_msm8974/block/blk-cgroup.c	2018-03-05 17:54:33.363656805 -0300
+++ tuned-kernel-LOS-s5/block/blk-cgroup.c	2017-11-30 13:52:18.748691137 -0300
@@ -47,10 +47,7 @@
 	.attach = blkiocg_attach,
 	.destroy = blkiocg_destroy,
 	.populate = blkiocg_populate,
-#ifdef CONFIG_BLK_CGROUP
-	/* note: blkio_subsys_id is otherwise defined in blk-cgroup.h */
 	.subsys_id = blkio_subsys_id,
-#endif
 	.use_id = 1,
 	.module = THIS_MODULE,
 };
@@ -1673,17 +1670,3 @@
 	spin_unlock(&blkio_list_lock);
 }
 EXPORT_SYMBOL_GPL(blkio_policy_unregister);
-
-static int __init init_cgroup_blkio(void)
-{
-	return cgroup_load_subsys(&blkio_subsys);
-}
-
-static void __exit exit_cgroup_blkio(void)
-{
-	cgroup_unload_subsys(&blkio_subsys);
-}
-
-module_init(init_cgroup_blkio);
-module_exit(exit_cgroup_blkio);
-MODULE_LICENSE("GPL");
Only in tuned-kernel-LOS-s5/block: blk-cgroup.c.orig
diff -ruBb android_kernel_samsung_msm8974/block/blk-cgroup.h tuned-kernel-LOS-s5/block/blk-cgroup.h
--- android_kernel_samsung_msm8974/block/blk-cgroup.h	2018-03-05 17:54:33.363656805 -0300
+++ tuned-kernel-LOS-s5/block/blk-cgroup.h	2017-11-30 13:52:18.748691137 -0300
@@ -24,13 +24,7 @@
 /* Max limits for throttle policy */
 #define THROTL_IOPS_MAX		UINT_MAX
 
-#if defined(CONFIG_BLK_CGROUP) || defined(CONFIG_BLK_CGROUP_MODULE)
-
-#ifndef CONFIG_BLK_CGROUP
-/* When blk-cgroup is a module, its subsys_id isn't a compile-time constant */
-extern struct cgroup_subsys blkio_subsys;
-#define blkio_subsys_id blkio_subsys.subsys_id
-#endif
+#ifdef CONFIG_BLK_CGROUP
 
 enum stat_type {
 	/* Total time spent (in ns) between request dispatch to the driver and
@@ -303,7 +297,7 @@
 static inline void blkiocg_set_start_empty_time(struct blkio_group *blkg) {}
 #endif
 
-#if defined(CONFIG_BLK_CGROUP) || defined(CONFIG_BLK_CGROUP_MODULE)
+#ifdef CONFIG_BLK_CGROUP
 extern struct blkio_cgroup blkio_root_cgroup;
 extern struct blkio_cgroup *cgroup_to_blkio_cgroup(struct cgroup *cgroup);
 extern struct blkio_cgroup *task_blkio_cgroup(struct task_struct *tsk);
diff -ruBb android_kernel_samsung_msm8974/block/blk-core.c tuned-kernel-LOS-s5/block/blk-core.c
--- android_kernel_samsung_msm8974/block/blk-core.c	2018-03-05 17:54:33.363656805 -0300
+++ tuned-kernel-LOS-s5/block/blk-core.c	2017-11-30 13:52:18.756691185 -0300
@@ -381,17 +381,24 @@
 
 		spin_lock_irq(q->queue_lock);
 
+		/*
+		 * The caller might be trying to drain @q before its
+		 * elevator is initialized.
+		 */
+		if (q->elevator)
 		elv_drain_elevator(q);
+
 		if (drain_all)
 			blk_throtl_drain(q);
 
 		/*
 		 * This function might be called on a queue which failed
-		 * driver init after queue creation.  Some drivers
-		 * (e.g. fd) get unhappy in such cases.  Kick queue iff
-		 * dispatch queue has something on it.
+		 * driver init after queue creation or is not yet fully
+		 * active yet.  Some drivers (e.g. fd and loop) get unhappy
+		 * in such cases.  Kick queue iff dispatch queue has
+		 * something on it and @q has request_fn set.
 		 */
-		if (!list_empty(&q->queue_head))
+		if (!list_empty(&q->queue_head) && q->request_fn)
 			__blk_run_queue(q);
 
 		drain |= q->rq.elvpriv;
@@ -444,12 +451,7 @@
 	spin_unlock_irq(lock);
 	mutex_unlock(&q->sysfs_lock);
 
-	/*
-	 * Drain all requests queued before DEAD marking.  The caller might
-	 * be trying to tear down @q before its elevator is initialized, in
-	 * which case we don't want to call into draining.
-	 */
-	if (q->elevator)
+	/* drain all requests queued before DEAD marking */
 		blk_drain_queue(q, true);
 
 	/* @q won't process any more request, flush async actions */
@@ -509,6 +511,7 @@
 	q->backing_dev_info.capabilities = BDI_CAP_MAP_COPY;
 	q->backing_dev_info.name = "block";
 	q->node = node_id;
+	*q->elevator_hard = '\0';
 
 	err = bdi_init(&q->backing_dev_info);
 	if (err)
@@ -520,6 +523,7 @@
 	setup_timer(&q->backing_dev_info.laptop_mode_wb_timer,
 		    laptop_mode_timer_fn, (unsigned long) q);
 	setup_timer(&q->timeout, blk_rq_timed_out_timer, (unsigned long) q);
+	INIT_LIST_HEAD(&q->queue_head);
 	INIT_LIST_HEAD(&q->timeout_list);
 	INIT_LIST_HEAD(&q->icq_list);
 	INIT_LIST_HEAD(&q->flush_queue[0]);
Only in tuned-kernel-LOS-s5/block: blk-core.c.orig
diff -ruBb android_kernel_samsung_msm8974/block/blk-sysfs.c tuned-kernel-LOS-s5/block/blk-sysfs.c
--- android_kernel_samsung_msm8974/block/blk-sysfs.c	2018-03-05 17:54:33.363656805 -0300
+++ tuned-kernel-LOS-s5/block/blk-sysfs.c	2017-11-30 13:42:39.265170041 -0300
@@ -319,6 +319,12 @@
 	.store = elv_iosched_store,
 };
 
+static struct queue_sysfs_entry queue_iosched_hard_entry = {
+	.attr = {.name = "scheduler_hard", .mode = S_IRUGO | S_IWUSR },
+	.show = elv_iosched_hard_show,
+	.store = elv_iosched_hard_store,
+};
+
 static struct queue_sysfs_entry queue_hw_sector_size_entry = {
 	.attr = {.name = "hw_sector_size", .mode = S_IRUGO },
 	.show = queue_logical_block_size_show,
@@ -398,6 +404,7 @@
 	&queue_max_integrity_segments_entry.attr,
 	&queue_max_segment_size_entry.attr,
 	&queue_iosched_entry.attr,
+	&queue_iosched_hard_entry.attr,
 	&queue_hw_sector_size_entry.attr,
 	&queue_logical_block_size_entry.attr,
 	&queue_physical_block_size_entry.attr,
diff -ruBb android_kernel_samsung_msm8974/block/cfq-iosched.c tuned-kernel-LOS-s5/block/cfq-iosched.c
--- android_kernel_samsung_msm8974/block/cfq-iosched.c	2018-03-05 17:54:33.367656828 -0300
+++ tuned-kernel-LOS-s5/block/cfq-iosched.c	2017-11-30 13:52:18.760691210 -0300
@@ -3887,8 +3887,6 @@
 	},
 	.plid = BLKIO_POLICY_PROP,
 };
-#else
-static struct blkio_policy_type blkio_policy_cfq;
 #endif
 
 static int __init cfq_init(void)
@@ -3919,14 +3917,17 @@
 		return ret;
 	}
 
+#ifdef CONFIG_CFQ_GROUP_IOSCHED
 	blkio_policy_register(&blkio_policy_cfq);
-
+#endif
 	return 0;
 }
 
 static void __exit cfq_exit(void)
 {
+#ifdef CONFIG_CFQ_GROUP_IOSCHED
 	blkio_policy_unregister(&blkio_policy_cfq);
+#endif
 	elv_unregister(&iosched_cfq);
 	kmem_cache_destroy(cfq_pool);
 }
diff -ruBb android_kernel_samsung_msm8974/block/elevator.c tuned-kernel-LOS-s5/block/elevator.c
--- android_kernel_samsung_msm8974/block/elevator.c	2018-03-05 17:54:33.367656828 -0300
+++ tuned-kernel-LOS-s5/block/elevator.c	2017-11-30 13:52:18.760691210 -0300
@@ -1103,10 +1103,18 @@
 			  size_t count)
 {
 	int ret;
+	char elevator_name[ELV_NAME_MAX];
 
 	if (!q->elevator)
 		return count;
 
+	if ((strlen(q->elevator_hard) != 0) && (! strstr(name, q->elevator_hard)))
+	{
+		sscanf(name, "%s", elevator_name);
+		printk(KERN_ERR "elevator: switch to %s failed due to Boeffla hard value set to %s\n", elevator_name, q->elevator_hard);
+		return count;
+	}
+
 	ret = __elevator_change(q, name);
 	if (!ret)
 		return count;
@@ -1140,6 +1148,20 @@
 	return len;
 }
 
+ssize_t elv_iosched_hard_store(struct request_queue *q, const char *name,
+			  size_t count)
+{
+	if (strlen(name) < ELV_NAME_MAX)
+		sscanf(name, "%s", q->elevator_hard);
+
+	return count;
+}
+
+ssize_t elv_iosched_hard_show(struct request_queue *q, char *name)
+{
+	return sprintf(name, "%s\n", q->elevator_hard);
+}
+
 struct request *elv_rb_former_request(struct request_queue *q,
 				      struct request *rq)
 {
Only in tuned-kernel-LOS-s5/block: fiops-iosched.c
diff -ruBb android_kernel_samsung_msm8974/block/Kconfig.iosched tuned-kernel-LOS-s5/block/Kconfig.iosched
--- android_kernel_samsung_msm8974/block/Kconfig.iosched	2018-03-05 17:54:33.359656781 -0300
+++ tuned-kernel-LOS-s5/block/Kconfig.iosched	2017-11-29 14:48:06.408841791 -0300
@@ -45,8 +45,6 @@
 
 config IOSCHED_CFQ
 	tristate "CFQ I/O scheduler"
-	# If BLK_CGROUP is a module, CFQ has to be built as module.
-	depends on (BLK_CGROUP=m && m) || !BLK_CGROUP || BLK_CGROUP=y
 	default y
 	---help---
 	  The CFQ I/O scheduler tries to distribute bandwidth equally
@@ -56,8 +54,6 @@
 
 	  This is the default I/O scheduler.
 
-	  Note: If BLK_CGROUP=m, then CFQ can be built only as module.
-
 config CFQ_GROUP_IOSCHED
 	bool "CFQ Group Scheduling support"
 	depends on IOSCHED_CFQ && BLK_CGROUP
@@ -65,6 +61,37 @@
 	---help---
 	  Enable group IO scheduling in CFQ.
 
+config IOSCHED_SIO
+	tristate "Simple I/O scheduler"
+	default y
+	---help---
+	  The Simple I/O scheduler is an extremely simple scheduler,
+	  based on noop and deadline, that relies on deadlines to
+	  ensure fairness. The algorithm does not do any sorting but
+	  basic merging, trying to keep a minimum overhead. It is aimed
+	  mainly for aleatory access devices (eg: flash devic
+
+config IOSCHED_FIOPS
+	tristate "IOPS based I/O scheduler"
+	default y
+	---help---
+	  This is an IOPS based I/O scheduler. It will try to distribute
+          IOPS equally among all processes in the system. It's mainly for
+          Flash based storage.
+          
+config IOSCHED_ZEN
+	tristate "Zen I/O scheduler"
+	default y
+	---help---
+		FCFS, dispatches are back-inserted, deadlines ensure fairness.
+		Should work best with devices where there is no travel delay.
+
+config IOSCHED_TRIPNDROID
+	tristate "Tripndroid"
+	default y
+	---help---
+	  The Trip N Droid scheduler
+
 config IOSCHED_BFQ
 	tristate "BFQ I/O scheduler"
 	depends on EXPERIMENTAL
@@ -123,6 +150,18 @@
 	config DEFAULT_NOOP
 		bool "No-op"
 
+	config DEFAULT_SIO
+		bool "SIO" if IOSCHED_SIO=y
+
+	config DEFAULT_FIOPS
+		bool "FIOPS" if IOSCHED_FIOPS=y
+
+	config DEFAULT_ZEN
+		bool "ZEN" if IOSCHED_ZEN=y
+
+	config DEFAULT_TRIPNDROID
+		bool "TRIPNDROID" if IOSCHED_TRIPNDROID=y
+
 endchoice
 
 config DEFAULT_IOSCHED
@@ -130,8 +169,12 @@
 	default "deadline" if DEFAULT_DEADLINE
 	default "row" if DEFAULT_ROW
 	default "cfq" if DEFAULT_CFQ
-	default "bfq" if DEFAULT_BFQ
 	default "noop" if DEFAULT_NOOP
+	default "sio" if DEFAULT_SIO
+	default "fiops" if DEFAULT_FIOPS
+	default "zen" if DEFAULT_ZEN
+	default "tripndroid" if DEFAULT_TRIPNDROID
+	default "bfq" if DEFAULT_BFQ
 
 endmenu
 
diff -ruBb android_kernel_samsung_msm8974/block/Makefile tuned-kernel-LOS-s5/block/Makefile
--- android_kernel_samsung_msm8974/block/Makefile	2018-03-05 17:54:33.359656781 -0300
+++ tuned-kernel-LOS-s5/block/Makefile	2017-10-20 13:09:47.275708366 -0300
@@ -17,6 +17,10 @@
 obj-$(CONFIG_IOSCHED_ROW)	+= row-iosched.o
 obj-$(CONFIG_IOSCHED_CFQ)	+= cfq-iosched.o
 obj-$(CONFIG_IOSCHED_TEST)	+= test-iosched.o
+obj-$(CONFIG_IOSCHED_SIO)	+= sio-iosched.o
+obj-$(CONFIG_IOSCHED_FIOPS)	+= fiops-iosched.o
+obj-$(CONFIG_IOSCHED_ZEN)	+= zen-iosched.o
+obj-$(CONFIG_IOSCHED_TRIPNDROID)	+= tripndroid-iosched.o
 obj-$(CONFIG_IOSCHED_BFQ)      += bfq-iosched.o
 
 obj-$(CONFIG_BLOCK_COMPAT)	+= compat_ioctl.o
Only in tuned-kernel-LOS-s5/block: new
Only in tuned-kernel-LOS-s5/block: sio-iosched.c
Only in tuned-kernel-LOS-s5/block: tripndroid-iosched.c
Only in tuned-kernel-LOS-s5/block: zen-iosched.c
diff -ruBb android_kernel_samsung_msm8974/drivers/base/cpu.c tuned-kernel-LOS-s5/drivers/base/cpu.c
--- android_kernel_samsung_msm8974/drivers/base/cpu.c	2018-03-05 17:54:33.455657352 -0300
+++ tuned-kernel-LOS-s5/drivers/base/cpu.c	2017-10-20 13:09:47.523710859 -0300
@@ -16,6 +16,18 @@
 
 #include "base.h"
 
+#define ONL_CONT_MODE_SYSFS 	0	// core online status controlled by sysfs (mpdecision)
+#define ONL_CONT_MODE_ONLINE 	1	// core is forced online
+#define ONL_CONT_MODE_OFFLINE	2	// core is forced offline 
+#define ONL_CONT_MODE_LOCK4_3	3	// core 4 is forced offline but locked to core 3 (only allowed for core 4 !)
+#define ID_CPU_CORE_3			2	// internal id of CPU core 3
+#define ID_CPU_CORE_4			3	// internal id of CPU core 4
+
+static int online_control_mode[4] = {ONL_CONT_MODE_SYSFS, 
+									ONL_CONT_MODE_SYSFS, 
+									ONL_CONT_MODE_SYSFS, 
+									ONL_CONT_MODE_SYSFS};
+
 struct bus_type cpu_subsys = {
 	.name = "cpu",
 	.dev_name = "cpu",
@@ -39,19 +51,43 @@
 				  const char *buf, size_t count)
 {
 	struct cpu *cpu = container_of(dev, struct cpu, dev);
+	struct device *dev3;
 	ssize_t ret;
 
+	// AP: this sysfs only works when control mode is in sysfs-mode
+	if (online_control_mode[cpu->dev.id] != ONL_CONT_MODE_SYSFS)
+		return count;
+
 	cpu_hotplug_driver_lock();
 	switch (buf[0]) {
 	case '0':
 		ret = cpu_down(cpu->dev.id);
 		if (!ret)
 			kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
+		// handling if core lock4_3 is active for fourth core
+		if ((cpu->dev.id == ID_CPU_CORE_3) && 
+			(online_control_mode[ID_CPU_CORE_4] == ONL_CONT_MODE_LOCK4_3))
+		{
+			dev3 = get_cpu_device(ID_CPU_CORE_4);
+			ret = cpu_down(ID_CPU_CORE_4);
+			if (!ret)
+				kobject_uevent(&dev3->kobj, KOBJ_OFFLINE);
+		}
 		break;
 	case '1':
 		ret = cpu_up(cpu->dev.id);
 		if (!ret)
 			kobject_uevent(&dev->kobj, KOBJ_ONLINE);
+
+		// handling if core lock4_3 is active for fourth core
+		if ((cpu->dev.id == ID_CPU_CORE_3) && 
+			(online_control_mode[3] == ONL_CONT_MODE_LOCK4_3))
+		{
+			dev3 = get_cpu_device(ID_CPU_CORE_4);
+			ret = cpu_up(ID_CPU_CORE_4);
+			if (!ret)
+				kobject_uevent(&dev3->kobj, KOBJ_ONLINE);
+		}
 		break;
 	default:
 		ret = -EINVAL;
@@ -64,9 +100,87 @@
 }
 static DEVICE_ATTR(online, 0644, show_online, store_online);
 
+static ssize_t show_online_control(struct device *dev,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	
+	struct cpu *cpu = container_of(dev, struct cpu, dev);
+
+	switch (online_control_mode[cpu->dev.id])
+	{
+		case ONL_CONT_MODE_SYSFS:
+			return sprintf(buf, "0: sysfs controlled\n");
+			break;
+		case ONL_CONT_MODE_ONLINE:
+			return sprintf(buf, "1: forced online\n");
+			break;
+		case ONL_CONT_MODE_OFFLINE:
+			return sprintf(buf, "2: forced offline\n");
+			break;
+	}
+	
+	return sprintf(buf, "Core online control invalid status\n");
+}
+
+static ssize_t __ref store_online_control(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct cpu *cpu = container_of(dev, struct cpu, dev);
+	ssize_t ret;
+
+	cpu_hotplug_driver_lock();
+	switch (buf[0]) 
+	{
+		case '0': // control via sysfs
+			ret = cpu_down(cpu->dev.id);
+			if (!ret)
+				kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
+			online_control_mode[cpu->dev.id] = ONL_CONT_MODE_SYSFS;
+			break;
+			
+		case '1': // forced online
+			ret = cpu_up(cpu->dev.id);
+			if (!ret)
+				kobject_uevent(&dev->kobj, KOBJ_ONLINE);
+			online_control_mode[cpu->dev.id] = ONL_CONT_MODE_ONLINE;
+			break;
+			
+		case '2': // forced offline
+			ret = cpu_down(cpu->dev.id);
+			if (!ret)
+				kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
+			online_control_mode[cpu->dev.id] = ONL_CONT_MODE_OFFLINE;
+			break;
+			
+		case '3': // only allowed for CPU core 4 - force offline but lock it to core 3
+			if (cpu->dev.id == ID_CPU_CORE_4)
+			{
+				ret = cpu_down(cpu->dev.id);
+				if (!ret)
+					kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
+				online_control_mode[cpu->dev.id] = ONL_CONT_MODE_LOCK4_3;
+			}
+			else
+				ret = -EINVAL;
+			break;
+			
+		default:
+			ret = -EINVAL;
+	}
+	cpu_hotplug_driver_unlock();
+
+	if (ret >= 0)
+		ret = count;
+	return ret;
+}
+static DEVICE_ATTR(online_control, 0644, show_online_control, store_online_control);
+
 static void __cpuinit register_cpu_control(struct cpu *cpu)
 {
 	device_create_file(&cpu->dev, &dev_attr_online);
+	device_create_file(&cpu->dev, &dev_attr_online_control);
 }
 void unregister_cpu(struct cpu *cpu)
 {
diff -ruBb android_kernel_samsung_msm8974/drivers/base/regmap/regcache-rbtree.c tuned-kernel-LOS-s5/drivers/base/regmap/regcache-rbtree.c
--- android_kernel_samsung_msm8974/drivers/base/regmap/regcache-rbtree.c	2018-03-05 17:54:33.459657375 -0300
+++ tuned-kernel-LOS-s5/drivers/base/regmap/regcache-rbtree.c	2017-11-08 18:41:05.942982109 -0300
@@ -21,7 +21,7 @@
 static int regcache_rbtree_write(struct regmap *map, unsigned int reg,
 				 unsigned int value);
 static int regcache_rbtree_exit(struct regmap *map);
-
+#if 0
 struct regcache_rbtree_node {
 	/* the actual rbtree node holding this block */
 	struct rb_node node;
@@ -32,6 +32,19 @@
 	/* number of registers available in the block */
 	unsigned int blklen;
 } __attribute__ ((packed));
+#endif
+struct regcache_rbtree_node {
+	/* block of adjacent registers */
+	void *block;
+	/* Which registers are present */
+	long *cache_present;
+	/* base register handled by this block */
+	unsigned int base_reg;
+	/* number of registers available in the block */
+	unsigned int blklen;
+	/* the actual rbtree node holding this block */
+	struct rb_node node;
+} __attribute__ ((packed));
 
 struct regcache_rbtree_ctx {
 	struct rb_root root;
diff -ruBb android_kernel_samsung_msm8974/drivers/battery/max77804k_charger.c tuned-kernel-LOS-s5/drivers/battery/max77804k_charger.c
--- android_kernel_samsung_msm8974/drivers/battery/max77804k_charger.c	2018-03-05 17:54:33.463657400 -0300
+++ tuned-kernel-LOS-s5/drivers/battery/max77804k_charger.c	2017-10-20 13:09:47.543711060 -0300
@@ -14,6 +14,10 @@
 #include <linux/mfd/max77804k-private.h>
 #include <linux/of_gpio.h>
 
+#ifdef CONFIG_CHARGE_LEVEL
+#include <linux/charge_level.h>
+#endif
+
 #ifdef CONFIG_USB_HOST_NOTIFY
 #include <linux/host_notify.h>
 #endif
@@ -41,6 +45,17 @@
 #define SIOP_WIRELESS_CHARGING_LIMIT_CURRENT 680
 #define SLOW_CHARGING_CURRENT_STANDARD 400
 
+#ifdef CONFIG_CHARGE_LEVEL
+int ac_level = AC_CHARGE_LEVEL_DEFAULT;
+int usb_level = USB_CHARGE_LEVEL_DEFAULT;
+int wireless_level = WIRELESS_CHARGE_LEVEL_DEFAULT;
+
+char charge_info_text[30] = "";
+int charge_level_nom = 0;		// default is no charger connected
+int charge_level_cur = 0;
+int charge_stock_logic = 1;		// default is stock charging logic
+#endif
+
 struct max77804k_charger_data {
 	struct max77804k_dev	*max77804k;
 
@@ -922,6 +937,9 @@
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_NOW:
 		val->intval = max77804k_get_input_current(charger);
+#ifdef CONFIG_CHARGE_LEVEL
+		charge_level_cur = val->intval;
+#endif
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_TYPE:
 		if (!charger->is_charging)
@@ -1077,6 +1095,64 @@
 				charger->pdata->charging_current[
 				val->intval].full_check_current_2nd);
 		}
+
+#ifdef CONFIG_CHARGE_LEVEL
+			charge_stock_logic = 1;
+			charge_level_nom = 9999;	// virtual charge rate for stock logic as we do not know the rate
+
+			switch(charger->cable_type)
+			{
+				case POWER_SUPPLY_TYPE_BATTERY:
+					charge_level_nom = 0;
+					sprintf(charge_info_text, "No charger");
+					break;
+					
+				case POWER_SUPPLY_TYPE_MAINS:
+					sprintf(charge_info_text, "AC charger");
+					if (ac_level != 0)
+					{
+						charge_stock_logic = 0;
+						charge_level_nom = ac_level;
+						set_charging_current = ac_level;
+						set_charging_current_max = ac_level;
+					}
+					break;
+
+				case POWER_SUPPLY_TYPE_USB:
+				case POWER_SUPPLY_TYPE_USB_DCP:
+				case POWER_SUPPLY_TYPE_USB_CDP:
+				case POWER_SUPPLY_TYPE_USB_ACA:
+				case POWER_SUPPLY_TYPE_CARDOCK:
+				case POWER_SUPPLY_TYPE_OTG:
+					sprintf(charge_info_text, "USB charger");
+					if (usb_level != 0)
+					{
+						charge_stock_logic = 0;
+						charge_level_nom = usb_level;
+						set_charging_current = usb_level;
+						set_charging_current_max = usb_level;
+					}
+					break;
+
+				case POWER_SUPPLY_TYPE_WIRELESS:
+					sprintf(charge_info_text, "Wireless charger");
+					if (wireless_level != 0)
+					{
+						charge_stock_logic = 0;
+						charge_level_nom = wireless_level;
+						set_charging_current = wireless_level;
+						set_charging_current_max = wireless_level;
+					}
+					break;
+
+				default:
+					sprintf(charge_info_text, "Unknown charger");
+					break;
+			}
+
+			pr_info("Boeffla-Kernel: charge level type: %s, stock logic: %d, nominal mA: %d\n", charge_info_text, charge_stock_logic, charge_level_nom);
+#endif
+
 		max77804k_set_charger_state(charger, charger->is_charging);
 		/* if battery full, only disable charging  */
 		if ((charger->status == POWER_SUPPLY_STATUS_CHARGING) ||
@@ -1115,6 +1191,10 @@
 				val->intval);
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+#ifdef CONFIG_CHARGE_LEVEL
+		if (charge_stock_logic == 0)
+			break;
+#endif
 		charger->siop_level = val->intval;
 		if (charger->is_charging) {
 			/* decrease the charging current according to siop level */
diff -ruBb android_kernel_samsung_msm8974/drivers/battery/sec_battery.c tuned-kernel-LOS-s5/drivers/battery/sec_battery.c
--- android_kernel_samsung_msm8974/drivers/battery/sec_battery.c	2018-03-05 17:54:33.463657400 -0300
+++ tuned-kernel-LOS-s5/drivers/battery/sec_battery.c	2017-10-20 13:09:47.547711101 -0300
@@ -9,6 +9,10 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+#include <linux/kt_wake_funcs.h>
+unsigned int prev_cable_state;
+unsigned int is_charging;
+
 #include <linux/battery/sec_battery.h>
 #if defined(CONFIG_SENSORS_QPNP_ADC_VOLTAGE)
 #include <linux/qpnp/qpnp-adc.h>
@@ -2409,6 +2413,13 @@
 
 	dev_dbg(battery->dev, "%s: End\n", __func__);
 
+	if (battery->cable_type != prev_cable_state)
+	{
+		if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+			is_charging = 0;
+		else
+			is_charging = 1;
+	}
 	return;
 }
 
diff -ruBb android_kernel_samsung_msm8974/drivers/cpufreq/cpu-boost.c tuned-kernel-LOS-s5/drivers/cpufreq/cpu-boost.c
--- android_kernel_samsung_msm8974/drivers/cpufreq/cpu-boost.c	2018-03-05 17:54:33.527657780 -0300
+++ tuned-kernel-LOS-s5/drivers/cpufreq/cpu-boost.c	2017-10-20 13:09:47.703712669 -0300
@@ -45,16 +45,28 @@
 
 static struct work_struct input_boost_work;
 
+#ifdef CONFIG_TOUCHBOOST_CONTROL
+unsigned int input_boost_status = 1;
+#endif
+
 static unsigned int boost_ms;
 module_param(boost_ms, uint, 0644);
 
 static unsigned int sync_threshold;
 module_param(sync_threshold, uint, 0644);
 
+#ifdef CONFIG_TOUCHBOOST_CONTROL
+unsigned int input_boost_freq;
+#else
 static unsigned int input_boost_freq;
+#endif
 module_param(input_boost_freq, uint, 0644);
 
+#ifdef CONFIG_TOUCHBOOST_CONTROL
+unsigned int input_boost_ms = 40;
+#else
 static unsigned int input_boost_ms = 40;
+#endif
 module_param(input_boost_ms, uint, 0644);
 
 static u64 last_input_time;
@@ -228,7 +240,7 @@
 
 static void do_input_boost(struct work_struct *work)
 {
-	unsigned int i, ret;
+	unsigned int i, ret, freq;
 	struct cpu_sync *i_sync_info;
 	struct cpufreq_policy policy;
 
@@ -239,11 +251,18 @@
 		ret = cpufreq_get_policy(&policy, i);
 		if (ret)
 			continue;
-		if (policy.cur >= input_boost_freq)
+
+		// ensure, touch boost freq does never exceed max scaling freq
+		if (input_boost_freq > policy.max)
+			freq = policy.max;
+		else
+			freq = input_boost_freq;
+
+		if (policy.cur >= freq)
 			continue;
 
 		cancel_delayed_work_sync(&i_sync_info->input_boost_rem);
-		i_sync_info->input_boost_min = input_boost_freq;
+		i_sync_info->input_boost_min = freq;
 		cpufreq_update_policy(i);
 		queue_delayed_work_on(i_sync_info->cpu, cpu_boost_wq,
 			&i_sync_info->input_boost_rem,
@@ -257,6 +276,12 @@
 {
 	u64 now;
 
+#ifdef CONFIG_TOUCHBOOST_CONTROL
+	// if touch boost (input boost) is switched off, do nothing
+	if (!input_boost_status)
+		return;
+#endif
+
 	if (!input_boost_freq)
 		return;
 
diff -ruBb android_kernel_samsung_msm8974/drivers/cpufreq/cpufreq.c tuned-kernel-LOS-s5/drivers/cpufreq/cpufreq.c
--- android_kernel_samsung_msm8974/drivers/cpufreq/cpufreq.c	2018-03-05 17:54:33.527657780 -0300
+++ tuned-kernel-LOS-s5/drivers/cpufreq/cpufreq.c	2017-11-23 23:35:34.450047161 -0300
@@ -31,6 +31,7 @@
 #include <linux/syscore_ops.h>
 
 #include <trace/events/power.h>
+#include <linux/kt_wake_funcs.h>
 
 /**
  * The "cpufreq driver" - the arch- or hardware-dependent low
@@ -49,6 +50,13 @@
 #endif
 static DEFINE_SPINLOCK(cpufreq_driver_lock);
 
+bool call_in_progress=false;
+
+static unsigned int min_freq_hardlimit[4] = {0, 0, 0, 0};
+static unsigned int max_freq_hardlimit[4] = {0, 0, 0, 0};
+#define GOVERNOR_NAME_MAX	16
+static char governor_hard[4][GOVERNOR_NAME_MAX];
+
 /*
  * cpu_policy_rwsem is a per CPU reader-writer semaphore designed to cure
  * all cpufreq/hotplug/workqueue/etc related lock issues.
@@ -464,11 +472,205 @@
 #ifdef CONFIG_SEC_PM
 #ifndef CONFIG_ARCH_MSM8226
 /* Disable scaling_min_freq store */
-	store_one(scaling_min_freq, min);
+//	store_one(scaling_min_freq, min);
 #endif
 #endif
 
-store_one(scaling_max_freq, max);
+// store_one(scaling_max_freq, max);
+
+/**
+ * show_scaling_min_freq_hardlimit - minimum scaling frequency hard limit 
+ */
+static ssize_t show_scaling_min_freq_hardlimit(struct cpufreq_policy *policy, char *buf)
+{							\
+	return sprintf(buf, "%u\n", min_freq_hardlimit[policy->cpu]);
+}
+
+/**
+ * store_scaling_min_freq_hardlimit() - minimum scaling frequency hard limit
+ */
+static ssize_t store_scaling_min_freq_hardlimit(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	unsigned int ret = -EINVAL;
+	unsigned int input;
+	int i;
+	struct cpufreq_frequency_table *table;
+
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1)
+		return -EINVAL;
+
+	// zero is an allowed value to disable the hard limit check
+	if (input == 0)
+	{
+		max_freq_hardlimit[policy->cpu] = 0;
+		pr_debug("cpufreq : max frequency hard limit check disabled\n");
+		return count;
+	}
+
+	// Get system frequency table
+	table = cpufreq_frequency_get_table(0);	
+
+	if (!table) 
+	{
+		pr_err("cpufreq : could not retrieve cpu freq table\n");
+		return -EINVAL;
+	} 
+
+	// Allow only frequencies in the system table
+	for (i = 0; (table[i].frequency != CPUFREQ_TABLE_END); i++) 
+		if (table[i].frequency == input) 
+		{
+			pr_debug("cpufreq : frequency for minimum scaling freq hard limit found\n");
+			min_freq_hardlimit[policy->cpu] = input;
+			return count;
+		}
+
+	pr_err("cpufreq : invalid frequency requested for minimum scaling freq hard limit\n");
+	return -EINVAL;
+}
+
+
+/**
+ * show_scaling_max_freq_hardlimit - maximum scaling frequency hard limit 
+ */
+static ssize_t show_scaling_max_freq_hardlimit(struct cpufreq_policy *policy, char *buf)
+{							\
+	return sprintf(buf, "%u\n", max_freq_hardlimit[policy->cpu]);
+}
+
+
+/**
+ * store_scaling_max_freq_hardlimit() - maximum scaling frequency hard limit
+ */
+static ssize_t store_scaling_max_freq_hardlimit(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	unsigned int ret = -EINVAL;
+	unsigned int input;
+	int i;
+	struct cpufreq_frequency_table *table;
+
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1)
+		return -EINVAL;
+
+	// zero is an allowed value to disable the hard limit check
+	if (input == 0)
+	{
+		min_freq_hardlimit[policy->cpu] = 0;
+		pr_debug("cpufreq : min frequency hard limit check disabled\n");
+		return count;
+	}
+
+	// Get system frequency table
+	table = cpufreq_frequency_get_table(0);	
+
+	if (!table) 
+	{
+		pr_err("cpufreq : could not retrieve cpu freq table\n");
+		return -EINVAL;
+	} 
+
+	// Allow only frequencies in the system table
+	for (i = 0; (table[i].frequency != CPUFREQ_TABLE_END); i++) 
+		if (table[i].frequency == input) 
+		{
+			pr_debug("cpufreq : frequency for maximum scaling freq hard limit found\n");
+			max_freq_hardlimit[policy->cpu] = input;
+			return count;
+		}
+
+	pr_err("cpufreq : invalid frequency requested for maximum scaling freq hard limit\n");
+	return -EINVAL;
+}
+
+
+/**
+ * store_scaling_min_freq() - minimum scaling frequency
+ */
+static ssize_t store_scaling_min_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	unsigned int ret = -EINVAL;
+	struct cpufreq_policy new_policy;
+
+	ret = cpufreq_get_policy(&new_policy, policy->cpu);
+	if (ret)
+		return -EINVAL;
+
+	ret = sscanf(buf, "%u", &new_policy.min);
+	if (ret != 1)
+		return -EINVAL;
+
+	// if hard limit check is enabled + if new min frequency is below hard limit,
+	// overwrite with hard limit
+	if (min_freq_hardlimit[policy->cpu] != 0)
+		if (new_policy.min < min_freq_hardlimit[policy->cpu])
+			new_policy.min = min_freq_hardlimit[policy->cpu];
+
+	policy->user_policy.min = new_policy.min;
+	new_policy.user_policy.min = new_policy.min;
+
+	ret = cpufreq_driver->verify(&new_policy);
+	if (ret)
+		pr_err("cpufreq: Frequency verification failed\n");
+
+	ret = __cpufreq_set_policy(policy, &new_policy);
+
+	return ret ? ret : count;
+}
+
+/**
+ * store_scaling_max_freq() - maximum scaling frequency
+ */
+static ssize_t store_scaling_max_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	unsigned int ret = -EINVAL;
+	struct cpufreq_policy new_policy;
+
+	ret = cpufreq_get_policy(&new_policy, policy->cpu);
+	if (ret)
+		return -EINVAL;
+
+	ret = sscanf(buf, "%u", &new_policy.max);
+	if (ret != 1)
+		return -EINVAL;
+
+	// if hard limit check is enabled + if new max frequency is above hard limit,
+	// overwrite with hard limit
+	if (max_freq_hardlimit[policy->cpu] != 0)
+		if (new_policy.max > max_freq_hardlimit[policy->cpu])
+			new_policy.max = max_freq_hardlimit[policy->cpu];
+
+	policy->user_policy.max = new_policy.max;
+	new_policy.user_policy.max = new_policy.max;
+
+	ret = cpufreq_driver->verify(&new_policy);
+	if (ret)
+		pr_err("cpufreq: Frequency verification failed\n");
+
+	ret = __cpufreq_set_policy(policy, &new_policy);
+
+	return ret ? ret : count;
+}
+
+/**
+ * show_scaling_governor_hard - scaling governor hard lock
+ */
+static ssize_t show_scaling_governor_hard(struct cpufreq_policy *policy, char *buf)
+{							\
+	return sprintf(buf, "%s\n", governor_hard[policy->cpu]);
+}
+
+/**
+ * store_scaling_governor_hard - scaling governor hard lock
+ */
+static ssize_t store_scaling_governor_hard(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	if (strlen(buf) < GOVERNOR_NAME_MAX)
+		sscanf(buf, "%s", governor_hard[policy->cpu]);
+
+	return count;
+}
 
 /**
  * show_cpuinfo_cur_freq - current CPU frequency as detected by hardware
@@ -517,6 +719,13 @@
 	if (ret != 1)
 		return -EINVAL;
 
+	// if hard limit for governor is set, only allow this governor to be set
+	if ((strlen(governor_hard[policy->cpu]) != 0) && (! strstr(str_governor, governor_hard[policy->cpu])))
+	{
+		printk(KERN_ERR "scaling governor: switch to %s failed due to Boeffla hard value set to %s\n", str_governor, governor_hard[policy->cpu]);
+		return -EINVAL;
+	}
+
 	if (cpufreq_parse_governor(str_governor, &new_policy.policy,
 						&new_policy.governor))
 		return -EINVAL;
@@ -645,6 +854,12 @@
 	return sprintf(buf, "%u\n", policy->cpuinfo.max_freq);
 }
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+extern ssize_t show_UV_mV_table(struct cpufreq_policy *policy, char *buf);
+extern ssize_t store_UV_mV_table(struct cpufreq_policy *policy,
+				 const char *buf, size_t count);
+#endif
+
 cpufreq_freq_attr_ro_perm(cpuinfo_cur_freq, 0400);
 cpufreq_freq_attr_ro(cpuinfo_min_freq);
 cpufreq_freq_attr_ro(cpuinfo_max_freq);
@@ -664,6 +879,7 @@
 #else
 cpufreq_freq_attr_rw(scaling_min_freq);
 #endif
+cpufreq_freq_attr_rw(scaling_min_freq_hardlimit);
 #else
 #ifdef CONFIG_ARCH_MSM8226
 cpufreq_freq_attr_ro(scaling_min_freq);
@@ -672,9 +888,13 @@
 #endif
 #endif
 
-
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+cpufreq_freq_attr_rw(UV_mV_table);
+#endif
 cpufreq_freq_attr_rw(scaling_max_freq);
+cpufreq_freq_attr_rw(scaling_max_freq_hardlimit);
 cpufreq_freq_attr_rw(scaling_governor);
+cpufreq_freq_attr_rw(scaling_governor_hard);
 cpufreq_freq_attr_rw(scaling_setspeed);
 
 static struct attribute *default_attrs[] = {
@@ -682,7 +902,9 @@
 	&cpuinfo_max_freq.attr,
 	&cpuinfo_transition_latency.attr,
 	&scaling_min_freq.attr,
+	&scaling_min_freq_hardlimit.attr,
 	&scaling_max_freq.attr,
+	&scaling_max_freq_hardlimit.attr,
 	&affected_cpus.attr,
 	&cpu_utilization.attr,
 #ifdef CONFIG_SEC_PM
@@ -690,9 +912,13 @@
 #endif
 	&related_cpus.attr,
 	&scaling_governor.attr,
+	&scaling_governor_hard.attr,
 	&scaling_driver.attr,
 	&scaling_available_governors.attr,
 	&scaling_setspeed.attr,
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+	&UV_mV_table.attr,
+#endif
 	NULL
 };
 
@@ -1051,6 +1277,14 @@
 		pr_debug("initialization failed\n");
 		goto err_unlock_policy;
 	}
+
+	/*
+	 * affected cpus must always be the one, which are online. We aren't
+	 * managing offline cpus here.
+	 */
+
+	cpumask_and(policy->cpus, policy->cpus, cpu_online_mask);
+
 	policy->user_policy.min = policy->min;
 	policy->user_policy.max = policy->max;
 
@@ -1899,6 +2133,12 @@
 }
 EXPORT_SYMBOL(cpufreq_update_policy);
 
+void set_call_in_progress(bool state)
+{
+	call_in_progress = state;
+	//pr_alert("CALL IN PROGRESS: %d\n", state);
+}
+
 static int __cpuinit cpufreq_cpu_callback(struct notifier_block *nfb,
 					unsigned long action, void *hcpu)
 {
@@ -1950,6 +2190,7 @@
 {
 	unsigned long flags;
 	int ret;
+	struct cpufreq_frequency_table *table;
 
 	if (cpufreq_disabled())
 		return -ENODEV;
@@ -1997,6 +2238,24 @@
 	register_hotcpu_notifier(&cpufreq_cpu_notifier);
 	pr_debug("driver %s up and running\n", driver_data->name);
 
+	// Initialize min and max scaling freq hard limits
+	table = cpufreq_frequency_get_table(0);	
+	if (!table) 
+	{
+		pr_err("cpufreq : could not retrieve cpu freq table\n");
+	} 
+	else
+	{
+		int i;
+		for (i = 0; i < nr_cpu_ids; i++)
+		{
+			min_freq_hardlimit[i] = CONFIG_MSM_CPU_FREQ_MIN;
+			max_freq_hardlimit[i] = CONFIG_MSM_CPU_FREQ_MAX;
+			sprintf(governor_hard[i], "%s", "");
+		}
+		pr_info("cpufreq : minimum/maximum scaling freq hard limit set to: %u %u\n", CONFIG_MSM_CPU_FREQ_MIN, CONFIG_MSM_CPU_FREQ_MAX);
+	}
+
 	return 0;
 err_if_unreg:
 	subsys_interface_unregister(&cpufreq_interface);
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_impulse.c
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_intelliactive.c
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_intellidemand.c
diff -ruBb android_kernel_samsung_msm8974/drivers/cpufreq/cpufreq_interactive.c tuned-kernel-LOS-s5/drivers/cpufreq/cpufreq_interactive.c
--- android_kernel_samsung_msm8974/drivers/cpufreq/cpufreq_interactive.c	2018-03-05 17:54:33.527657780 -0300
+++ tuned-kernel-LOS-s5/drivers/cpufreq/cpufreq_interactive.c	2018-02-28 11:57:26.611735923 -0300
@@ -35,8 +35,8 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/cpufreq_interactive.h>
 
-#define CONFIG_MODE_AUTO_CHANGE
-#define CONFIG_RETENTION_CHANGE
+//#define CONFIG_MODE_AUTO_CHANGE
+//#define CONFIG_RETENTION_CHANGE
 
 static int active_count;
 
@@ -69,17 +69,17 @@
 static struct mutex gov_lock;
 
 /* Hi speed to bump to from lo speed when load burst (default max) */
-static unsigned int hispeed_freq;
+static unsigned int hispeed_freq = 2265600;
 
 /* Go to hi speed when CPU load at or above this value. */
-#define DEFAULT_GO_HISPEED_LOAD 99
+#define DEFAULT_GO_HISPEED_LOAD 90
 static unsigned long go_hispeed_load = DEFAULT_GO_HISPEED_LOAD;
 
 /* Sampling down factor to be applied to min_sample_time at max freq */
-static unsigned int sampling_down_factor;
+static unsigned int sampling_down_factor = 0;
 
 /* Target load.  Lower values result in higher CPU speeds. */
-#define DEFAULT_TARGET_LOAD 90
+#define DEFAULT_TARGET_LOAD 70
 static unsigned int default_target_loads[] = {DEFAULT_TARGET_LOAD};
 static spinlock_t target_loads_lock;
 static unsigned int *target_loads = default_target_loads;
@@ -88,7 +88,7 @@
 /*
  * The minimum amount of time to spend at a frequency before we can ramp down.
  */
-#define DEFAULT_MIN_SAMPLE_TIME (80 * USEC_PER_MSEC)
+#define DEFAULT_MIN_SAMPLE_TIME (60 * USEC_PER_MSEC)
 static unsigned long min_sample_time = DEFAULT_MIN_SAMPLE_TIME;
 
 /*
@@ -105,8 +105,7 @@
  * timer interval.
  */
 #define DEFAULT_ABOVE_HISPEED_DELAY DEFAULT_TIMER_RATE
-static unsigned int default_above_hispeed_delay[] = {
-	DEFAULT_ABOVE_HISPEED_DELAY };
+static unsigned int default_above_hispeed_delay[] = { 10000, 2265600, 80000 };
 static spinlock_t above_hispeed_delay_lock;
 static unsigned int *above_hispeed_delay = default_above_hispeed_delay;
 static int nabove_hispeed_delay = ARRAY_SIZE(default_above_hispeed_delay);
@@ -125,7 +124,7 @@
 #define DEFAULT_TIMER_SLACK (4 * DEFAULT_TIMER_RATE)
 static int timer_slack_val = DEFAULT_TIMER_SLACK;
 
-static bool io_is_busy;
+static bool io_is_busy = true;
 
 #ifdef CONFIG_MODE_AUTO_CHANGE
 struct cpufreq_loadinfo {
@@ -199,6 +198,7 @@
 
 static int cpufreq_governor_interactive(struct cpufreq_policy *policy,
 		unsigned int event);
+extern bool displayon;
 
 #define DYN_DEFER (1)
 		
@@ -206,7 +206,7 @@
 static
 #endif
 struct cpufreq_governor cpufreq_gov_interactive = {
-	.name = "interactive",
+	.name = "interactuned",
 	.governor = cpufreq_governor_interactive,
 	.max_transition_latency = 10000000,
 	.owner = THIS_MODULE,
@@ -215,9 +215,9 @@
 static inline cputime64_t get_cpu_idle_time_jiffy(unsigned int cpu,
 						  cputime64_t *wall)
 {
-	u64 idle_time;
-	u64 cur_wall_time;
-	u64 busy_time;
+	static u64 idle_time;
+	static u64 cur_wall_time;
+	static u64 busy_time;
 
 	cur_wall_time = jiffies64_to_cputime64(get_jiffies_64());
 
@@ -276,7 +276,10 @@
 				     &pcpu->time_in_idle_timestamp);
 	pcpu->cputime_speedadj = 0;
 	pcpu->cputime_speedadj_timestamp = pcpu->time_in_idle_timestamp;
+	if (displayon)
 	expires = jiffies + usecs_to_jiffies(timer_rate);
+	else
+		expires = jiffies + usecs_to_jiffies(timer_rate*2);
 	
 #ifdef DYN_DEFER
        if (pcpu->target_freq > pcpu->policy->min)
@@ -618,15 +621,11 @@
 
 static void cpufreq_interactive_timer(unsigned long data)
 {
-	u64 now;
-	unsigned int delta_time;
-	u64 cputime_speedadj;
+	u64 now, cputime_speedadj;
+	unsigned int delta_time, loadadjfreq, new_freq, index;
 	int cpu_load;
 	struct cpufreq_interactive_cpuinfo *pcpu =
 		&per_cpu(cpuinfo, data);
-	unsigned int new_freq;
-	unsigned int loadadjfreq;
-	unsigned int index;
 	unsigned long flags;
 	bool boosted;
 	unsigned long mod_min_sample_time;
@@ -1700,7 +1699,7 @@
 
 static struct attribute_group interactive_attr_group = {
 	.attrs = interactive_attributes,
-	.name = "interactive",
+	.name = "interactuned",
 };
 
 static int cpufreq_interactive_idle_notifier(struct notifier_block *nb,
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_lionheart.c
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_nightmare.c
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_ondemandplus.c
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_pegasusq.c
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_smartmax.c
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_smartmax_eps.c
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_wheatley.c
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_yankactive.c
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_zzmoove.c
Only in tuned-kernel-LOS-s5/drivers/cpufreq: cpufreq_zzmoove_profiles.h
diff -ruBb android_kernel_samsung_msm8974/drivers/cpufreq/Kconfig tuned-kernel-LOS-s5/drivers/cpufreq/Kconfig
--- android_kernel_samsung_msm8974/drivers/cpufreq/Kconfig	2018-03-05 17:54:33.527657780 -0300
+++ tuned-kernel-LOS-s5/drivers/cpufreq/Kconfig	2017-10-20 13:09:47.703712669 -0300
@@ -109,6 +109,15 @@
 	  governor. If unsure have a look at the help section of the
 	  driver. Fallback governor will be the performance governor.
 
+config CPU_FREQ_DEFAULT_GOV_ZZMOOVE
+	  bool "zzmoove"
+	  select CPU_FREQ_GOV_ZZMOOVE
+	  select CPU_FREQ_GOV_PERFORMANCE
+	  help
+	  Use the CPUFreq governor 'zzmoove' as default, using predefined
+	  frequency lookup tables and optimized scaling triggers instead of
+	  % frequency steps to get smooth up/downscaling dependant on CPU load.
+
 config CPU_FREQ_DEFAULT_GOV_INTERACTIVE
 	bool "interactive"
 	select CPU_FREQ_GOV_INTERACTIVE
@@ -118,6 +127,79 @@
 	  loading your cpufreq low-level hardware driver, using the
 	  'interactive' governor for latency-sensitive workloads.
 
+config CPU_FREQ_DEFAULT_GOV_INTELLIDEMAND
+
+	bool "intellidemand"
+	select CPU_FREQ_GOV_INTELLIDEMAND
+	help
+	  Use the CPUFreq governor 'intellidemand' as default.
+	  
+config CPU_FREQ_DEFAULT_GOV_INTELLIACTIVE
+	bool "intelliactive"
+	select CPU_FREQ_GOV_INTELLIACTIVE
+	help
+	  Use the CPUFreq governor 'intelliactive' as default. This allows
+	  you to get a full dynamic cpu frequency capable system by simply
+	  loading your cpufreq low-level hardware driver, using the
+	  'interactive' governor for latency-sensitive workloads.	  
+
+config CPU_FREQ_DEFAULT_GOV_WHEATLEY
+	bool "wheatley"
+	select CPU_FREQ_GOV_WHEATLEY
+	select CPU_FREQ_GOV_PERFORMANCE
+	---help---
+	  Use the CPUFreq governor 'wheatley' as default.
+
+config CPU_FREQ_DEFAULT_GOV_SMARTMAX
+        bool "smartmax"
+        select CPU_FREQ_GOV_SMARTMAX
+        help
+          Use the CPUFreq governor 'smartmax' as default
+
+config CPU_FREQ_DEFAULT_GOV_LIONHEART
+            bool "lionheart"
+            select CPU_FREQ_GOV_LIONHEART
+            help
+              Use the CPUFreq governor 'lionheart' as default.
+
+config CPU_FREQ_DEFAULT_GOV_NIGHTMARE
+	bool "nightmare"
+	select CPU_FREQ_GOV_NIGHTMARE
+	help
+
+config CPU_FREQ_DEFAULT_GOV_PEGASUSQ
+	bool "pegasusq"
+	select CPU_FREQ_GOV_PEGASUSQ
+	help
+	Use the CPUFreq governor 'pegasusq' as default.
+
+config CPU_FREQ_DEFAULT_GOV_IMPULSE
+	bool "impulse"
+	select CPU_FREQ_GOV_IMPULSE
+	help
+	  Use the CPUFreq governor 'impulse' as default.
+
+config CPU_FREQ_DEFAULT_GOV_SMARTMAX_EPS
+        bool "smartmax_eps"
+        select CPU_FREQ_GOV_SMARTMAX_EPS
+        help
+          Use the CPUFreq governor 'smartmax eps' as default
+
+config CPU_FREQ_DEFAULT_GOV_ONDEMANDPLUS
+	bool "ondemandplus"
+	select CPU_FREQ_GOV_ONDEMANDPLUS
+	help
+	Use the CPUFreq governor 'ondemandplus' as default.
+
+config CPU_FREQ_DEFAULT_GOV_YANKACTIVE
+ 	   bool "yankactive"
+  	   select CPU_FREQ_GOV_YANKACTIVE
+	   help
+	   Use the CPUFreq governor 'yankactive' as default. This allows
+	   you to get a full dynamic cpu frequency capable system by simply
+	   loading your cpufreq low-level hardware driver, using the
+	   'yankactive' governor for latency-sensitive workloads.
+
 endchoice
 
 config CPU_FREQ_GOV_PERFORMANCE
@@ -215,6 +297,87 @@
 
 	  If in doubt, say N.
 
+config CPU_FREQ_GOV_ZZMOOVE
+	tristate "'zzmoove' cpufreq governor"
+	depends on CPU_FREQ
+	help
+	  'zzmoove' - based on cpufreq_conservative, using predefined
+	  frequency lookup tables and optimized scaling triggers instead of
+	  % frequency steps to get smooth up/downscaling dependant on CPU load.
+	  If in doubt, say N.
+
+config CPU_FREQ_GOV_INTELLIDEMAND
+    tristate "'intellidemand' cpufreq governor"
+    depends on CPU_FREQ
+
+config CPU_FREQ_GOV_INTELLIACTIVE
+	tristate "'intelliactive' cpufreq policy governor"
+	help
+	  'intelliactive' - This driver adds a dynamic cpufreq policy governor
+	  designed for latency-sensitive workloads.
+
+	  This governor attempts to reduce the latency of clock
+	  increases so that the system is more responsive to
+	  interactive workloads.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cpufreq_interactive.
+
+	  For details, take a look at linux/Documentation/cpu-freq.
+
+	  If in doubt, say N.
+	  
+config CPU_FREQ_GOV_WHEATLEY
+	tristate "'wheatley' cpufreq governor"
+	depends on CPU_FREQ	  
+
+config CPU_FREQ_GOV_SMARTMAX
+        tristate "'smartmax' cpufreq policy governor"
+        select CPU_FREQ_TABLE
+        help
+          'smartmax' combined ondemand and smartass2
+
+config CPU_FREQ_GOV_LIONHEART
+           tristate "'lionheart' cpufreq governor"
+           depends on CPU_FREQ
+           help
+             lionheart' - a "smart" optimized governor!
+             If in doubt, say N.
+             
+config CPU_FREQ_GOV_NIGHTMARE
+	tristate "'nightmare' cpufreq governor"
+	depends on CPU_FREQ
+	
+config CPU_FREQ_GOV_PEGASUSQ
+	tristate "'pegasusq' cpufreq policy governor"
+
+config CPU_FREQ_GOV_IMPULSE
+	tristate "'impulse' cpufreq policy governor"
+	help
+	  'impulse' - This driver adds a dynamic cpufreq policy governor
+	  designed for optimized balance between power and performance.
+
+	  If in doubt, say N.
+
+config CPU_FREQ_GOV_SMARTMAX_EPS
+        tristate "'smartmax EPS' cpufreq policy governor"
+        select CPU_FREQ_TABLE
+        help
+          'smartmax EPS' is the extreme powersaving version of smartmax
+
+config CPU_FREQ_GOV_ONDEMANDPLUS
+	tristate "'ondemandplus' cpufreq governor"
+	depends on CPU_FREQ	  
+
+config CPU_FREQ_GOV_YANKACTIVE
+	  tristate "'yankactive' cpufreq policy governor"
+	  help
+	  'yankactive' - This driver adds a dynamic cpufreq policy governor
+	  designed for latency-sensitive workloads.
+	  The governor is based on interactive with just different default settings
+	  and can be achieved using interactive with a script. This is added for
+	  simplification purposes for myself.
+
 menu "x86 CPU frequency scaling drivers"
 depends on X86
 source "drivers/cpufreq/Kconfig.x86"
diff -ruBb android_kernel_samsung_msm8974/drivers/cpufreq/Makefile tuned-kernel-LOS-s5/drivers/cpufreq/Makefile
--- android_kernel_samsung_msm8974/drivers/cpufreq/Makefile	2018-03-05 17:54:33.527657780 -0300
+++ tuned-kernel-LOS-s5/drivers/cpufreq/Makefile	2017-10-31 10:39:31.157016896 -0300
@@ -1,5 +1,6 @@
 # CPUfreq core
-obj-$(CONFIG_CPU_FREQ)			+= cpufreq.o cpu-boost.o
+obj-$(CONFIG_CPU_FREQ)			+= cpufreq.o 
+#cpu-boost.o
 # CPUfreq stats
 obj-$(CONFIG_CPU_FREQ_STAT)             += cpufreq_stats.o
 
@@ -12,7 +13,19 @@
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_GOV_ZZMOOVE)      += cpufreq_zzmoove.o
 obj-$(CONFIG_CPU_FREQ_GOV_INTERACTIVE)	+= cpufreq_interactive.o
+obj-$(CONFIG_CPU_FREQ_GOV_INTELLIDEMAND)	+= cpufreq_intellidemand.o
+obj-$(CONFIG_CPU_FREQ_GOV_INTELLIACTIVE)+= cpufreq_intelliactive.o
+obj-$(CONFIG_CPU_FREQ_GOV_WHEATLEY)	+= cpufreq_wheatley.o
+obj-$(CONFIG_CPU_FREQ_GOV_SMARTMAX)     += cpufreq_smartmax.o
+obj-$(CONFIG_CPU_FREQ_GOV_LIONHEART)    += cpufreq_lionheart.o
+obj-$(CONFIG_CPU_FREQ_GOV_NIGHTMARE)	+= cpufreq_nightmare.o
+obj-$(CONFIG_CPU_FREQ_GOV_PEGASUSQ)	+= cpufreq_pegasusq.o
+obj-$(CONFIG_CPU_FREQ_GOV_IMPULSE)	+= cpufreq_impulse.o
+obj-$(CONFIG_CPU_FREQ_GOV_SMARTMAX_EPS)     += cpufreq_smartmax_eps.o
+obj-$(CONFIG_CPU_FREQ_GOV_ONDEMANDPLUS)	+= cpufreq_ondemandplus.o
+obj-$(CONFIG_CPU_FREQ_GOV_YANKACTIVE)	+= cpufreq_yankactive.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
diff -ruBb android_kernel_samsung_msm8974/drivers/devfreq/devfreq.c tuned-kernel-LOS-s5/drivers/devfreq/devfreq.c
--- android_kernel_samsung_msm8974/drivers/devfreq/devfreq.c	2018-03-05 17:54:33.543657875 -0300
+++ tuned-kernel-LOS-s5/drivers/devfreq/devfreq.c	2017-10-20 13:09:47.727712910 -0300
@@ -28,6 +28,7 @@
 #include "governor.h"
 
 static struct class *devfreq_class;
+static struct kobject *gpufreq_kobj;
 
 /*
  * devfreq core provides delayed work based load monitoring helper
@@ -548,6 +549,10 @@
 	mutex_unlock(&devfreq->lock);
 
 	mutex_lock(&devfreq_list_lock);
+	gpufreq_kobj = kobject_create_and_add("gpufreq", &devfreq->dev.kobj);
+	if (!gpufreq_kobj)
+		goto err_dev;
+
 	list_add(&devfreq->node, &devfreq_list);
 
 	governor = find_devfreq_governor(devfreq->governor_name);
@@ -744,6 +749,26 @@
 }
 EXPORT_SYMBOL(devfreq_remove_governor);
 
+int devfreq_policy_add_files(struct devfreq *devfreq,
+			     struct attribute_group attr_group)
+{
+	int ret;
+
+	ret = sysfs_create_group(gpufreq_kobj, &attr_group);
+	if (ret)
+		kobject_put(gpufreq_kobj);
+
+	return ret;
+}
+EXPORT_SYMBOL(devfreq_policy_add_files);
+
+void devfreq_policy_remove_files(struct devfreq *devfreq,
+				 struct attribute_group attr_group)
+{
+	sysfs_remove_group(gpufreq_kobj, &attr_group);
+}
+EXPORT_SYMBOL(devfreq_policy_remove_files);
+
 static ssize_t show_governor(struct device *dev,
 			     struct device_attribute *attr, char *buf)
 {
diff -ruBb android_kernel_samsung_msm8974/drivers/devfreq/governor.h tuned-kernel-LOS-s5/drivers/devfreq/governor.h
--- android_kernel_samsung_msm8974/drivers/devfreq/governor.h	2018-03-05 17:54:33.547657899 -0300
+++ tuned-kernel-LOS-s5/drivers/devfreq/governor.h	2017-10-20 13:09:47.727712910 -0300
@@ -39,4 +39,8 @@
 extern int devfreq_remove_governor(struct devfreq_governor *governor);
 
 extern int devfreq_get_freq_level(struct devfreq *devfreq, unsigned long freq);
+extern int devfreq_policy_add_files(struct devfreq *devfreq,
+				    struct attribute_group attr_group);
+extern void devfreq_policy_remove_files(struct devfreq *devfreq,
+					struct attribute_group attr_group);
 #endif /* _GOVERNOR_H */
diff -ruBb android_kernel_samsung_msm8974/drivers/devfreq/governor_msm_adreno_tz.c tuned-kernel-LOS-s5/drivers/devfreq/governor_msm_adreno_tz.c
--- android_kernel_samsung_msm8974/drivers/devfreq/governor_msm_adreno_tz.c	2018-03-05 17:54:33.547657899 -0300
+++ tuned-kernel-LOS-s5/drivers/devfreq/governor_msm_adreno_tz.c	2017-10-20 13:09:47.727712910 -0300
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2014, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -29,6 +29,10 @@
  * per frame for 60fps content.
  */
 #define FLOOR			5000
+/*
+ * MIN_BUSY is 1 msec for the sample to be sent
+ */
+#define MIN_BUSY		1000
 #define LONG_FLOOR		50000
 #define HIST			5
 #define TARGET			80
@@ -116,11 +120,13 @@
 	/*
 	 * Do not waste CPU cycles running this algorithm if
 	 * the GPU just started, or if less than FLOOR time
-	 * has passed since the last run.
+	 * has passed since the last run or the gpu hasn't been
+	 * busier than MIN_BUSY.
 	 */
 	if ((stats.total_time == 0) ||
-		(priv->bin.total_time < FLOOR)) {
-		return 1;
+		(priv->bin.total_time < FLOOR) ||
+		(unsigned int) priv->bin.busy_time < MIN_BUSY) {
+		return 0;
 	}
 
 	level = devfreq_get_freq_level(devfreq, stats.current_frequency);
@@ -152,7 +158,7 @@
 	if (val) {
 		level += val;
 		level = max(level, 0);
-		level = min_t(int, level, devfreq->profile->max_state);
+		level = min_t(int, level, devfreq->profile->max_state - 1);
 		goto clear;
 	}
 
@@ -224,11 +230,6 @@
 	unsigned int t1, t2 = 2 * HIST;
 	int i, out, ret;
 
-	if (devfreq->data == NULL) {
-		pr_err(TAG "data is required for this governor\n");
-		return -EINVAL;
-	}
-
 	priv = devfreq->data;
 	priv->nb.notifier_call = tz_notify;
 
@@ -274,6 +275,8 @@
 	struct devfreq_msm_adreno_tz_data *priv = devfreq->data;
 
 	kgsl_devfreq_del_notifier(devfreq->dev.parent, &priv->nb);
+	/* leaving the governor and cleaning the pointer to private data */
+	devfreq->data = NULL;
 	return 0;
 }
 
diff -ruBb android_kernel_samsung_msm8974/drivers/devfreq/governor_simpleondemand.c tuned-kernel-LOS-s5/drivers/devfreq/governor_simpleondemand.c
--- android_kernel_samsung_msm8974/drivers/devfreq/governor_simpleondemand.c	2018-03-05 17:54:33.547657899 -0300
+++ tuned-kernel-LOS-s5/drivers/devfreq/governor_simpleondemand.c	2017-10-20 13:09:47.727712910 -0300
@@ -15,35 +15,33 @@
 #include <linux/math64.h>
 #include "governor.h"
 
+#define DEVFREQ_SIMPLE_ONDEMAND	"simple_ondemand"
+
 /* Default constants for DevFreq-Simple-Ondemand (DFSO) */
-#define DFSO_UPTHRESHOLD	(90)
-#define DFSO_DOWNDIFFERENCTIAL	(5)
+#define DFSO_UPTHRESHOLD	60
+#define DFSO_DOWNDIFFERENCTIAL	20
+
+static unsigned int dfso_upthreshold = DFSO_UPTHRESHOLD;
+static unsigned int dfso_downdifferential = DFSO_DOWNDIFFERENCTIAL;
+
+
 static int devfreq_simple_ondemand_func(struct devfreq *df,
 					unsigned long *freq,
 					u32 *flag)
 {
 	struct devfreq_dev_status stat;
-	int err = df->profile->get_dev_status(df->dev.parent, &stat);
-	unsigned long long a, b;
-	unsigned int dfso_upthreshold = DFSO_UPTHRESHOLD;
-	unsigned int dfso_downdifferential = DFSO_DOWNDIFFERENCTIAL;
 	struct devfreq_simple_ondemand_data *data = df->data;
+	int err;
+	unsigned long long a, b;
 	unsigned long max = (df->max_freq) ? df->max_freq : UINT_MAX;
 	unsigned long min = (df->min_freq) ? df->min_freq : 0;
 
+	stat.private_data = NULL;
+
+	err = df->profile->get_dev_status(df->dev.parent, &stat);
 	if (err)
 		return err;
 
-	if (data) {
-		if (data->upthreshold)
-			dfso_upthreshold = data->upthreshold;
-		if (data->downdifferential)
-			dfso_downdifferential = data->downdifferential;
-	}
-	if (dfso_upthreshold > 100 ||
-	    dfso_upthreshold < dfso_downdifferential)
-		return -EINVAL;
-
 	/* Prevent overflow */
 	if (stat.busy_time >= (1 << 24) || stat.total_time >= (1 << 24)) {
 		stat.busy_time >>= 7;
@@ -104,15 +102,81 @@
 	return 0;
 }
 
+static ssize_t simple_ondemand_upthreshold_show(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	return sprintf(buf, "%d\n", dfso_upthreshold);
+}
+
+static ssize_t simple_ondemand_upthreshold_store(struct kobject *kobj,
+						  struct kobj_attribute *attr,
+						  const char *buf, size_t count)
+{
+	unsigned int val;
+
+	sscanf(buf, "%d", &val);
+	if (val > 100 || val < dfso_downdifferential)
+		return -EINVAL;
+
+	dfso_upthreshold = val;
+
+	return count;
+}
+
+static ssize_t simple_ondemand_downdifferential_show(struct kobject *kobj,
+						     struct kobj_attribute *attr,
+						     char *buf)
+{
+	return sprintf(buf, "%d\n", dfso_downdifferential);
+}
+
+static ssize_t simple_ondemand_downdifferential_store(struct kobject *kobj,
+						      struct kobj_attribute *attr,
+						      const char *buf, size_t count)
+{
+	unsigned int val;
+
+	sscanf(buf, "%d", &val);
+	if (val > dfso_upthreshold)
+		return -EINVAL;
+
+	dfso_downdifferential = val;
+
+	return count;
+}
+
+static struct kobj_attribute upthreshold_attribute =
+	__ATTR(upthreshold, 0664, simple_ondemand_upthreshold_show,
+	       simple_ondemand_upthreshold_store);
+static struct kobj_attribute downdifferential_attribute =
+	__ATTR(downdifferential, 0664, simple_ondemand_downdifferential_show,
+	       simple_ondemand_downdifferential_store);
+
+static struct attribute *attrs[] = {
+	&upthreshold_attribute.attr,
+	&downdifferential_attribute.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+	.name = DEVFREQ_SIMPLE_ONDEMAND,
+};
+
 static int devfreq_simple_ondemand_handler(struct devfreq *devfreq,
 				unsigned int event, void *data)
 {
+	int ret = 0;
+
 	switch (event) {
 	case DEVFREQ_GOV_START:
 		devfreq_monitor_start(devfreq);
+		ret = devfreq_policy_add_files(devfreq, attr_group);
 		break;
 
 	case DEVFREQ_GOV_STOP:
+		devfreq_policy_remove_files(devfreq, attr_group);
 		devfreq_monitor_stop(devfreq);
 		break;
 
@@ -132,11 +196,11 @@
 		break;
 	}
 
-	return 0;
+	return ret;
 }
 
 static struct devfreq_governor devfreq_simple_ondemand = {
-	.name = "simple_ondemand",
+	.name = DEVFREQ_SIMPLE_ONDEMAND,
 	.get_target_freq = devfreq_simple_ondemand_func,
 	.event_handler = devfreq_simple_ondemand_handler,
 };
diff -ruBb android_kernel_samsung_msm8974/drivers/fingerprint/vfs61xx.c tuned-kernel-LOS-s5/drivers/fingerprint/vfs61xx.c
--- android_kernel_samsung_msm8974/drivers/fingerprint/vfs61xx.c	2018-03-05 17:54:33.567658018 -0300
+++ tuned-kernel-LOS-s5/drivers/fingerprint/vfs61xx.c	2017-11-08 20:51:45.804573764 -0300
@@ -296,7 +296,7 @@
 }
 
 /* Return no.of bytes read >0. negative integer incase of error. */
-inline ssize_t vfsspi_readSync(struct vfsspi_devData *vfsSpiDev,
+static inline ssize_t vfsspi_readSync(struct vfsspi_devData *vfsSpiDev,
 	unsigned char *buf, size_t len)
 {
 	int status = 0;
diff -ruBb android_kernel_samsung_msm8974/drivers/gpu/drm/i915/i915_drv.c tuned-kernel-LOS-s5/drivers/gpu/drm/i915/i915_drv.c
--- android_kernel_samsung_msm8974/drivers/gpu/drm/i915/i915_drv.c	2018-03-05 17:54:33.603658232 -0300
+++ tuned-kernel-LOS-s5/drivers/gpu/drm/i915/i915_drv.c	2017-11-29 13:27:57.622221853 -0300
@@ -93,8 +93,8 @@
 int i915_vbt_sdvo_panel_type __read_mostly = -1;
 module_param_named(vbt_sdvo_panel_type, i915_vbt_sdvo_panel_type, int, 0600);
 MODULE_PARM_DESC(vbt_sdvo_panel_type,
-		"Override selection of SDVO panel mode in the VBT "
-		"(default: auto)");
+		"Override/Ignore selection of SDVO panel mode in the VBT "
+		"(-2=ignore, -1=auto [default], index in VBT BIOS table)");
 
 static bool i915_try_reset __read_mostly = true;
 module_param_named(reset, i915_try_reset, bool, 0600);
diff -ruBb android_kernel_samsung_msm8974/drivers/gpu/drm/i915/intel_acpi.c tuned-kernel-LOS-s5/drivers/gpu/drm/i915/intel_acpi.c
--- android_kernel_samsung_msm8974/drivers/gpu/drm/i915/intel_acpi.c	2018-03-05 17:54:33.607658255 -0300
+++ tuned-kernel-LOS-s5/drivers/gpu/drm/i915/intel_acpi.c	2017-11-29 13:27:58.082221846 -0300
@@ -182,8 +182,6 @@
 			DRM_DEBUG_DRIVER("  hpd mux info: %s\n",
 			       intel_dsm_mux_type(info->buffer.pointer[3]));
 		}
-	} else {
-		DRM_ERROR("MUX INFO call failed\n");
 	}
 
 out:
diff -ruBb android_kernel_samsung_msm8974/drivers/gpu/drm/i915/intel_bios.c tuned-kernel-LOS-s5/drivers/gpu/drm/i915/intel_bios.c
--- android_kernel_samsung_msm8974/drivers/gpu/drm/i915/intel_bios.c	2018-03-05 17:54:33.607658255 -0300
+++ tuned-kernel-LOS-s5/drivers/gpu/drm/i915/intel_bios.c	2017-11-29 13:27:57.618221854 -0300
@@ -292,6 +292,11 @@
 	int index;
 
 	index = i915_vbt_sdvo_panel_type;
+	if (index == -2) {
+		DRM_DEBUG_KMS("Ignore SDVO panel mode from BIOS VBT tables.\n");
+		return;
+	}
+
 	if (index == -1) {
 		struct bdb_sdvo_lvds_options *sdvo_lvds_options;
 
diff -ruBb android_kernel_samsung_msm8974/drivers/gpu/drm/i915/intel_display.c tuned-kernel-LOS-s5/drivers/gpu/drm/i915/intel_display.c
--- android_kernel_samsung_msm8974/drivers/gpu/drm/i915/intel_display.c	2018-03-05 17:54:33.607658255 -0300
+++ tuned-kernel-LOS-s5/drivers/gpu/drm/i915/intel_display.c	2017-11-29 13:27:58.842221831 -0300
@@ -2554,7 +2554,7 @@
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 	int pipe = intel_crtc->pipe;
-	u32 reg, temp, i;
+	u32 reg, temp, i, retry;
 
 	/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit
 	   for train result */
@@ -2603,6 +2603,7 @@
 		POSTING_READ(reg);
 		udelay(500);
 
+		for (retry = 0; retry < 5; retry++) {
 		reg = FDI_RX_IIR(pipe);
 		temp = I915_READ(reg);
 		DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);
@@ -2606,12 +2607,15 @@
 		reg = FDI_RX_IIR(pipe);
 		temp = I915_READ(reg);
 		DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);
-
 		if (temp & FDI_RX_BIT_LOCK) {
 			I915_WRITE(reg, temp | FDI_RX_BIT_LOCK);
 			DRM_DEBUG_KMS("FDI train 1 done.\n");
 			break;
 		}
+			udelay(50);
+		}
+		if (retry < 5)
+			break;
 	}
 	if (i == 4)
 		DRM_ERROR("FDI train 1 fail!\n");
@@ -2652,6 +2656,7 @@
 		POSTING_READ(reg);
 		udelay(500);
 
+		for (retry = 0; retry < 5; retry++) {
 		reg = FDI_RX_IIR(pipe);
 		temp = I915_READ(reg);
 		DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);
@@ -2655,12 +2660,15 @@
 		reg = FDI_RX_IIR(pipe);
 		temp = I915_READ(reg);
 		DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);
-
 		if (temp & FDI_RX_SYMBOL_LOCK) {
 			I915_WRITE(reg, temp | FDI_RX_SYMBOL_LOCK);
 			DRM_DEBUG_KMS("FDI train 2 done.\n");
 			break;
 		}
+			udelay(50);
+		}
+		if (retry < 5)
+			break;
 	}
 	if (i == 4)
 		DRM_ERROR("FDI train 2 fail!\n");
diff -ruBb android_kernel_samsung_msm8974/drivers/gpu/gpu_sysfs/Kbuild tuned-kernel-LOS-s5/drivers/gpu/gpu_sysfs/Kbuild
--- android_kernel_samsung_msm8974/drivers/gpu/gpu_sysfs/Kbuild	2018-03-05 17:54:33.671658636 -0300
+++ tuned-kernel-LOS-s5/drivers/gpu/gpu_sysfs/Kbuild	2017-10-20 13:09:47.931714962 -0300
@@ -25,8 +25,8 @@
 # Generate error if the TARGET
 # specific file is not defined OR
 # picked using the PLATFORM configs.
-ifndef GPU_SYSFS_TARGET_FILE_DEFINED
-$(warning **** Make sure target file is defined. \
-               Check the TARGET and GPU configs in Makefile and Kernel Config. \
-               Module won't work without target file. ****)
-endif
+#ifndef GPU_SYSFS_TARGET_FILE_DEFINED
+#$(warning **** Make sure target file is defined. \
+#               Check the TARGET and GPU configs in Makefile and Kernel Config. \
+#               Module won't work without target file. ****)
+#endif
diff -ruBb android_kernel_samsung_msm8974/drivers/gpu/msm/adreno_ringbuffer.c tuned-kernel-LOS-s5/drivers/gpu/msm/adreno_ringbuffer.c
--- android_kernel_samsung_msm8974/drivers/gpu/msm/adreno_ringbuffer.c	2018-03-05 17:54:33.679658684 -0300
+++ tuned-kernel-LOS-s5/drivers/gpu/msm/adreno_ringbuffer.c	2017-11-08 21:02:53.753378146 -0300
@@ -212,7 +212,7 @@
  *
  * Load the pm4 ucode from @start at @addr.
  */
-inline int adreno_ringbuffer_load_pm4_ucode(struct kgsl_device *device,
+static inline int adreno_ringbuffer_load_pm4_ucode(struct kgsl_device *device,
 			unsigned int start, unsigned int end, unsigned int addr)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
@@ -266,7 +266,7 @@
  *
  * Load the pfp ucode from @start at @addr.
  */
-inline int adreno_ringbuffer_load_pfp_ucode(struct kgsl_device *device,
+static inline int adreno_ringbuffer_load_pfp_ucode(struct kgsl_device *device,
 			unsigned int start, unsigned int end, unsigned int addr)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
diff -ruBb android_kernel_samsung_msm8974/drivers/gpu/msm/kgsl_iommu.c tuned-kernel-LOS-s5/drivers/gpu/msm/kgsl_iommu.c
--- android_kernel_samsung_msm8974/drivers/gpu/msm/kgsl_iommu.c	2018-03-05 17:54:33.679658684 -0300
+++ tuned-kernel-LOS-s5/drivers/gpu/msm/kgsl_iommu.c	2017-11-10 10:14:35.103861951 -0300
@@ -997,7 +997,7 @@
  *
  * Return - int - number of commands.
  */
-inline unsigned int kgsl_iommu_sync_lock(struct kgsl_mmu *mmu,
+static inline unsigned int kgsl_iommu_sync_lock(struct kgsl_mmu *mmu,
 						unsigned int *cmds)
 {
 	struct kgsl_device *device = mmu->device;
@@ -1067,7 +1067,7 @@
  *
  * Return - int - number of commands.
  */
-inline unsigned int kgsl_iommu_sync_unlock(struct kgsl_mmu *mmu,
+static inline unsigned int kgsl_iommu_sync_unlock(struct kgsl_mmu *mmu,
 					unsigned int *cmds)
 {
 	struct kgsl_device *device = mmu->device;
diff -ruBb android_kernel_samsung_msm8974/drivers/gpu/msm/kgsl_pwrctrl.c tuned-kernel-LOS-s5/drivers/gpu/msm/kgsl_pwrctrl.c
--- android_kernel_samsung_msm8974/drivers/gpu/msm/kgsl_pwrctrl.c	2018-03-05 17:54:33.679658684 -0300
+++ tuned-kernel-LOS-s5/drivers/gpu/msm/kgsl_pwrctrl.c	2017-10-20 13:09:47.959715243 -0300
@@ -35,6 +35,12 @@
 #define UPDATE_BUSY_VAL		1000000
 #define UPDATE_BUSY		50
 
+#define DEFAULT_MAX_PWRLEVEL   0
+#define DEFAULT_MIN_PWRLEVEL   5
+#define BYPASS_HARDLIMIT_CHECK	99
+static unsigned int max_pwrlevel_hardlimit;
+static unsigned int min_pwrlevel_hardlimit;
+
 /*
  * Expected delay for post-interrupt processing on A3xx.
  * The delay may be longer, gradually increase the delay
@@ -291,6 +297,12 @@
 	if (level > pwr->min_pwrlevel)
 		level = pwr->min_pwrlevel;
 
+	// AP: check for hard limit and do not allow to go below
+	// a value of 99 will disable this hard limit check
+	if (max_pwrlevel_hardlimit != BYPASS_HARDLIMIT_CHECK)
+		if (level < max_pwrlevel_hardlimit)
+			level = max_pwrlevel_hardlimit;
+
 	pwr->max_pwrlevel = level;
 
 
@@ -345,6 +357,12 @@
 	if (level < pwr->max_pwrlevel)
 		level = pwr->max_pwrlevel;
 
+	// AP: check for hard limit and do not allow to go above
+	// a value of 99 will disable this hard limit check
+	if (min_pwrlevel_hardlimit != BYPASS_HARDLIMIT_CHECK)
+		if (level > min_pwrlevel_hardlimit)
+			level = min_pwrlevel_hardlimit;
+
 	pwr->min_pwrlevel = level;
 
 	min_level = max_t(int, pwr->thermal_pwrlevel, pwr->min_pwrlevel);
@@ -373,6 +391,73 @@
 	return snprintf(buf, PAGE_SIZE, "%d\n", pwr->min_pwrlevel);
 }
 
+static int kgsl_pwrctrl_max_pwrlevel_hardlimit_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct kgsl_device *device = kgsl_device_from_dev(dev);
+	struct kgsl_pwrctrl *pwr;
+	int ret;
+	unsigned int level = 0;
+
+	if (device == NULL)
+		return 0;
+
+	pwr = &device->pwrctrl;
+
+	ret = sscanf(buf, "%d", &level);
+	if (ret != 1)
+		return count;
+
+	if (((level >= 0) && (level < (pwr->num_pwrlevels - 1))) ||
+		(level == BYPASS_HARDLIMIT_CHECK))
+		max_pwrlevel_hardlimit = level;
+	else
+		pr_debug("kgsl_pwrctrl: invalid max_pwrlevel_hardlimit, not set\n");
+
+	return count;
+}
+
+static int kgsl_pwrctrl_max_pwrlevel_hardlimit_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	return sprintf(buf, "%u\n", max_pwrlevel_hardlimit);
+}
+
+static int kgsl_pwrctrl_min_pwrlevel_hardlimit_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{	struct kgsl_device *device = kgsl_device_from_dev(dev);
+	struct kgsl_pwrctrl *pwr;
+	int ret;
+	unsigned int level = 0;
+
+	if (device == NULL)
+		return 0;
+
+	pwr = &device->pwrctrl;
+
+	ret = sscanf(buf, "%d", &level);
+	if (ret != 1)
+		return count;
+
+	if (((level >= 0) && (level < (pwr->num_pwrlevels - 1))) ||
+		(level == BYPASS_HARDLIMIT_CHECK))
+		min_pwrlevel_hardlimit = level;
+	else
+		pr_debug("kgsl_pwrctrl: invalid min_pwrlevel_hardlimit, not set\n");
+
+	return count;
+}
+
+static int kgsl_pwrctrl_min_pwrlevel_hardlimit_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	return sprintf(buf, "%u\n", min_pwrlevel_hardlimit);
+}
+
 static int kgsl_pwrctrl_num_pwrlevels_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
@@ -791,6 +876,12 @@
 DEVICE_ATTR(min_pwrlevel, 0644,
 	kgsl_pwrctrl_min_pwrlevel_show,
 	kgsl_pwrctrl_min_pwrlevel_store);
+DEVICE_ATTR(max_pwrlevel_hardlimit, 0644,
+	kgsl_pwrctrl_max_pwrlevel_hardlimit_show,
+	kgsl_pwrctrl_max_pwrlevel_hardlimit_store);
+DEVICE_ATTR(min_pwrlevel_hardlimit, 0644,
+	kgsl_pwrctrl_min_pwrlevel_hardlimit_show,
+	kgsl_pwrctrl_min_pwrlevel_hardlimit_store);
 DEVICE_ATTR(thermal_pwrlevel, 0644,
 	kgsl_pwrctrl_thermal_pwrlevel_show,
 	kgsl_pwrctrl_thermal_pwrlevel_store);
@@ -825,6 +916,8 @@
 	&dev_attr_gpu_available_frequencies,
 	&dev_attr_max_pwrlevel,
 	&dev_attr_min_pwrlevel,
+	&dev_attr_max_pwrlevel_hardlimit,
+	&dev_attr_min_pwrlevel_hardlimit,
 	&dev_attr_thermal_pwrlevel,
 	&dev_attr_num_pwrlevels,
 	&dev_attr_pmqos_latency,
@@ -1076,10 +1169,24 @@
 
 	/* Initialize the user and thermal clock constraints */
 
+#ifdef DEFAULT_MAX_PWRLEVEL
+	pwr->max_pwrlevel = DEFAULT_MAX_PWRLEVEL;
+#else
 	pwr->max_pwrlevel = 0;
+#endif	
+
+#ifdef DEFAULT_MIN_PWRLEVEL
+	pwr->min_pwrlevel = DEFAULT_MIN_PWRLEVEL;
+#else
 	pwr->min_pwrlevel = pdata->num_levels - 2;
+#endif
+
 	pwr->thermal_pwrlevel = 0;
 
+	// AP: initialize hard limits
+	max_pwrlevel_hardlimit = pwr->max_pwrlevel;
+	min_pwrlevel_hardlimit = pwr->min_pwrlevel;
+
 	pwr->active_pwrlevel = pdata->init_level;
 	pwr->default_pwrlevel = pdata->init_level;
 	pwr->init_pwrlevel = pdata->init_level;
diff -ruBb android_kernel_samsung_msm8974/drivers/i2c/busses/i2c-qup.c tuned-kernel-LOS-s5/drivers/i2c/busses/i2c-qup.c
--- android_kernel_samsung_msm8974/drivers/i2c/busses/i2c-qup.c	2018-03-05 17:54:33.731658993 -0300
+++ tuned-kernel-LOS-s5/drivers/i2c/busses/i2c-qup.c	2017-10-20 13:09:48.067716329 -0300
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -22,7 +22,6 @@
 #include <linux/err.h>
 #include <linux/init.h>
 #include <linux/i2c.h>
-#include <linux/i2c/i2c-qup.h>
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/delay.h>
@@ -39,6 +38,7 @@
 #include <mach/board.h>
 #include <mach/gpiomux.h>
 #include <mach/msm_bus_board.h>
+#include <linux/kt_wake_funcs.h>
 
 MODULE_LICENSE("GPL v2");
 MODULE_VERSION("0.2");
@@ -86,11 +86,10 @@
 	QUP_MX_INPUT_DONE       = 1U << 11,
 };
 
-/* QUP_CONFIG values and flags */
+/* I2C mini core related values */
 enum {
 	I2C_MINI_CORE           = 2U << 8,
 	I2C_N_VAL               = 0xF,
-	I2C_CORE_CLK_ON_EN      = BIT(13),
 
 };
 
@@ -131,25 +130,12 @@
 	I2C_CLK_FORCED_LOW_STATE	= 5,
 };
 
-enum msm_i2c_state {
-	MSM_I2C_PM_ACTIVE,
-	MSM_I2C_PM_SUSPENDED,
-	MSM_I2C_SYS_SUSPENDING,
-	MSM_I2C_SYS_SUSPENDED,
-};
 #define QUP_MAX_CLK_STATE_RETRIES	300
 #define DEFAULT_CLK_RATE		(19200000)
 #define I2C_STATUS_CLK_STATE		13
 #define QUP_OUT_FIFO_NOT_EMPTY		0x10
 #define I2C_GPIOS_DT_CNT		(2)		/* sda and scl */
 
-#if defined(CONFIG_MACH_KS01EUR) || defined(CONFIG_SEC_CHAGALL_PROJECT) 
-/* Register:QUP_I2C_MASTER_CLK_CTL field setters */
-#define QUP_I2C_SCL_NOISE_REJECTION(reg_val, noise_rej_val) \
-		(((reg_val) & ~(0x3 << 24)) | (((noise_rej_val) & 0x3) << 24))
-#define QUP_I2C_SDA_NOISE_REJECTION(reg_val, noise_rej_val) \
-		(((reg_val) & ~(0x3 << 26)) | (((noise_rej_val) & 0x3) << 26))
-#endif
 static char const * const i2c_rsrcs[] = {"i2c_clk", "i2c_sda"};
 
 static struct gpiomux_setting recovery_config = {
@@ -199,8 +185,8 @@
 	int                          in_blk_sz;
 	int                          wr_sz;
 	struct msm_i2c_platform_data *pdata;
-	enum msm_i2c_state           pwr_state;
-	atomic_t		     xfer_progress;
+	int                          suspended;
+	int                          pwr_state;
 	struct mutex                 mlock;
 	void                         *complete;
 	int                          i2c_gpios[ARRAY_SIZE(i2c_rsrcs)];
@@ -238,10 +224,8 @@
 	uint32_t op_flgs = 0;
 	int err = 0;
 
-	if (atomic_read(&dev->xfer_progress) != 1) {
-		dev_err(dev->dev, "irq:%d when PM suspended\n", irq);
+	if (pm_runtime_suspended(dev->dev))
 		return IRQ_NONE;
-	}
 
 	status = readl_relaxed(dev->base + QUP_I2C_STATUS);
 	status1 = readl_relaxed(dev->base + QUP_ERROR_FLAGS);
@@ -356,6 +340,22 @@
 	return 0;
 }
 
+/*
+ * Before calling qup_config_core_on_en(), please make
+ * sure that QuPE core is in RESET state.
+ */
+static void
+qup_config_core_on_en(struct qup_i2c_dev *dev)
+{
+	uint32_t status;
+
+	status = readl_relaxed(dev->base + QUP_CONFIG);
+	status |= BIT(13);
+	writel_relaxed(status, dev->base + QUP_CONFIG);
+	/* making sure that write has really gone through */
+	mb();
+}
+
 #define MSM_I2C_CLK_PATH_SUSPEND (0)
 #define MSM_I2C_CLK_PATH_RESUME  (1)
 #define MSM_I2C_CLK_PATH_MAX_BW(dev) ((dev->pdata->src_clk_rate * 8) / 1000)
@@ -501,97 +501,27 @@
 	}
 }
 
-static int i2c_qup_gpio_request(struct qup_i2c_dev *dev)
-{
-	int i;
-	int result = 0;
-
-	for (i = 0; i < ARRAY_SIZE(i2c_rsrcs); ++i) {
-		if (dev->i2c_gpios[i] >= 0) {
-			result = gpio_request(dev->i2c_gpios[i], i2c_rsrcs[i]);
-			if (result) {
-				dev_err(dev->dev,
-					"gpio_request for pin %d failed with error %d\n",
-					dev->i2c_gpios[i], result);
-				goto error;
-			}
-		}
-	}
-	return 0;
-
-error:
-	for (; --i >= 0;) {
-		if (dev->i2c_gpios[i] >= 0)
-			gpio_free(dev->i2c_gpios[i]);
-	}
-	return result;
-}
-
-static void i2c_qup_gpio_free(struct qup_i2c_dev *dev)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(i2c_rsrcs); ++i) {
-		if (dev->i2c_gpios[i] >= 0)
-			gpio_free(dev->i2c_gpios[i]);
-	}
-}
-
-static void i2c_qup_pm_suspend_clk(struct qup_i2c_dev *dev)
+static void
+qup_i2c_pwr_mgmt(struct qup_i2c_dev *dev, unsigned int state)
 {
-	uint32_t status;
+	dev->pwr_state = state;
+	if (state != 0) {
+		i2c_qup_clk_path_postponed_register(dev);
+		if (!dev->pdata->active_only)
+			i2c_qup_clk_path_vote(dev);
 
-	/* reset core and enable conditional dynamic clock gating */
+		clk_prepare_enable(dev->clk);
+		if (!dev->pdata->keep_ahb_clk_on)
+			clk_prepare_enable(dev->pclk);
+	} else {
 	qup_update_state(dev, QUP_RESET_STATE);
-	status = readl_relaxed(dev->base + QUP_CONFIG);
-	status |= I2C_CORE_CLK_ON_EN;
-	writel_relaxed(status, dev->base + QUP_CONFIG);
-	/* ensure that write has really gone through */
-	mb();
-
 	clk_disable_unprepare(dev->clk);
+		qup_config_core_on_en(dev);
 	if (!dev->pdata->keep_ahb_clk_on)
 		clk_disable_unprepare(dev->pclk);
-}
-
-static void i2c_qup_pm_resume_clk(struct qup_i2c_dev *dev)
-{
-	clk_prepare_enable(dev->clk);
-	if (!dev->pdata->keep_ahb_clk_on)
-		clk_prepare_enable(dev->pclk);
-}
-
-static void i2c_qup_pm_suspend(struct qup_i2c_dev *dev)
-{
-	if (dev->pwr_state == MSM_I2C_PM_SUSPENDED) {
-		dev_err(dev->dev, "attempt to suspend when suspended\n");
-		return;
-	}
-
-	if (!dev->pdata->clk_ctl_xfer)
-		i2c_qup_pm_suspend_clk(dev);
-
 	if (!dev->pdata->active_only)
 		i2c_qup_clk_path_unvote(dev);
-
-	i2c_qup_gpio_free(dev);
-	dev->pwr_state = MSM_I2C_PM_SUSPENDED;
-}
-
-static void i2c_qup_pm_resume(struct qup_i2c_dev *dev)
-{
-	if (dev->pwr_state == MSM_I2C_PM_ACTIVE)
-		return;
-
-	i2c_qup_gpio_request(dev);
-
-	i2c_qup_clk_path_postponed_register(dev);
-	if (!dev->pdata->active_only)
-		i2c_qup_clk_path_vote(dev);
-
-	if (!dev->pdata->clk_ctl_xfer)
-		i2c_qup_pm_resume_clk(dev);
-	dev->pwr_state = MSM_I2C_PM_ACTIVE;
+	}
 }
 
 static int
@@ -666,6 +596,43 @@
 	return -ETIMEDOUT;
 }
 
+static inline int qup_i2c_request_gpios(struct qup_i2c_dev *dev)
+{
+	int i;
+	int result = 0;
+
+	for (i = 0; i < ARRAY_SIZE(i2c_rsrcs); ++i) {
+		if (dev->i2c_gpios[i] >= 0) {
+			result = gpio_request(dev->i2c_gpios[i], i2c_rsrcs[i]);
+			if (result) {
+				dev_err(dev->dev,
+					"gpio_request for pin %d failed\
+					with error %d\n", dev->i2c_gpios[i],
+					result);
+				goto error;
+			}
+		}
+	}
+	return 0;
+
+error:
+	for (; --i >= 0;) {
+		if (dev->i2c_gpios[i] >= 0)
+			gpio_free(dev->i2c_gpios[i]);
+	}
+	return result;
+}
+
+static inline void qup_i2c_free_gpios(struct qup_i2c_dev *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(i2c_rsrcs); ++i) {
+		if (dev->i2c_gpios[i] >= 0)
+			gpio_free(dev->i2c_gpios[i]);
+	}
+}
+
 #ifdef DEBUG
 static void qup_verify_fifo(struct qup_i2c_dev *dev, uint32_t val,
 				uint32_t addr, int rdwr)
@@ -982,37 +949,31 @@
 	long timeout;
 	int err;
 
-	/*
-	 * If all slaves of this controller behave as expected, they will
-	 * implement suspend and won't call any transaction if they are
-	 * suspended. Since controller is its parent, controller's suspend
-	 * will be called only AFTER alls slaves are suspended.
-	 * However reality is differe and some slave don't implement suspend
-	 * If a slave tries to initiate transfer when we are suspended,
-	 * pm_runtime_enabled is set to false by system-pm.
-	 * Make sure we return error when transaction is initiated while
-	 * we are in suspended state
-	 */
-	mutex_lock(&dev->mlock);
-	if (dev->pwr_state >= MSM_I2C_SYS_SUSPENDING) {
-		dev_err(dev->dev,
-			"xfer not allowed when ctrl is suspended addr:0x%x\n",
-			msgs->addr);
-		mutex_unlock(&dev->mlock);
-		return -EIO;
-	}
+	/* Alternate if runtime power management is disabled */
 	if (!pm_runtime_enabled(dev->dev)) {
-		dev_dbg(dev->dev, "Runtime PM FEATURE is disabled\n");
-		i2c_qup_pm_resume(dev);
+		dev_dbg(dev->dev, "Runtime PM is disabled\n");
+		i2c_qup_pm_resume_runtime(dev->dev);
 	} else {
 		pm_runtime_get_sync(dev->dev);
 	}
+	mutex_lock(&dev->mlock);
 
+	if (dev->suspended) {
+		mutex_unlock(&dev->mlock);
+		return -EIO;
+	}
 
-	if (dev->pdata->clk_ctl_xfer)
-		i2c_qup_pm_resume_clk(dev);
+	if (screen_wake_options && dev->pwr_state == 0) {
+		if (dev->clk_ctl == 0) {
+			if (dev->pdata->src_clk_rate > 0)
+				clk_set_rate(dev->clk,
+						dev->pdata->src_clk_rate);
+			else
+				dev->pdata->src_clk_rate = DEFAULT_CLK_RATE;
+		}
+		qup_i2c_pwr_mgmt(dev, 1);
+	}
 
-	atomic_set(&dev->xfer_progress, 1);
 	/* Initialize QUP registers during first transfer */
 	if (dev->clk_ctl == 0) {
 		int fs_div;
@@ -1034,12 +995,6 @@
 				/ dev->pdata->clk_freq) / 2) - 3;
 		hs_div = 3;
 		dev->clk_ctl = ((hs_div & 0x7) << 8) | (fs_div & 0xff);
-#if defined(CONFIG_MACH_KS01EUR) || defined(CONFIG_SEC_CHAGALL_PROJECT)
-		dev->clk_ctl = QUP_I2C_SCL_NOISE_REJECTION(
-				dev->clk_ctl, dev->pdata->noise_rjct_scl);
-		dev->clk_ctl = QUP_I2C_SDA_NOISE_REJECTION(
-				dev->clk_ctl, dev->pdata->noise_rjct_sda);
-#endif
 		fifo_reg = readl_relaxed(dev->base + QUP_IO_MODE);
 		if (fifo_reg & 0x3)
 			dev->out_blk_sz = (fifo_reg & 0x3) * 16;
@@ -1212,6 +1167,15 @@
 					if (timeout)
 						goto timeout_err;
 				}
+				if (screen_wake_options)
+				{
+					pm_runtime_disable(dev->dev);
+					pm_runtime_set_active(dev->dev);
+					qup_i2c_request_gpios(dev);
+					qup_i2c_pwr_mgmt(dev, 1);
+					//pm_runtime_enable(dev->dev);
+				}
+				
 				qup_i2c_recover_bus_busy(dev);
 				dev_err(dev->dev,
 					"Transaction timed out, SL-AD = 0x%x\n",
@@ -1220,7 +1184,14 @@
 				dev_err(dev->dev, "I2C Status: %x\n", istatus);
 				dev_err(dev->dev, "QUP Status: %x\n", qstatus);
 				dev_err(dev->dev, "OP Flags: %x\n", op_flgs);
+				dev_err(dev->dev, "CLK Rate: %x\n", dev->pdata->src_clk_rate);
 				writel_relaxed(1, dev->base + QUP_SW_RESET);
+				if (screen_wake_options)
+				{
+					dev->pdata->src_clk_rate = 50000000;
+					clk_set_rate(dev->clk, dev->pdata->src_clk_rate);
+				}
+
 				/* Make sure that the write has gone through
 				 * before returning from the function
 				 */
@@ -1320,11 +1291,9 @@
 	dev->pos = 0;
 	dev->err = 0;
 	dev->cnt = 0;
-	if (dev->pdata->clk_ctl_xfer)
-		i2c_qup_pm_suspend_clk(dev);
-	atomic_set(&dev->xfer_progress, 0);
 	mutex_unlock(&dev->mlock);
 	pm_runtime_mark_last_busy(dev->dev);
+	if (!screen_wake_options)
 	pm_runtime_put_autosuspend(dev->dev);
 	return ret;
 }
@@ -1356,19 +1325,14 @@
 	struct device_node *node = pdev->dev.of_node;
 	struct msm_i2c_dt_to_pdata_map *itr;
 	struct msm_i2c_dt_to_pdata_map  map[] = {
-	{"qcom,i2c-bus-freq", &pdata->clk_freq,     DT_REQUIRED,  DT_U32,   0},
-	{"cell-index",        &pdev->id,            DT_REQUIRED,  DT_U32,  -1},
+	{"qcom,i2c-bus-freq", &pdata->clk_freq    , DT_REQUIRED , DT_U32 ,  0},
+	{"cell-index"       , &pdev->id           , DT_REQUIRED , DT_U32 , -1},
 	{"qcom,i2c-src-freq", &pdata->src_clk_rate, DT_SUGGESTED, DT_U32,   0},
-	{"qcom,master-id",    &pdata->master_id,    DT_SUGGESTED, DT_U32,   0},
-	{"qcom,scl-gpio",      gpios,               DT_OPTIONAL,  DT_GPIO, -1},
-	{"qcom,sda-gpio",      gpios + 1,           DT_OPTIONAL,  DT_GPIO, -1},
-	{"qcom,clk-ctl-xfer", &pdata->clk_ctl_xfer, DT_OPTIONAL,  DT_BOOL, -1},
-	{"qcom,active-only",  &pdata->active_only,  DT_OPTIONAL,  DT_BOOL,  0},
-#if defined(CONFIG_MACH_KS01EUR) || defined(CONFIG_SEC_CHAGALL_PROJECT)
-	{"qcom,noise-rjct-scl", &pdata->noise_rjct_scl, DT_OPTIONAL, DT_U32, 0},
-	{"qcom,noise-rjct-sda", &pdata->noise_rjct_sda, DT_OPTIONAL, DT_U32, 0},
-#endif
-	{NULL,                 NULL,                0,            0,        0},
+	{"qcom,master-id"   , &pdata->master_id   , DT_SUGGESTED, DT_U32,   0},
+	{"qcom,scl-gpio"    , gpios               , DT_OPTIONAL , DT_GPIO, -1},
+	{"qcom,sda-gpio"    , gpios + 1           , DT_OPTIONAL , DT_GPIO, -1},
+	{"qcom,active-only" , &pdata->active_only , DT_OPTIONAL , DT_BOOL,  0},
+	{NULL               , NULL                , 0           , 0      ,  0},
 	};
 
 	for (itr = map; itr->dt_name ; ++itr) {
@@ -1525,7 +1489,7 @@
 		dev_err(&pdev->dev, "Could not get iface_clk\n");
 		ret = PTR_ERR(pclk);
 		clk_put(clk);
-		goto err_config_pckl_failed;
+		goto err_clk_get_failed;
 	}
 
 	/* We support frequencies upto FAST Mode(400KHz) */
@@ -1606,6 +1570,8 @@
 	if (ret)
 		dev_info(&pdev->dev, "clk_set_rate(core_clk, %dHz):%d\n",
 					dev->pdata->src_clk_rate, ret);
+	if (screen_wake_options)
+		pr_alert("SET QUP CLK - %d", dev->pdata->src_clk_rate);
 
 	clk_prepare_enable(dev->clk);
 	clk_prepare_enable(dev->pclk);
@@ -1676,8 +1642,7 @@
 		pdata->msm_i2c_config_gpio(dev->adapter.nr, 1);
 
 	mutex_init(&dev->mlock);
-	dev->pwr_state = MSM_I2C_PM_SUSPENDED;
-	atomic_set(&dev->xfer_progress, 0);
+	dev->pwr_state = 0;
 	/* If the same AHB clock is used on Modem side
 	 * switch it on here itself and don't switch it
 	 * on and off during suspend and resume.
@@ -1698,10 +1663,12 @@
 			dev->adapter.dev.of_node = pdev->dev.of_node;
 			of_i2c_register_devices(&dev->adapter);
 		}
-
+		if (!screen_wake_options)
+		{
 		pm_runtime_set_autosuspend_delay(&pdev->dev, MSEC_PER_SEC);
 		pm_runtime_use_autosuspend(&pdev->dev);
 		pm_runtime_enable(&pdev->dev);
+		}
 		return 0;
 	}
 
@@ -1720,7 +1687,6 @@
 err_alloc_dev_failed:
 err_config_failed:
 	clk_put(clk);
-err_config_pckl_failed:
 	clk_put(pclk);
 err_clk_get_failed:
 	if (gsbi_mem)
@@ -1752,11 +1718,13 @@
 
 	/* Grab mutex to ensure ongoing transaction is over */
 	mutex_lock(&dev->mlock);
-	dev->pwr_state = MSM_I2C_SYS_SUSPENDING;
+	dev->suspended = 1;
 	mutex_unlock(&dev->mlock);
-	i2c_qup_pm_suspend(dev);
-	dev->pwr_state = MSM_I2C_SYS_SUSPENDED;
 	mutex_destroy(&dev->mlock);
+	if (dev->pwr_state != 0) {
+		qup_i2c_pwr_mgmt(dev, 0);
+		qup_i2c_free_gpios(dev);
+	}
 	platform_set_drvdata(pdev, NULL);
 	if (dev->num_irqs == 3) {
 		free_irq(dev->out_irq, dev);
@@ -1794,10 +1762,21 @@
 #ifdef CONFIG_PM
 static int i2c_qup_pm_suspend_runtime(struct device *device)
 {
+	if (!screen_wake_options)
+	{
 	struct platform_device *pdev = to_platform_device(device);
 	struct qup_i2c_dev *dev = platform_get_drvdata(pdev);
 	dev_dbg(device, "pm_runtime: suspending...\n");
-	i2c_qup_pm_suspend(dev);
+		/* Grab mutex to ensure ongoing transaction is over */
+		mutex_lock(&dev->mlock);
+		dev->suspended = 1;
+		mutex_unlock(&dev->mlock);
+		if (dev->pwr_state != 0) {
+			qup_i2c_pwr_mgmt(dev, 0);
+			qup_i2c_free_gpios(dev);
+		}
+	}
+	pr_alert("PM: SUSPEND RUNTIME");
 	return 0;
 }
 
@@ -1805,52 +1784,52 @@
 {
 	struct platform_device *pdev = to_platform_device(device);
 	struct qup_i2c_dev *dev = platform_get_drvdata(pdev);
+	int ret = 0;
 	dev_dbg(device, "pm_runtime: resuming...\n");
-	i2c_qup_pm_resume(dev);
+	if (dev->pwr_state == 0) {
+		ret = qup_i2c_request_gpios(dev);
+		if (ret != 0)
+			return ret;
+		qup_i2c_pwr_mgmt(dev, 1);
+	}
+	dev->suspended = 0;
 	return 0;
 }
 
-static int i2c_qup_pm_suspend_sys(struct device *device)
+static int qup_i2c_suspend(struct device *device)
 {
-	struct platform_device *pdev = to_platform_device(device);
-	struct qup_i2c_dev *dev = platform_get_drvdata(pdev);
-	/* Acquire mutex to ensure current transaction is over */
-	mutex_lock(&dev->mlock);
-	dev->pwr_state = MSM_I2C_SYS_SUSPENDING;
-	mutex_unlock(&dev->mlock);
 	if (!pm_runtime_enabled(device) || !pm_runtime_suspended(device)) {
-		dev_dbg(device, "system suspend\n");
-		i2c_qup_pm_suspend(dev);
+		dev_dbg(device, "system suspend");
+		i2c_qup_pm_suspend_runtime(device);
 		/*
 		 * set the device's runtime PM status to 'suspended'
 		 */
+		if (!screen_wake_options)
+		{
 		pm_runtime_disable(device);
 		pm_runtime_set_suspended(device);
 		pm_runtime_enable(device);
 	}
-	dev->pwr_state = MSM_I2C_SYS_SUSPENDED;
+	}
 	return 0;
 }
 
-static int i2c_qup_pm_resume_sys(struct device *device)
+static int qup_i2c_resume(struct device *device)
 {
-	struct platform_device *pdev = to_platform_device(device);
-	struct qup_i2c_dev *dev = platform_get_drvdata(pdev);
 	/*
 	 * Rely on runtime-PM to call resume in case it is enabled
 	 * Even if it's not enabled, rely on 1st client transaction to do
 	 * clock ON and gpio configuration
 	 */
-	dev_dbg(device, "system resume\n");
-	dev->pwr_state = MSM_I2C_PM_SUSPENDED;
+	dev_dbg(device, "system resume");
 	return 0;
 }
 #endif /* CONFIG_PM */
 
 static const struct dev_pm_ops i2c_qup_dev_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(
-		i2c_qup_pm_suspend_sys,
-		i2c_qup_pm_resume_sys
+		qup_i2c_suspend,
+		qup_i2c_resume
 	)
 	SET_RUNTIME_PM_OPS(
 		i2c_qup_pm_suspend_runtime,
@@ -1878,18 +1857,11 @@
 };
 
 /* QUP may be needed to bring up other drivers */
-int __init qup_i2c_init_driver(void)
+static int __init
+qup_i2c_init_driver(void)
 {
-	static bool initialized;
-
-	if (initialized)
-		return 0;
-	else
-		initialized = true;
-
 	return platform_driver_register(&qup_i2c_driver);
 }
-EXPORT_SYMBOL(qup_i2c_init_driver);
 arch_initcall(qup_i2c_init_driver);
 
 static void __exit qup_i2c_exit_driver(void)
diff -ruBb android_kernel_samsung_msm8974/drivers/input/keyboard/cypress_touchkey/cypress-touchkey.c tuned-kernel-LOS-s5/drivers/input/keyboard/cypress_touchkey/cypress-touchkey.c
--- android_kernel_samsung_msm8974/drivers/input/keyboard/cypress_touchkey/cypress-touchkey.c	2018-03-05 17:54:33.807659445 -0300
+++ tuned-kernel-LOS-s5/drivers/input/keyboard/cypress_touchkey/cypress-touchkey.c	2017-12-14 18:59:14.820610046 -0300
@@ -41,6 +41,10 @@
 #include "issp_extern.h"
 #include <linux/mfd/pm8xxx/pm8921.h>
 
+#ifdef CONFIG_BOEFFLA_TOUCH_KEY_CONTROL
+#include <linux/boeffla_touchkey_control.h>
+#endif
+
 #ifdef USE_OPEN_CLOSE
 static int cypress_input_open(struct input_dev *dev);
 static void cypress_input_close(struct input_dev *dev);
@@ -938,11 +942,23 @@
 				menu_data ? (menu_press ? "menu P " : "menu R ") : "",
 				back_data ? (back_press ? "back P " : "back R ") : "",
 				buf[0], info->ic_fw_ver, info->module_ver);
+
+#ifdef CONFIG_BOEFFLA_TOUCH_KEY_CONTROL
+	if ((menu_press != 0) || (back_press != 0))
+		btkc_touch();
+#endif
+
 #else
 		dev_info(&info->client->dev, "%s: key %s%s fw_ver: 0x%x, modue_ver: 0x%x\n", __func__,
 				menu_data ? (menu_press ? "P" : "R") : "",
 				back_data ? (back_press ? "P" : "R") : "",
 				info->ic_fw_ver, info->module_ver);
+
+#ifdef CONFIG_BOEFFLA_TOUCH_KEY_CONTROL
+	if ((menu_press != 0) || (back_press != 0))
+		btkc_touch();
+#endif
+
 #endif
 	} else {
 		press = !(buf[0] & PRESS_BIT_MASK);
@@ -952,10 +968,22 @@
 		dev_info(&info->client->dev,
 				"%s: code=%d %s. fw_ver=0x%x, module_ver=0x%x \n", __func__,
 				code, press ? "pressed" : "released", info->ic_fw_ver, info->module_ver);
+
+#ifdef CONFIG_BOEFFLA_TOUCH_KEY_CONTROL
+	if (press != 0)
+		btkc_touch();
+#endif
+
 #else
 		dev_info(&info->client->dev,
 				"%s: %s. fw_ver=0x%x, module_ver=0x%x \n", __func__,
 				press ? "pressed" : "released", info->ic_fw_ver, info->module_ver);
+
+#ifdef CONFIG_BOEFFLA_TOUCH_KEY_CONTROL
+	if (press != 0)
+		btkc_touch();
+#endif
+
 #endif
 		if (code < 0) {
 			dev_info(&info->client->dev,
@@ -1261,6 +1289,11 @@
 		return size;
 	}
 
+#ifdef CONFIG_BOEFFLA_TOUCH_KEY_CONTROL
+	if (btkc_block_touchkey_backlight(data))
+		return size;
+#endif
+
 	if (!info->enabled) {
 		touchled_cmd_reversed = 1;
 		goto out;
@@ -2647,6 +2680,11 @@
    cypress_power_onoff(info, 0);
 */
 	dev_info(&info->client->dev, "%s: done\n", __func__);
+
+#ifdef CONFIG_BOEFFLA_TOUCH_KEY_CONTROL
+	btkc_store_handle(info);
+#endif
+
 	return 0;
 
 err_sysfs_group:
diff -ruBb android_kernel_samsung_msm8974/drivers/input/keyboard/gpio_keys.c tuned-kernel-LOS-s5/drivers/input/keyboard/gpio_keys.c
--- android_kernel_samsung_msm8974/drivers/input/keyboard/gpio_keys.c	2018-03-05 17:54:33.819659516 -0300
+++ tuned-kernel-LOS-s5/drivers/input/keyboard/gpio_keys.c	2017-10-20 13:09:48.191717576 -0300
@@ -34,6 +34,9 @@
 #include <mach/sec_debug.h>
 #endif
 #include <linux/regulator/consumer.h>
+#ifdef CONFIG_BOEFFLA_TOUCH_KEY_CONTROL
+void btkc_touch_home_key(void);
+#endif
 
 /* if you want to check gpio status continually use this */
 #if 0
@@ -515,6 +518,11 @@
 		input_event(input, type, button->code, !!state);
 	}
 	input_sync(input);
+	
+#ifdef CONFIG_BOEFFLA_TOUCH_KEY_CONTROL
+	if ((button->code == 172) && (state != 0)) // check if home button was pressed
+		btkc_touch_home_key();
+#endif
 }
 
 static void gpio_keys_gpio_work_func(struct work_struct *work)
Only in tuned-kernel-LOS-s5/drivers/input: kt_wake_funcs.c
Only in tuned-kernel-LOS-s5/drivers/input: kt_wake_funcs_sysfs.c
diff -ruBb android_kernel_samsung_msm8974/drivers/input/Makefile tuned-kernel-LOS-s5/drivers/input/Makefile
--- android_kernel_samsung_msm8974/drivers/input/Makefile	2018-03-05 17:54:33.799659398 -0300
+++ tuned-kernel-LOS-s5/drivers/input/Makefile	2017-10-20 13:09:48.151717174 -0300
@@ -4,7 +4,7 @@
 
 # Each configuration option enables a list of files.
 
-obj-$(CONFIG_INPUT)		+= input-core.o
+obj-$(CONFIG_INPUT)		+= input-core.o kt_wake_funcs.o kt_wake_funcs_sysfs.o
 input-core-y := input.o input-compat.o input-mt.o ff-core.o
 
 obj-$(CONFIG_INPUT_FF_MEMLESS)	+= ff-memless.o
diff -ruBb android_kernel_samsung_msm8974/drivers/input/touchscreen/Kconfig tuned-kernel-LOS-s5/drivers/input/touchscreen/Kconfig
--- android_kernel_samsung_msm8974/drivers/input/touchscreen/Kconfig	2018-03-05 17:54:33.847659682 -0300
+++ tuned-kernel-LOS-s5/drivers/input/touchscreen/Kconfig	2017-10-20 13:09:48.247718138 -0300
@@ -1165,4 +1165,12 @@
 source "drivers/input/touchscreen/stm_fts/Kconfig"
 source "drivers/input/touchscreen/stm_s/Kconfig"
 source "drivers/input/touchscreen/synaptics_jsglte/Kconfig"
+
+config TOUCHBOOST_CONTROL
+	bool "Touch boost control"
+	depends on INPUT_TOUCHSCREEN
+	help
+	  Boeffla Kernels functionality to control input boost as touch boost
+	  in the Boeffla Config app
+
 endif
diff -ruBb android_kernel_samsung_msm8974/drivers/input/touchscreen/Makefile tuned-kernel-LOS-s5/drivers/input/touchscreen/Makefile
--- android_kernel_samsung_msm8974/drivers/input/touchscreen/Makefile	2018-03-05 17:54:33.847659682 -0300
+++ tuned-kernel-LOS-s5/drivers/input/touchscreen/Makefile	2017-10-20 13:09:48.247718138 -0300
@@ -100,3 +100,5 @@
 obj-$(CONFIG_TOUCHSCREEN_FTS) += stm_fts/
 obj-$(CONFIG_TOUCHSCREEN_ZINITIX_BT532)	+= zinitix_bt532_ts.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI_JSGLTE)	+= synaptics_jsglte/
+
+obj-$(CONFIG_TOUCHBOOST_CONTROL)	+= touchboost_switch.o
diff -ruBb android_kernel_samsung_msm8974/drivers/input/touchscreen/synaptics/rmi_f54.c tuned-kernel-LOS-s5/drivers/input/touchscreen/synaptics/rmi_f54.c
--- android_kernel_samsung_msm8974/drivers/input/touchscreen/synaptics/rmi_f54.c	2018-03-05 17:54:33.883659897 -0300
+++ tuned-kernel-LOS-s5/drivers/input/touchscreen/synaptics/rmi_f54.c	2017-10-20 13:09:48.351719184 -0300
@@ -19,6 +19,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <asm/unaligned.h>
+//#include <mach/cpufreq.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
@@ -1161,7 +1162,6 @@
 static void clear_cover_mode(void);
 static void get_glove_sensitivity(void);
 static void fast_glove_mode(void);
-int synaptics_rmi4_glove_mode_enables(struct synaptics_rmi4_data *rmi4_data);
 #endif
 #ifdef TOUCHKEY_ENABLE
 static void run_deltacap_read(void);
@@ -2278,12 +2278,6 @@
 		return count;
 	}
 
-	if ((int)count >= CMD_STR_LEN) {
-		dev_info(&rmi4_data->i2c_client->dev, "%s: cmd size overflow![%d]\n",
-				__func__, (int)count);
-		return count;
-	}
-
 	mutex_lock(&data->cmd_lock);
 	data->cmd_is_running = true;
 	mutex_unlock(&data->cmd_lock);
@@ -2513,14 +2507,6 @@
 	}
 #endif
 
-	/* temp chagall sdc firmware */
-	if ((rmi4_data->ic_version == SYNAPTICS_PRODUCT_ID_S5710) && (rmi4_data->fw_version_of_ic == 0x34)) {
-		dev_info(&rmi4_data->i2c_client->dev,
-			"%s: chagall's sdc firmware is 0x34, it should be updated 0x24 firmware\n",
-				__func__);
-		return false;
-	}
-	
 	if (rmi4_data->fw_version_of_bin <= rmi4_data->fw_version_of_ic) {
 		dev_info(&rmi4_data->i2c_client->dev,
 				"%s: Do not need to update\n",
@@ -3074,8 +3060,6 @@
 		snprintf(data->cmd_buff, CMD_RESULT_STR_LEN, "%s", tostring(S5707));
 	else if (f54->rmi4_data->ic_version == SYNAPTICS_PRODUCT_ID_S5708)
 		snprintf(data->cmd_buff, CMD_RESULT_STR_LEN, "%s", tostring(S5708));
-	else if (f54->rmi4_data->ic_version == SYNAPTICS_PRODUCT_ID_S5006)
-		snprintf(data->cmd_buff, CMD_RESULT_STR_LEN, "%s", tostring(S5006));
 	else
 		snprintf(data->cmd_buff, CMD_RESULT_STR_LEN, "%s", tostring(NA));
 
@@ -3189,8 +3173,6 @@
 	struct factory_data *data = f54->factory_data;
 	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
 	unsigned char command = 0x01;
-	int retry = 2;
-	unsigned char cmd_state = CMD_STATUS_RUNNING;
 
 	set_default_result(data);
 
@@ -3203,29 +3185,9 @@
 		return;
 	}
 
-	while (retry--) {
 		retval = do_preparation();
 		if (retval < 0) {
 			dev_err(&rmi4_data->i2c_client->dev,
-				"%s: Failed to do preparation, do soft reset, and retry\n",
-				__func__);
-			/* soft reset */
-			retval = f54->fn_ptr->write(rmi4_data,
-					rmi4_data->f01_cmd_base_addr,
-					&command,
-					sizeof(command));
-			if (retval < 0) {
-				dev_err(&rmi4_data->i2c_client->dev,
-					"%s: Failed to issue reset1 command 1, error = %d\n",
-					__func__, retval);
-			}
-			msleep(100);
-		} else {
-			break;
-		}
-	}
-	if (retval < 0) {
-		dev_err(&rmi4_data->i2c_client->dev,
 				"%s: Failed to do preparation\n",
 				__func__);
 		snprintf(data->cmd_buff, CMD_RESULT_STR_LEN, "%s", "Error preparation");
@@ -3235,7 +3197,7 @@
 	}
 
 	if (!synaptics_rmi4_f54_get_report_type(CMD_REPORT_TYPE_RAWCAP)) {
-		cmd_state = CMD_STATUS_FAIL;
+		data->cmd_state = CMD_STATUS_FAIL;
 		goto exit;
 	}
 
@@ -3271,18 +3233,20 @@
 	snprintf(data->cmd_buff, CMD_RESULT_STR_LEN, "%d,%d", min_value, max_value);
 	set_cmd_result(data, data->cmd_buff, strlen(data->cmd_buff));
 
-	cmd_state = CMD_STATUS_OK;
+	data->cmd_state = CMD_STATUS_OK;
 
 exit:
-	retval = rmi4_data->reset_device(rmi4_data);
+	/* soft reset */
+	retval = f54->fn_ptr->write(rmi4_data,
+			rmi4_data->f01_cmd_base_addr,
+			&command,
+			sizeof(command));
 	if (retval < 0) {
 		dev_err(&rmi4_data->i2c_client->dev,
 				"%s: Failed to issue reset command, error = %d\n",
 				__func__, retval);
 	}
 
-	data->cmd_state = cmd_state;
-
 	return;
 }
 
@@ -3300,7 +3264,7 @@
 	short cur_value;
 	struct factory_data *data = f54->factory_data;
 	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
-	unsigned char cmd_state = CMD_STATUS_RUNNING;
+	unsigned char command = 0x01;
 
 	set_default_result(data);
 
@@ -3314,7 +3278,7 @@
 	}
 
 	if (!synaptics_rmi4_f54_get_report_type(F54_RAW_16BIT_IMAGE)) {
-		cmd_state = CMD_STATUS_FAIL;
+		data->cmd_state = CMD_STATUS_FAIL;
 		goto exit;
 	}
 
@@ -3342,18 +3306,20 @@
 	snprintf(data->cmd_buff, CMD_RESULT_STR_LEN, "%d,%d", min_value, max_value);
 	set_cmd_result(data, data->cmd_buff, strlen(data->cmd_buff));
 
-	cmd_state = CMD_STATUS_OK;
+	data->cmd_state = CMD_STATUS_OK;
 
 exit:
-	retval = rmi4_data->reset_device(rmi4_data);
+	/* soft reset */
+	retval = f54->fn_ptr->write(rmi4_data,
+			rmi4_data->f01_cmd_base_addr,
+			&command,
+			sizeof(command));
 	if (retval < 0) {
 		dev_err(&rmi4_data->i2c_client->dev,
 				"%s: Failed to issue reset command, error = %d\n",
 				__func__, retval);
 	}
 
-	data->cmd_state = cmd_state;
-
 	return;
 }
 
@@ -3444,8 +3410,8 @@
 	unsigned char ii;
 	unsigned short num_of_tx;
 	unsigned short num_of_rx;
+	unsigned char command = 0x01;
 	int retval;
-	unsigned char cmd_state = CMD_STATUS_RUNNING;
 
 	set_default_result(data);
 
@@ -3458,13 +3424,9 @@
 		return;
 	}
 
-	retval = synaptics_rmi4_f54_get_report_type(F54_ABS_CAP);
-	if (!retval) {
-		dev_err(&rmi4_data->i2c_client->dev,
-			"%s: Failed to get report type\n",
-			__func__);
-		cmd_state = CMD_STATUS_FAIL;
-		goto exit;
+	if (!synaptics_rmi4_f54_get_report_type(F54_ABS_CAP)) {
+		data->cmd_state = CMD_STATUS_FAIL;
+		return;
 	}
 
 	report_data = f54->factory_data->abscap_data;
@@ -3491,17 +3453,16 @@
 	snprintf(data->cmd_buff, CMD_RESULT_STR_LEN, "%s", temp2);
 	set_cmd_result(data, data->cmd_buff, strlen(data->cmd_buff));
 
-	cmd_state = CMD_STATUS_OK;
-
-exit:
-	retval = rmi4_data->reset_device(rmi4_data);
+	retval = f54->fn_ptr->write(rmi4_data,
+				rmi4_data->f01_cmd_base_addr,
+				&command,
+				sizeof(command));
 	if (retval < 0) {
 		dev_err(&rmi4_data->i2c_client->dev,
 				"%s: Failed to issue reset command, error = %d\n",
 				__func__, retval);
 	}
-
-	data->cmd_state = cmd_state;
+	data->cmd_state = CMD_STATUS_OK;
 
 	return;
 }
@@ -3517,8 +3478,8 @@
 	unsigned char ii;
 	unsigned short num_of_tx;
 	unsigned short num_of_rx;
+	unsigned char command = 0x01;
 	int retval;
-	unsigned char cmd_state = CMD_STATUS_RUNNING;
 
 	set_default_result(data);
 
@@ -3541,8 +3502,8 @@
 #endif
 
 	if (!synaptics_rmi4_f54_get_report_type(F54_ABS_DELTA)) {
-		cmd_state = CMD_STATUS_FAIL;
-		goto exit;
+		data->cmd_state = CMD_STATUS_FAIL;
+		return;
 	}
 
 	report_data = f54->factory_data->absdelta_data;
@@ -3566,18 +3527,19 @@
 	snprintf(data->cmd_buff, CMD_RESULT_STR_LEN, "%s", temp2);
 	set_cmd_result(data, data->cmd_buff, strlen(data->cmd_buff));
 
-	cmd_state = CMD_STATUS_OK;
+	data->cmd_state = CMD_STATUS_OK;
 
-exit:
-	retval = rmi4_data->reset_device(rmi4_data);
+	/* soft reset */
+	retval = f54->fn_ptr->write(rmi4_data,
+			rmi4_data->f01_cmd_base_addr,
+			&command,
+			sizeof(command));
 	if (retval < 0) {
 		dev_err(&rmi4_data->i2c_client->dev,
 				"%s: Failed to issue reset command, error = %d\n",
 				__func__, retval);
 	}
 
-	data->cmd_state = cmd_state;
-
 	return;
 }
 
@@ -3598,9 +3560,9 @@
 	char *report_data;
 	unsigned char ii, jj;
 	int retval = 0;
+	unsigned char command = 0x01;
 	char temp[CMD_STR_LEN];
 	char temp2[CMD_RESULT_STR_LEN];
-	unsigned char cmd_state = CMD_STATUS_RUNNING;
 
 	set_default_result(data);
 
@@ -3615,7 +3577,7 @@
 
 	disable_irq(rmi4_data->i2c_client->irq);
 	if (!synaptics_rmi4_f54_get_report_type(F54_TREX_SHORTS)) {
-		cmd_state = CMD_STATUS_FAIL;
+		data->cmd_state = CMD_STATUS_FAIL;
 		goto exit;
 	}
 
@@ -3643,20 +3605,22 @@
 
 	set_cmd_result(data, data->cmd_buff, strlen(data->cmd_buff));
 
-	cmd_state = CMD_STATUS_OK;
+	data->cmd_state = CMD_STATUS_OK;
 
 exit:
 	enable_irq(rmi4_data->i2c_client->irq);
 
-	retval = rmi4_data->reset_device(rmi4_data);
+	/* soft reset */
+	retval = f54->fn_ptr->write(rmi4_data,
+			rmi4_data->f01_cmd_base_addr,
+			&command,
+			sizeof(command));
 	if (retval < 0) {
 		dev_err(&rmi4_data->i2c_client->dev,
 				"%s: Failed to issue reset command, error = %d\n",
 				__func__, retval);
 	}
 
-	data->cmd_state = cmd_state;
-
 	return;
 }
 
@@ -3889,18 +3853,12 @@
 	} else {
 		int retval;
 
-		if (data->cmd_param[0]){
+		if (data->cmd_param[0])
 			rmi4_data->feature_enable |= GLOVE_MODE_EN;
-#ifdef ENABLE_F12_OBJTYPE
-			rmi4_data->obj_type_enable |= OBJ_TYPE_GLOVE;
-#endif
-		} else {
+		else
 			rmi4_data->feature_enable &= ~(GLOVE_MODE_EN);
-#ifdef ENABLE_F12_OBJTYPE
-			rmi4_data->obj_type_enable &= ~(OBJ_TYPE_GLOVE);
-#endif
-		}
-		retval = synaptics_rmi4_glove_mode_enables(rmi4_data);
+
+		retval = synaptics_rmi4_f12_set_feature(rmi4_data);
 		if (retval < 0) {
 			dev_err(&rmi4_data->i2c_client->dev,
 					"%s failed, retval = %d\n",
@@ -3940,19 +3898,13 @@
 
 		if (data->cmd_param[0]) {
 			rmi4_data->feature_enable |= FAST_DETECT_EN | GLOVE_MODE_EN;
-#ifdef ENABLE_F12_OBJTYPE
-			rmi4_data->obj_type_enable |= OBJ_TYPE_GLOVE;
-#endif
 			rmi4_data->fast_glove_state = true;
 		} else {
 			rmi4_data->feature_enable &= ~(FAST_DETECT_EN);
-#ifdef ENABLE_F12_OBJTYPE
-			rmi4_data->obj_type_enable &= ~(OBJ_TYPE_GLOVE);
-#endif
 			rmi4_data->fast_glove_state = false;
 		}
 
-		retval = synaptics_rmi4_glove_mode_enables(rmi4_data);
+		retval = synaptics_rmi4_f12_set_feature(rmi4_data);
 		if (retval < 0) {
 			dev_err(&rmi4_data->i2c_client->dev,
 					"%s failed, retval = %d\n",
@@ -4398,10 +4350,10 @@
 	unsigned char ii, jj = 0;
 	unsigned short num_of_tx;
 	unsigned short num_of_rx;
+	unsigned char command = 0x01;
 	int retval;
 	unsigned char sidekey_production_test[1];
 	int length = 1;
-	unsigned char cmd_state = CMD_STATUS_RUNNING;
 
 	set_default_result(data);
 
@@ -4430,8 +4382,8 @@
 	rmi4_data->sidekey_test = true;
 
 	if (!synaptics_rmi4_f54_get_report_type(F54_ABS_CAP)) {
-		cmd_state = CMD_STATUS_FAIL;
-		goto exit;
+		data->cmd_state = CMD_STATUS_FAIL;
+		return;
 	}
 
 	report_data = f54->factory_data->abscap_data;
@@ -4465,9 +4417,10 @@
 	snprintf(data->cmd_buff, CMD_RESULT_STR_LEN, "%s", temp2);
 	set_cmd_result(data, data->cmd_buff, strlen(data->cmd_buff));
 
-	cmd_state = CMD_STATUS_OK;
-exit:
-	retval = rmi4_data->reset_device(rmi4_data);
+	retval = f54->fn_ptr->write(rmi4_data,
+				rmi4_data->f01_cmd_base_addr,
+				&command,
+				sizeof(command));
 	if (retval < 0) {
 		dev_err(&rmi4_data->i2c_client->dev,
 				"%s: Failed to issue reset command, error = %d\n",
@@ -4476,7 +4429,7 @@
 
 	rmi4_data->sidekey_test = false;
 
-	data->cmd_state = cmd_state;
+	data->cmd_state = CMD_STATUS_OK;
 
 	return;
 }
@@ -4598,7 +4551,6 @@
 
 	int retval = 0;
 	unsigned char device_status = 0;
-	int retry = 2;
 
 	set_default_result(data);
 
@@ -4633,19 +4585,8 @@
 					__func__, device_status);
 		}
 
-		while (retry--) {
 			retval = synaptics_rmi4_set_tsp_test_result_in_config(data->cmd_param[0]);
-			if (retval < 0) {
-				dev_err(&rmi4_data->i2c_client->dev, "%s: failed [%d], retry%d\n",
-					__func__, retval, retry);
-				synaptics_power_ctrl(rmi4_data, false);
-				msleep(SYNAPTICS_POWER_MARGIN_TIME);
-				synaptics_power_ctrl(rmi4_data, true);
-				msleep(SYNAPTICS_POWER_MARGIN_TIME);
-			} else {
-				break;
-			}
-		}
+
 		msleep(200);
 
 		if (retval < 0) {
@@ -6041,7 +5982,7 @@
 {
 	int retval;
 	char buf[3];
-	unsigned int patience = 90;
+	unsigned int patience = 250;
 
 	memset(buf, 0x00, sizeof(buf));
 	snprintf(buf, 3, "%u\n", type);
@@ -6076,22 +6017,7 @@
 
 	if (f54->status != STATUS_BUSY)
 		return;
-#if defined(CONFIG_SEC_RUBENS_PROJECT)
-	retval = f54->fn_ptr->read(rmi4_data,
-			f54->query_base_addr,
-			f54->query.data,
-			sizeof(f54->query.data));
-	if (retval < 0) {
-		dev_err(&rmi4_data->i2c_client->dev,
-				"%s: Failed to read f54 query registers\n",
-				__func__);
-		retval = -EINVAL;
-		goto error_exit;
-	}
 
-	f54->rx_assigned = f54->query.num_of_rx_electrodes;
-	f54->tx_assigned = f54->query.num_of_tx_electrodes;
-#endif
 	set_report_size();
 	if (f54->report_size == 0) {
 		dev_err(&rmi4_data->i2c_client->dev,
@@ -6687,13 +6613,7 @@
 		}
 
 		rmi4_data->created_sec_class = true;
-		retval = sysfs_create_link(&factory_data->fac_dev_ts->kobj,
-						&rmi4_data->input_dev->dev.kobj, "input");
-		if (retval < 0) {
-			dev_err(&rmi4_data->i2c_client->dev,
-				"%s: Failed to create input symbolic link\n",
-					__func__);
-		}
+
 		retval = sysfs_create_group(&factory_data->fac_dev_ts->kobj,
 				&cmd_attr_group);
 		if (retval < 0) {
diff -ruBb android_kernel_samsung_msm8974/drivers/input/touchscreen/synaptics/synaptics_i2c_rmi.c tuned-kernel-LOS-s5/drivers/input/touchscreen/synaptics/synaptics_i2c_rmi.c
--- android_kernel_samsung_msm8974/drivers/input/touchscreen/synaptics/synaptics_i2c_rmi.c	2018-03-05 17:54:33.887659921 -0300
+++ tuned-kernel-LOS-s5/drivers/input/touchscreen/synaptics/synaptics_i2c_rmi.c	2017-10-20 13:09:48.355719224 -0300
@@ -219,6 +219,40 @@
 			synaptics_rmi4_suspend_store),
 };
 
+
+
+//KT specifics
+extern void hotplugap_boostpulse(void);
+#include <linux/wakelock.h>
+#include <linux/kt_wake_funcs.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#define RESET_SLEEPER	5
+int SYN_I2C_RETRY_TIMES = 10;
+int GPIO_CFG_KT = GPIO_CFG_2MA;
+static struct delayed_work lockout_touch_work;
+static bool lockout_touch_work_done = false;
+//static struct synaptics_rmi4_data *grmi4_data;
+static struct wake_lock wakelock;
+
+static void lockout_touch_work_func(struct work_struct *work)
+{
+	//wake_lock_timeout(&wakelock, msecs_to_jiffies(2000));
+	wake_lock(&wakelock);
+	//pm_runtime_resume(&grmi4_data->i2c_client->dev);
+	lockout_touch_work_done = false;
+	//gpio_tlmm_config(GPIO_CFG(grmi4_data->dt_data->scl_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_KT), 1);
+	//gpio_tlmm_config(GPIO_CFG(grmi4_data->dt_data->sda_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_KT), 1);
+	//synaptics_power_ctrl(grmi4_data, true);
+	//grmi4_data->current_page = MASK_8BIT;
+	//grmi4_data->touch_stopped = false;
+	//msleep(SYNAPTICS_HW_RESET_TIME);
+	//synaptics_rmi4_reinit_device(grmi4_data);
+	//enable_irq_wake(grmi4_data->i2c_client->irq);
+}
+
+
+
 #ifdef READ_LCD_ID
 static int synaptics_lcd_id;
 static int __init synaptics_read_lcd_id(char *mode)
@@ -256,15 +290,11 @@
 
 	/* vdd, irq gpio info */
 	dt_data->external_ldo = of_get_named_gpio(np, "synaptics,external_ldo", 0);
-#if defined(CONFIG_SEC_RUBENS_PROJECT)
-	dt_data->external_ldo2 = of_get_named_gpio(np, "synaptics,external_ldo2", 0);
-#endif
 	dt_data->scl_gpio = of_get_named_gpio(np, "synaptics,scl-gpio", 0);
 	dt_data->sda_gpio = of_get_named_gpio(np, "synaptics,sda-gpio", 0);
 	dt_data->irq_gpio = of_get_named_gpio(np, "synaptics,irq-gpio", 0);
 	dt_data->reset_gpio = of_get_named_gpio(np, "synaptics,reset-gpio", 0);
 	dt_data->id_gpio = of_get_named_gpio(np, "synaptics,id-gpio", 0);
-	dt_data->tablet = of_property_read_bool(np, "synaptics,tablet");
 
 	rc = of_property_read_u32_array(np, "synaptics,tsp-coords", coords, 2);
 	if (rc < 0) {
@@ -396,16 +426,7 @@
 			return;
 		}
 	}
-#if defined(CONFIG_SEC_RUBENS_PROJECT)
-	if (rmi4_data->dt_data->external_ldo2 > 0) {
-		ret = gpio_request(rmi4_data->dt_data->external_ldo2, "synaptics,external_ldo2");
-		if (ret) {
-			pr_err("%s: unable to request external_ldo [%d]\n",
-					__func__, rmi4_data->dt_data->external_ldo2);
-			return;
-		}
-	}
-#endif
+
 	if (rmi4_data->dt_data->tkey_led_en > 0) {
 		ret = gpio_request(rmi4_data->dt_data->tkey_led_en, "synaptics,tkey_led_vdd_on");
 		if (ret) {
@@ -423,8 +444,8 @@
 			return;
 		}
 	}
-	gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->scl_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), 1);
-	gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->sda_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), 1);
+	gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->scl_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_KT), 1);
+	gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->sda_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_KT), 1);
 
 	if (rmi4_data->dt_data->id_gpio > 0) {
 		ret = gpio_request(rmi4_data->dt_data->id_gpio, "synaptics,id-gpio");
@@ -631,47 +652,6 @@
 }
 
 #ifdef GLOVE_MODE
-#ifdef ENABLE_F12_OBJTYPE
-static int synaptics_rmi4_f12_obj_type_enable(struct synaptics_rmi4_data *rmi4_data)
-{
-	int retval = 0;
-
-	retval = synaptics_rmi4_i2c_write(rmi4_data,
-			rmi4_data->f12_ctrl23_addr,
-			&rmi4_data->obj_type_enable,
-			sizeof(rmi4_data->obj_type_enable));
-	if (retval < 0)
-		dev_err(&rmi4_data->i2c_client->dev, "%s: write fail[%d]\n",
-			__func__, retval);
-
-	return retval;
-}
-#endif
-
-int synaptics_rmi4_glove_mode_enables(struct synaptics_rmi4_data *rmi4_data)
-{
-	int retval = 0;
-
-	if (rmi4_data->touch_stopped)
-		goto out;
-
-	retval = synaptics_rmi4_f12_set_feature(rmi4_data);
-	if (retval < 0) {
-		dev_err(&rmi4_data->i2c_client->dev,
-			"%s: f12 set_feature write fail[%d]\n", __func__, retval);
-	}
-	
-#ifdef ENABLE_F12_OBJTYPE
-	retval = synaptics_rmi4_f12_obj_type_enable(rmi4_data);
-	if (retval < 0) {
-		dev_err(&rmi4_data->i2c_client->dev,
-			"%s: f12 obj_type write fail[%d]\n", __func__, retval);
-	}
-#endif
-out:
-	return retval;
-}
-
 static ssize_t synaptics_rmi4_glove_mode_enable_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -707,7 +687,7 @@
 	if (input)
 		rmi4_data->feature_enable |= GLOVE_MODE_EN;
 
-	retval = synaptics_rmi4_glove_mode_enables(rmi4_data);
+	retval = synaptics_rmi4_f12_set_feature(rmi4_data);
 	if (retval < 0) {
 		dev_err(dev,
 				"%s: Failed to set glove mode enable, error = %d\n",
@@ -1258,17 +1238,37 @@
 					return retval;
 				}
 				dev_err(&i2c->dev,
-						"%s: I2C retry = %d, i2c_master_send retval = %d\n",
-						__func__, retry + 1, retval);
+						"%s: I2C retry = %d, i2c_master_send retval = %d %d %d\n",
+						__func__, retry + 1, retval, screen_is_off, screen_wake_options_when_off);
 				if (retval == 0)
 					retval = -EAGAIN;
+				if (screen_wake_options)
+				{
+					pm_runtime_resume(&rmi4_data->i2c_client->dev);
+					if (!lockout_touch_work_done)
+					{
+						wake_lock(&wakelock);
+						disable_irq_wake(rmi4_data->i2c_client->irq);
+						msleep(20);
+						enable_irq_wake(rmi4_data->i2c_client->irq);
+						//lockout_touch_work_done = true;
+						//schedule_delayed_work_on(0, &lockout_touch_work, msecs_to_jiffies(RESET_SLEEPER));
+					}
+					rmi4_data->current_page = page;
+					break;
+				}
+				else
 				msleep(20);
 			} else {
+				if (screen_wake_options)
+					wake_unlock(&wakelock);
 				rmi4_data->current_page = page;
 				break;
 			}
 		}
 	} else {
+		if (screen_wake_options)
+			wake_unlock(&wakelock);
 		retval = PAGE_SELECT_LEN;
 	}
 
@@ -1324,10 +1324,29 @@
 	for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
 		if (i2c_transfer(rmi4_data->i2c_client->adapter, msg, 2) == 2) {
 			retval = length;
+			if (screen_wake_options)
+				wake_unlock(&wakelock);
 			break;
 		}
-		dev_err(&rmi4_data->i2c_client->dev, "%s: I2C retry %d\n",
-				__func__, retry + 1);
+		dev_err(&rmi4_data->i2c_client->dev, "%s: I2C retry %d %d %d\n",
+				__func__, retry + 1, screen_is_off, screen_wake_options_when_off);
+		
+		if (screen_wake_options)
+		{
+			pm_runtime_resume(&rmi4_data->i2c_client->dev);
+			if (!lockout_touch_work_done)
+			{
+				wake_lock(&wakelock);
+				disable_irq_wake(rmi4_data->i2c_client->irq);
+				msleep(20);
+				enable_irq_wake(rmi4_data->i2c_client->irq);
+				//lockout_touch_work_done = true;
+				//schedule_delayed_work_on(0, &lockout_touch_work, msecs_to_jiffies(RESET_SLEEPER));
+			}
+			retval = length;
+			break;
+		}
+		else
 		msleep(20);
 	}
 
@@ -1387,11 +1406,29 @@
 	for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
 		if (i2c_transfer(rmi4_data->i2c_client->adapter, msg, 1) == 1) {
 			retval = length;
+			if (screen_wake_options)
+				wake_unlock(&wakelock);
 			break;
 		}
 		dev_err(&rmi4_data->i2c_client->dev,
-				"%s: I2C retry %d\n",
-				__func__, retry + 1);
+				"%s: I2C retry %d %d %d\n",
+				__func__, retry + 1, screen_is_off, screen_wake_options_when_off);
+		if (screen_wake_options)
+		{
+			pm_runtime_resume(&rmi4_data->i2c_client->dev);
+			if (!lockout_touch_work_done)
+			{
+				wake_lock(&wakelock);
+				disable_irq_wake(rmi4_data->i2c_client->irq);
+				msleep(20);
+				enable_irq_wake(rmi4_data->i2c_client->irq);
+				//lockout_touch_work_done = true;
+				//schedule_delayed_work_on(0, &lockout_touch_work, msecs_to_jiffies(RESET_SLEEPER));
+			}
+			retval = length;
+			break;
+		}
+		else
 		msleep(20);
 	}
 
@@ -1605,7 +1642,11 @@
 				extra_data->data15_data,
 				extra_data->data15_size);
 		if (retval < 0)
+		{
+			//if (screen_is_off)
+			//	synaptics_rmi4_free_fingers(rmi4_data);
 			return 0;
+		}
 
 		d_len = (extra_data->data15_data[0] | ((extra_data->data15_data[1] & 0x3) << 8));
 
@@ -1631,6 +1672,8 @@
 	if (retval < 0) {
 		dev_err(&rmi4_data->i2c_client->dev, "%s:%4d read fail[%d]\n",
 				__func__, __LINE__, retval);
+		//if (screen_is_off)
+		//	synaptics_rmi4_free_fingers(rmi4_data);
 		return 0;
 	}
 	data = (struct synaptics_rmi4_f12_finger_data *)fhandler->data;
@@ -1714,8 +1757,15 @@
 					input_report_abs(rmi4_data->input_dev,
 							ABS_MT_WIDTH_MAJOR, rmi4_data->f51_handle->surface_data.sumsize);
 #endif
+#else
+					input_report_abs(rmi4_data->input_dev,
+							ABS_MT_SUMSIZE, rmi4_data->f51_handle->surface_data.sumsize);
 #endif
 
+#ifdef REPORT_ANGLE
+					input_report_abs(rmi4_data->input_dev,
+							ABS_MT_ANGLE, rmi4_data->f51_handle->surface_data.angle);
+#endif
 					input_report_abs(rmi4_data->input_dev,
 							ABS_MT_PALM, rmi4_data->f51_handle->surface_data.palm);
 				}
@@ -1723,12 +1773,10 @@
 			}
 #endif	/* EDGE_SWIPE */
 #endif	/* REPORT_2D_W */
-
-
-			if (rmi4_data->dt_data->tablet > 0) {
+			if (rmi4_data->dt_data->x_flip)
 				x = rmi4_data->sensor_max_x - x;
+			if (rmi4_data->dt_data->y_flip)
 				y = rmi4_data->sensor_max_y - y;
-			}
 
 			input_report_key(rmi4_data->input_dev,
 					BTN_TOUCH, 1);
@@ -1745,6 +1793,13 @@
 					ABS_MT_TOUCH_MINOR, min(wx, wy));
 #endif
 
+			// ***** KT WAKE AND SLEEP OPTIONS *****
+			if (screen_is_off && screen_wake_options && !call_in_progress)
+				check_touch_off(x, y, rmi4_data->finger[finger].state, touch_count);
+			if (!screen_is_off && screen_sleep_options == 1 && !call_in_progress)
+				check_touch_on(x, y, rmi4_data->finger[finger].state, touch_count);
+			// ***** KT WAKE AND SLEEP OPTIONS *****
+
 			if (!rmi4_data->finger[finger].state) {
 #if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
 				dev_info(&rmi4_data->i2c_client->dev,
@@ -1933,11 +1988,21 @@
 	if (retval < 0) {
 		dev_err(&rmi4_data->i2c_client->dev, "%s: read fail[%d]\n",
 					__func__, retval);
+		//synaptics_rmi4_free_fingers(rmi4_data);
 		return retval;
 	}
 
 	if (!rmi4_data->f51_handle)
 		return -ENODEV;
+#ifdef REPORT_ANGLE
+	if (data->edge_swipe_dg >= 90 && data->edge_swipe_dg <= 180)
+		rmi4_data->f51_handle->surface_data.angle = data->edge_swipe_dg - 180;
+	else if (data->edge_swipe_dg < 90)
+		rmi4_data->f51_handle->surface_data.angle = data->edge_swipe_dg;
+	else
+		dev_err(&rmi4_data->i2c_client->dev, "Skip wrong edge swipe angle [%d]\n",
+				data->edge_swipe_dg);
+#endif
 	rmi4_data->f51_handle->surface_data.sumsize = data->edge_swipe_mm;
 	rmi4_data->f51_handle->surface_data.wx = data->edge_swipe_wx;
 	rmi4_data->f51_handle->surface_data.wy = data->edge_swipe_wy;
@@ -2221,6 +2286,7 @@
 		dev_err(&rmi4_data->i2c_client->dev,
 				"%s: Failed to read detection_flag\n",
 				__func__);
+		//synaptics_rmi4_free_fingers(rmi4_data);
 		return;
 	}
 
@@ -2230,6 +2296,7 @@
 		dev_err(&rmi4_data->i2c_client->dev,
 				"%s: Failed to read detection_flag2\n",
 				__func__);
+		//synaptics_rmi4_free_fingers(rmi4_data);
 		return;
 	}
 
@@ -2323,6 +2390,7 @@
 		dev_err(&rmi4_data->i2c_client->dev,
 				"%s: Failed to read interrupt status\n",
 				__func__);
+		synaptics_rmi4_free_fingers(rmi4_data);
 		return retval;
 	}
 
@@ -2341,6 +2409,7 @@
 			dev_err(&rmi4_data->i2c_client->dev,
 					"%s: Failed to reinit device\n",
 					__func__);
+			//synaptics_rmi4_free_fingers(rmi4_data);
 		}
 		return 0;
 	}
@@ -2434,15 +2503,10 @@
 			return retval;
 		}
 
-		if (rmi4_data->dt_data->extra_config[3])
+		// | IRQF_NO_SUSPEND
 		retval = request_threaded_irq(rmi4_data->irq, NULL,
-				synaptics_rmi4_irq, TSP_IRQ_TYPE_LEVEL, 
+				synaptics_rmi4_irq, IRQF_TRIGGER_FALLING,
 				DRIVER_NAME, rmi4_data);
-		else
-			retval = request_threaded_irq(rmi4_data->irq, NULL,
-				synaptics_rmi4_irq, TSP_IRQ_TYPE_EDGE, 
-				DRIVER_NAME, rmi4_data);
-
 		if (retval < 0) {
 			dev_err(&rmi4_data->i2c_client->dev,
 					"%s: Failed to create irq thread\n",
@@ -2591,6 +2655,7 @@
 	if (retval < 0) {
 		dev_err(&rmi4_data->i2c_client->dev, "%s: write fail[%d]\n",
 				__func__, retval);
+		//synaptics_rmi4_free_fingers(rmi4_data);
 		return retval;
 	}
 
@@ -2609,6 +2674,7 @@
 		if (retval < 0) {
 			dev_err(&rmi4_data->i2c_client->dev, "%s: write fail[%d]\n",
 				__func__, retval);
+			//synaptics_rmi4_free_fingers(rmi4_data);
 			return retval;
 		}
 
@@ -2822,11 +2888,6 @@
 	rmi4_data->f12_ctrl26_addr = fhandler->full_addr.ctrl_base + ctrl_26_offset;
 	rmi4_data->f12_ctrl28_addr = fhandler->full_addr.ctrl_base + ctrl_28_offset;
 
-#ifdef ENABLE_F12_OBJTYPE
-	rmi4_data->f12_ctrl23_addr = fhandler->full_addr.ctrl_base + ctrl_23_offset;
-	rmi4_data->obj_type_enable = OBJ_TYPE_FINGER | OBJ_TYPE_UNCLASSIFIED;
-#endif
-
 	if (rmi4_data->has_glove_mode) {
 		retval = synaptics_rmi4_i2c_read(rmi4_data,
 				rmi4_data->f12_ctrl26_addr,
@@ -2853,16 +2914,6 @@
 		return retval;
 	}
 
-#ifdef ENABLE_F12_OBJTYPE
-	retval = synaptics_rmi4_f12_obj_type_enable(rmi4_data);
-	if (retval < 0) {
-		dev_err(&rmi4_data->i2c_client->dev,
-				"%s, Failed to set object. [%d]\n",
-			__func__, retval);
-		return retval;
-	}
-#endif
-
 	retval = synaptics_rmi4_i2c_read(rmi4_data,
 			fhandler->full_addr.ctrl_base + ctrl_8_offset,
 			ctrl_8.data,
@@ -3017,7 +3068,7 @@
 
 	return 0;
 }
-#if !defined(CONFIG_SEC_RUBENS_PROJECT)
+
 static int synaptics_rmi4_f1a_button_map(struct synaptics_rmi4_data *rmi4_data,
 		struct synaptics_rmi4_fn *fhandler)
 {
@@ -3069,7 +3120,7 @@
 
 	return 0;
 }
-#endif
+
 static void synaptics_rmi4_f1a_kfree(struct synaptics_rmi4_fn *fhandler)
 {
 	struct synaptics_rmi4_f1a_handle *f1a = fhandler->data;
@@ -3113,13 +3164,13 @@
 	retval = synaptics_rmi4_f1a_alloc_mem(rmi4_data, fhandler);
 	if (retval < 0)
 		goto error_exit;
-#if !defined(CONFIG_SEC_RUBENS_PROJECT)
+
 	retval = synaptics_rmi4_f1a_button_map(rmi4_data, fhandler);
 	if (retval < 0)
 		goto error_exit;
 
 	rmi4_data->button_0d_enabled = 1;
-#endif
+
 	return 0;
 
 error_exit:
@@ -3984,17 +4035,13 @@
 		rmi4_data->ic_version = SYNAPTICS_PRODUCT_ID_S5708;
 	else if (strncmp(rmi->product_id_string + 1, "5707", 4) == 0)
 		rmi4_data->ic_version = SYNAPTICS_PRODUCT_ID_S5707;
-	else if (strncmp(rmi->product_id_string + 1, "5006", 4) == 0)
-		rmi4_data->ic_version = SYNAPTICS_PRODUCT_ID_S5006;
-	else if (strncmp(rmi->product_id_string + 1, "5710", 4) == 0)
-		rmi4_data->ic_version = SYNAPTICS_PRODUCT_ID_S5710;
 	else
 		rmi4_data->ic_version = SYNAPTICS_PRODUCT_ID_NONE;
 
 /* below code is only S5000 IC temporary code. will be removed..*/
 	if (rmi4_data->ic_version == SYNAPTICS_PRODUCT_ID_S5000)
 		rmi4_data->ic_revision_of_ic = 0xB0;
-#if !defined(CONFIG_SEC_HESTIA_PROJECT)
+
 	if (rmi4_data->ic_version == SYNAPTICS_PRODUCT_ID_S5100) {
 		if ((strncmp(rmi->product_id_string + 6, "A1", 2) == 0) ||
 			(strncmp(rmi->product_id_string + 6, "a1", 2) == 0)) {
@@ -4018,7 +4065,7 @@
 			rmi4_data->ic_revision_of_ic = SYNAPTICS_IC_REVISION_NONE;
 		}
 	}
-#endif
+
 	retval = synaptics_rmi4_i2c_read(rmi4_data,
 			0x31, f01_package_id,
 			sizeof(f01_package_id));
@@ -4205,6 +4252,15 @@
 	input_set_abs_params(rmi4_data->input_dev,
 			ABS_MT_WIDTH_MAJOR, 0,
 			EDGE_SWIPE_WIDTH_MAX, 0, 0);
+#else
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_SUMSIZE, 0,
+			EDGE_SWIPE_WIDTH_MAX, 0, 0);
+#endif
+#ifdef REPORT_ANGLE
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_ANGLE, 0,
+			EDGE_SWIPE_ANGLE_MAX, 0, 0);
 #endif
 	input_set_abs_params(rmi4_data->input_dev,
 			ABS_MT_PALM, 0,
@@ -4265,6 +4321,7 @@
 #ifdef PROXIMITY
 	if (rmi4_data->has_edge_swipe) {
 		rmi4_data->max_touch_width *= EDGE_SWIPE_WIDTH_SCALING_FACTOR;
+		rmi4_data->num_of_fingers++; /* extra finger for edge swipe */
 	}
 #endif
 
@@ -4324,14 +4381,6 @@
 	unsigned char ii;
 
 	dev_info(&rmi4_data->i2c_client->dev, "%s\n", __func__);
-
-/* if firmware is broken, occurs null pinter exception : cause is rmi4_data->f51_handle is NULL */
-#ifdef PROXIMITY
-	if (!rmi4_data->tsp_probe || !rmi4_data->f51_handle) {
-		dev_info(&rmi4_data->i2c_client->dev, "%s: probe is not done\n", __func__);
-		return 0;
-	}
-#endif
 	for (ii = 0; ii < rmi4_data->num_of_fingers; ii++) {
 		input_mt_slot(rmi4_data->input_dev, ii);
 		if (rmi4_data->finger[ii].state) {
@@ -4408,21 +4457,7 @@
 	if (!list_empty(&rmi->support_fn_list)) {
 		list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
 			if (fhandler->fn_number == SYNAPTICS_RMI4_F12) {
-#ifdef GLOVE_MODE
-				retval = synaptics_rmi4_glove_mode_enables(rmi4_data);				
-				if (retval < 0) {
-					dev_err(&rmi4_data->i2c_client->dev,
-							"%s: Failed to glove mode enable, error = %d\n",
-							__func__, retval);
-					goto exit;
-				}
-#else
-				retval = synaptics_rmi4_f12_set_feature(rmi4_data);
-				if (retval < 0) {
-					dev_err(&rmi4_data->i2c_client->dev,
-						"%s: f12 set_feature write fail[%d]\n", __func__, retval);
-				}
-#endif
+				synaptics_rmi4_f12_set_feature(rmi4_data);
 				retval = synaptics_rmi4_f12_set_report(rmi4_data);
 				if (retval < 0) {
 					dev_err(&rmi4_data->i2c_client->dev,
@@ -4507,6 +4542,8 @@
 
 	mutex_lock(&(rmi4_data->rmi4_reset_mutex));
 
+	pr_alert("RESET DEVICE\n");
+	if (!screen_wake_options)
 	disable_irq(rmi4_data->i2c_client->irq);
 
 	synaptics_rmi4_free_fingers(rmi4_data);
@@ -4572,6 +4609,7 @@
 #endif
 
 out:
+	if (!screen_wake_options)
 	enable_irq(rmi4_data->i2c_client->irq);
 	mutex_unlock(&(rmi4_data->rmi4_reset_mutex));
 
@@ -4850,15 +4888,7 @@
 				__func__, rmi4_data->dt_data->external_ldo,
 				enable ? "enabled" : "disabled", (retval < 0) ? "NG" : "OK");
 	}
-#if defined(CONFIG_SEC_RUBENS_PROJECT)
-	mdelay(5);
-	if (rmi4_data->dt_data->external_ldo2 > 0) {
-		retval = gpio_direction_output(rmi4_data->dt_data->external_ldo2, enable);
-		dev_info(dev, "%s: sensor_en[3.3V][%d] is %s[%s]\n",
-				__func__, rmi4_data->dt_data->external_ldo2,
-				enable ? "enabled" : "disabled", (retval < 0) ? "NG" : "OK");
-	}
-#endif
+
 	if (enable) {
 		/* Enable regulators according to the order */
 		for (i = 0; i < rmi4_data->dt_data->num_of_supply; i++) {
@@ -4877,12 +4907,10 @@
 			}
 		}
 
-#if !defined(CONFIG_SEC_GNOTE_PROJECT) && !defined(CONFIG_SEC_CHAGALL_PROJECT) && !defined(CONFIG_SEC_HESTIA_PROJECT) && !defined(CONFIG_SEC_RUBENS_PROJECT)
 		retval = qpnp_pin_config(rmi4_data->dt_data->irq_gpio,
 				&synaptics_int_set[SYNAPTICS_PM_GPIO_STATE_WAKE]);
 		if (retval < 0)
 			dev_info(dev, "%s: wakeup int config return: %d\n", __func__, retval);
-#endif
 
 	} else {
 		/* Disable regulator */
@@ -4902,12 +4930,10 @@
 			}
 		}
 
-#if !defined(CONFIG_SEC_GNOTE_PROJECT) && !defined(CONFIG_SEC_CHAGALL_PROJECT) && !defined(CONFIG_SEC_HESTIA_PROJECT) && !defined(CONFIG_SEC_RUBENS_PROJECT)
 		retval = qpnp_pin_config(rmi4_data->dt_data->irq_gpio,
 				&synaptics_int_set[SYNAPTICS_PM_GPIO_STATE_SLEEP]);
 		if (retval < 0)
 			dev_info(dev, "%s: sleep int config return: %d\n", __func__, retval);
-#endif
 	}
 
 	if (rmi4_data->dt_data->reset_gpio > 0) {
@@ -4919,7 +4945,7 @@
 
 	if (rmi4_data->dt_data->id_gpio > 0) {
 		gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->id_gpio, 0,
-			GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), 1);
+			GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_KT), 1);
 	}
 
 	return;
@@ -4942,14 +4968,6 @@
 					__func__, rmi4_data->dt_data->external_ldo,
 					enable ? "enabled" : "disabled", (retval < 0) ? "NG" : "OK");
 		}
-#if defined(CONFIG_SEC_RUBENS_PROJECT)
-		if (rmi4_data->dt_data->external_ldo2 > 0) {
-			retval = gpio_direction_output(rmi4_data->dt_data->external_ldo2, enable);
-			dev_err(dev, "%s: sensor_en[3.3V][%d] is %s[%s]\n",
-					__func__, rmi4_data->dt_data->external_ldo2,
-					enable ? "enabled" : "disabled", (retval < 0) ? "NG" : "OK");
-		}
-#endif
 	} else {
 		enable = 1;
 		for (i = 0; i < rmi4_data->dt_data->num_of_supply; i++) {
@@ -4967,14 +4985,6 @@
 					__func__, rmi4_data->dt_data->external_ldo,
 					enable ? "enabled" : "disabled", (retval < 0) ? "NG" : "OK");
 		}
-#if defined(CONFIG_SEC_RUBENS_PROJECT)
-		if (rmi4_data->dt_data->external_ldo2 > 0) {
-			retval = gpio_direction_output(rmi4_data->dt_data->external_ldo2, enable);
-			dev_err(dev, "%s: sensor_en[3.3V][%d] is %s[%s]\n",
-					__func__, rmi4_data->dt_data->external_ldo2,
-					enable ? "enabled" : "disabled", (retval < 0) ? "NG" : "OK");
-		}
-#endif
 	}
 }
 
@@ -5046,18 +5056,9 @@
 	} else if (rmi4_data->ic_version == SYNAPTICS_PRODUCT_ID_S5000) {
 		rmi4_data->firmware_name = FW_IMAGE_NAME_NONE;
 	} else if (rmi4_data->ic_version == SYNAPTICS_PRODUCT_ID_S5707) {
-		if (strncmp(rmi4_data->dt_data->project, "Klimt", 5) == 0)
-			rmi4_data->firmware_name = FW_IMAGE_NAME_S5707_KLIMT;
-		else if (strncmp(rmi4_data->dt_data->project, "RUBENS", 6) == 0)
-			rmi4_data->firmware_name = FW_IMAGE_NAME_S5707_RUBENS;
-		else 
 			rmi4_data->firmware_name = FW_IMAGE_NAME_S5707;
 	} else if (rmi4_data->ic_version == SYNAPTICS_PRODUCT_ID_S5708) {
 		rmi4_data->firmware_name = FW_IMAGE_NAME_S5708;
-	} else if (rmi4_data->ic_version == SYNAPTICS_PRODUCT_ID_S5006) {
-		rmi4_data->firmware_name = FW_IMAGE_NAME_S5006;		
-	} else if (rmi4_data->ic_version == SYNAPTICS_PRODUCT_ID_S5710) {
-			rmi4_data->firmware_name = FW_IMAGE_NAME_S5710; 	
 	} else {
 		rmi4_data->firmware_name = FW_IMAGE_NAME_NONE;
 	}
@@ -5129,9 +5130,6 @@
 #endif
 #endif
 
-#if defined(CONFIG_FB_MSM8x26_MDSS_CHECK_LCD_CONNECTION)
-extern int get_lcd_attached(void);
-#endif
 /**
  * synaptics_rmi4_probe()
  *
@@ -5164,12 +5162,7 @@
 				__func__);
 		return -EIO;
 	}
-#if defined(CONFIG_FB_MSM8x26_MDSS_CHECK_LCD_CONNECTION)
-        if (get_lcd_attached() == 0) {
-                dev_err(&client->dev, "%s : get_lcd_attached()=0 \n", __func__);
-                return -EIO;
-        }
-#endif
+
 	if (client->dev.of_node) {
 		dt_data = devm_kzalloc(&client->dev,
 				sizeof(struct synaptics_rmi4_device_tree_data),
@@ -5210,6 +5203,14 @@
 	rmi4_data->i2c_client = client;
 	rmi4_data->current_page = MASK_8BIT;
 
+	retval = pm_runtime_set_active(&rmi4_data->i2c_client->dev);
+	if (retval < 0)
+		pr_alert("KT_PM unable to set runtime pm state\n");
+	pm_runtime_enable(&rmi4_data->i2c_client->dev);
+	device_init_wakeup(&rmi4_data->i2c_client->dev, true);
+	INIT_DELAYED_WORK(&lockout_touch_work, lockout_touch_work_func);
+	wake_lock_init(&wakelock, WAKE_LOCK_SUSPEND, "kt_wake_funcs");
+	
 	rmi4_data->touch_stopped = false;
 	rmi4_data->sensor_sleep = false;
 	rmi4_data->irq_enabled = false;
@@ -5323,8 +5324,11 @@
 			goto err_sysfs;
 		}
 	}
+	wake_funcs_sysfs(rmi4_data, client);
+	wake_funcs_init();
 
 	synaptics_get_firmware_name(rmi4_data);
+
 	retval = synaptics_rmi4_fw_update_on_probe(rmi4_data);
 	if (retval < 0) {
 		dev_err(&client->dev, "%s: Failed to firmware update\n",
@@ -5366,16 +5371,7 @@
 
 	/* for blocking to be excuted open function until probing */
 	rmi4_data->tsp_probe = true;
-#if defined(CONFIG_SEC_HESTIA_PROJECT)
-        retval = synaptics_rmi4_reset_device(rmi4_data);
-        if (retval < 0) {
-                dev_err(&client->dev,
-                                "%s: Failed to issue reset command, error = %d\n",
-                                __func__, retval);
-                return retval;
-        }
-	msleep(SYNAPTICS_HW_RESET_TIME);
-#endif
+
 #ifdef SIDE_TOUCH
 	/* default deepsleep mode */
 	rmi4_data->use_deepsleep = DEFAULT_DISABLE;
@@ -5681,11 +5677,23 @@
 				__func__);
 		goto out;
 	}
+	pr_alert("STOP DEVICE\n");
+	screen_is_off = true;
 
+	if (wake_options_okto_enable())
+	{
+		enable_irq_wake(rmi4_data->i2c_client->irq);
+		screen_wake_options_when_off = screen_wake_options;
+	}
+	else
+	{
 	disable_irq(rmi4_data->i2c_client->irq);
-	synaptics_rmi4_free_fingers(rmi4_data);
 	rmi4_data->touch_stopped = true;
 	synaptics_power_ctrl(rmi4_data, false);
+		screen_wake_options_when_off = 0;
+	}
+	
+	synaptics_rmi4_free_fingers(rmi4_data);
 
 	dev_dbg(&rmi4_data->i2c_client->dev, "%s\n", __func__);
 
@@ -5699,7 +5707,10 @@
 	int retval = 0;
 	mutex_lock(&rmi4_data->rmi4_device_mutex);
 
-	if (!rmi4_data->touch_stopped) {
+	pr_alert("START DEVICE\n");
+	screen_is_off = false;
+		
+	if (!rmi4_data->touch_stopped && !screen_wake_options_when_off) {
 		dev_err(&rmi4_data->i2c_client->dev, "%s already power on\n",
 				__func__);
 		goto out;
@@ -5732,6 +5743,11 @@
 		synaptics_charger_conn(rmi4_data, rmi4_data->ta_status);
 #endif
 
+	if (screen_wake_options_when_off)
+	{
+		disable_irq_wake(rmi4_data->i2c_client->irq);
+	}
+	else
 	enable_irq(rmi4_data->i2c_client->irq);
 
 	dev_dbg(&rmi4_data->i2c_client->dev, "%s\n", __func__);
@@ -5748,9 +5764,10 @@
 	int retval;
 
 	dev_info(&rmi4_data->i2c_client->dev, "%s %s\n", __func__, rmi4_data->use_deepsleep ? "wakeup" : "");
+	pr_alert("INPUT OPEN - %s\n", rmi4_data->use_deepsleep ? "deepsleep" : "");
 
-	gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->scl_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), 1);
-	gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->sda_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), 1);
+	gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->scl_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_KT), 1);
+	gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->sda_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_KT), 1);
 	if (rmi4_data->use_deepsleep) {
 		synaptics_rmi4_sensor_wake(rmi4_data);
 	} else {
@@ -5768,15 +5785,20 @@
 	struct synaptics_rmi4_data *rmi4_data = input_get_drvdata(dev);
 
 	dev_info(&rmi4_data->i2c_client->dev, "%s %s\n", __func__, rmi4_data->use_deepsleep ? "deepsleep" : "");
+	pr_alert("INPUT CLOSE - %s\n", rmi4_data->use_deepsleep ? "deepsleep" : "");
 
 	if (rmi4_data->use_deepsleep) {
 		synaptics_rmi4_sensor_sleep(rmi4_data);
-		gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->scl_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), 1);
-		gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->sda_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), 1);
+		gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->scl_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_KT), 1);
+		gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->sda_gpio, 3, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_KT), 1);
+
 	} else {
 		synaptics_rmi4_stop_device(rmi4_data);
-		gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->scl_gpio, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA), 1);
-		gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->sda_gpio, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA), 1);
+		if (!screen_wake_options || call_in_progress)
+		{
+			gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->scl_gpio, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_KT), 1);
+			gpio_tlmm_config(GPIO_CFG(rmi4_data->dt_data->sda_gpio, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_KT), 1);
+		}
 	}
 }
 #endif
diff -ruBb android_kernel_samsung_msm8974/drivers/input/touchscreen/synaptics/synaptics_i2c_rmi.h tuned-kernel-LOS-s5/drivers/input/touchscreen/synaptics/synaptics_i2c_rmi.h
--- android_kernel_samsung_msm8974/drivers/input/touchscreen/synaptics/synaptics_i2c_rmi.h	2018-03-05 17:54:33.887659921 -0300
+++ tuned-kernel-LOS-s5/drivers/input/touchscreen/synaptics/synaptics_i2c_rmi.h	2017-10-20 13:09:48.359719264 -0300
@@ -467,7 +467,6 @@
  */
 #endif
 
-#define SYN_I2C_RETRY_TIMES 10
 #define MAX_F11_TOUCH_WIDTH 15
 
 #define CHECK_STATUS_TIMEOUT_MS 100
Only in tuned-kernel-LOS-s5/drivers/input/touchscreen: touchboost_switch.c
Only in tuned-kernel-LOS-s5/drivers/leds: boeffla_touchkey_control.c
diff -ruBb android_kernel_samsung_msm8974/drivers/leds/Kconfig tuned-kernel-LOS-s5/drivers/leds/Kconfig
--- android_kernel_samsung_msm8974/drivers/leds/Kconfig	2018-03-05 17:54:33.979660468 -0300
+++ tuned-kernel-LOS-s5/drivers/leds/Kconfig	2017-10-20 13:09:48.575721435 -0300
@@ -633,6 +633,12 @@
 	  KTD2026 is a fully programmable, constant current
 	  three channel LED driver with flexible control interface.
 
+config BOEFFLA_TOUCH_KEY_CONTROL
+	bool "Boeffla touchkey control driver"
+	depends on LEDS_CLASS
+	help
+	  Boeffla touchkey control driver to control touch key backlight
+
 comment "iptables trigger is under Netfilter config (LED target)"
 	depends on LEDS_TRIGGERS
 
diff -ruBb android_kernel_samsung_msm8974/drivers/leds/leds-an30259a.c tuned-kernel-LOS-s5/drivers/leds/leds-an30259a.c
--- android_kernel_samsung_msm8974/drivers/leds/leds-an30259a.c	2018-03-05 17:54:33.979660468 -0300
+++ tuned-kernel-LOS-s5/drivers/leds/leds-an30259a.c	2017-10-20 13:09:48.575721435 -0300
@@ -11,6 +11,27 @@
  * the Free Software Foundation; version 2 of the License.
  *
  */
+
+/* Extended sysfs interface to allow LED fading control + brightness
+ *
+ * andip71, 19.09.2016
+ *
+ * SysFS interface :
+ * -----------------
+ *
+ * /sys/class/sec/led/led_fade (rw)
+ *
+ *   0 : blink (Samsung style)
+ *   1 : fade (CyanogenMod style)
+ *
+ * /sys/class/sec/led/led_intensity (rw)
+ *
+ *        0 : stock CM behaviour
+ *    1- 39 : darker than Samsung stock
+ *       40 : stock Samsung behaviour
+ *   41-255 : brighter than Samsung stock* 
+ */
+
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/module.h>
@@ -80,6 +101,8 @@
 
 #define	MAX_NUM_LEDS	3
 
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
 u8 LED_DYNAMIC_CURRENT = 0x28;
 u8 LED_LOWPOWER_MODE = 0x0;
 
@@ -150,9 +173,13 @@
 
 #ifdef SEC_LED_SPECIFIC
 struct device *led_dev;
+int led_enable_fade = 0; // default is without fading
+u8 led_intensity = 0; // default is CM brightness
 /*path : /sys/class/sec/led/led_pattern*/
 /*path : /sys/class/sec/led/led_blink*/
 /*path : /sys/class/sec/led/led_brightness*/
+/*path : /sys/class/sec/led/led_fade*/
+/*path : /sys/class/sec/led/led_intensity*/
 /*path : /sys/class/leds/led_r/brightness*/
 /*path : /sys/class/leds/led_g/brightness*/
 /*path : /sys/class/leds/led_b/brightness*/
@@ -343,6 +370,9 @@
 static void an30259a_start_led_pattern(int mode)
 {
 	int retval;
+	u8 r_brightness;          /* Yank555.lu : Control LED intensity (normal, bright) */
+	u8 g_brightness;
+	u8 b_brightness;
 	struct i2c_client *client;
 	struct work_struct *reset = 0;
 	client = b_client;
@@ -360,43 +390,74 @@
 	else
 		LED_DYNAMIC_CURRENT = (u8)led_default_cur;
 
+	/* Yank555.lu : Control LED intensity (normal, bright) */
+	if (led_intensity == 0) {
+		r_brightness = LED_DYNAMIC_CURRENT; /* CM stock behaviour */
+		g_brightness = LED_DYNAMIC_CURRENT;
+		b_brightness = LED_DYNAMIC_CURRENT;
+	} else {
+		r_brightness = MIN(led_intensity, LED_MAX_CURRENT);
+		g_brightness = MIN(led_intensity, LED_MAX_CURRENT);
+		b_brightness = MIN(led_intensity, LED_MAX_CURRENT);
+	}
+
 	switch (mode) {
 	/* leds_set_slope_mode(client, LED_SEL, DELAY,  MAX, MID, MIN,
 		SLPTT1, SLPTT2, DT1, DT2, DT3, DT4) */
 	case CHARGING:
 		pr_info("LED Battery Charging Pattern on\n");
-		leds_on(LED_R, true, false,
-					LED_DYNAMIC_CURRENT);
+		leds_on(LED_R, true, false, r_brightness);
 		break;
 
 	case CHARGING_ERR:
 		pr_info("LED Battery Charging error Pattern on\n");
-		leds_on(LED_R, true, true,
-					LED_DYNAMIC_CURRENT);
+		leds_on(LED_R, true, true, r_brightness);
+
+		if (led_enable_fade == 1)
+		{
+			leds_set_slope_mode(client, LED_R,
+					1, 15, 7, 0, 1, 1, 1, 1, 1, 1);
+		}
+		else
+		{
 		leds_set_slope_mode(client, LED_R,
 				1, 15, 15, 0, 1, 1, 0, 0, 0, 0);
+		}
 		break;
 
 	case MISSED_NOTI:
 		pr_info("LED Missed Notifications Pattern on\n");
-		leds_on(LED_B, true, true,
-					LED_DYNAMIC_CURRENT);
+		leds_on(LED_B, true, true, b_brightness);
+		if (led_enable_fade == 1)
+		{
+			leds_set_slope_mode(client, LED_R,
+					1, 15, 7, 0, 1, 10, 1, 1, 1, 1);
+		}
+		else
+		{
 		leds_set_slope_mode(client, LED_B,
 					10, 15, 15, 0, 1, 10, 0, 0, 0, 0);
+		}
 		break;
 
 	case LOW_BATTERY:
 		pr_info("LED Low Battery Pattern on\n");
-		leds_on(LED_R, true, true,
-					LED_DYNAMIC_CURRENT);
+		leds_on(LED_R, true, true, r_brightness);
+		if (led_enable_fade == 1)
+		{
 		leds_set_slope_mode(client, LED_R,
+					1, 15, 7, 0, 1, 10, 1, 1, 1, 1);
+		}
+		else
+		{
+			leds_set_slope_mode(client, LED_B,
 					10, 15, 15, 0, 1, 10, 0, 0, 0, 0);
+		}
 		break;
 
 	case FULLY_CHARGED:
 		pr_info("LED full Charged battery Pattern on\n");
-		leds_on(LED_G, true, false,
-					LED_DYNAMIC_CURRENT);
+		leds_on(LED_G, true, false, g_brightness);
 		break;
 
 	case POWERING:
@@ -438,8 +499,11 @@
 	else if (led == LED_B)
 		LED_DYNAMIC_CURRENT = LED_B_CURRENT;
 
-	/* In user case, LED current is restricted */
+	/* Yank555.lu : Control LED intensity (CM, Samsung, override) */
+	if (led_intensity == 40) /* Samsung stock behaviour */
 	brightness = (brightness * LED_DYNAMIC_CURRENT) / LED_MAX_CURRENT;
+	else if (led_intensity != 0) /* CM stock behaviour */
+		brightness = (brightness * led_intensity) / LED_MAX_CURRENT; /* override, darker or brighter */
 
 	if (delay_on_time > SLPTT_MAX_VALUE)
 		delay_on_time = SLPTT_MAX_VALUE;
@@ -455,12 +519,24 @@
 	} else
 		leds_on(led, true, true, brightness);
 
+	if (led_enable_fade == 1)
+	{
+		leds_set_slope_mode(client, led, 0, 15, 7, 0,
+					(delay_on_time + AN30259A_TIME_UNIT - 1) /
+					AN30259A_TIME_UNIT,
+					(delay_off_time + AN30259A_TIME_UNIT - 1) /
+					AN30259A_TIME_UNIT,
+					1, 1, 1, 1);
+	}
+	else
+	{
 	leds_set_slope_mode(client, led, 0, 15, 15, 0,
 				(delay_on_time + AN30259A_TIME_UNIT - 1) /
 				AN30259A_TIME_UNIT,
 				(delay_off_time + AN30259A_TIME_UNIT - 1) /
 				AN30259A_TIME_UNIT,
 				0, 0, 0, 0);
+	}
 }
 
 static ssize_t store_an30259a_led_lowpower(struct device *dev,
@@ -573,6 +649,63 @@
 }
 
 
+static ssize_t show_an30259a_led_fade(struct device *dev,
+                    struct device_attribute *attr, char *buf)
+{
+	switch(led_enable_fade) {
+		case 0:		return sprintf(buf, "%d - LED fading is disabled\n", led_enable_fade);
+		case 1:		return sprintf(buf, "%d - LED fading is enabled\n", led_enable_fade);
+		default:	return sprintf(buf, "%d - LED fading is in undefined status\n", led_enable_fade);
+	}
+}
+
+static ssize_t store_an30259a_led_fade(struct device *dev,
+					struct device_attribute *devattr,
+					const char *buf, size_t count)
+{
+	int enabled = -1; /* default to not set a new value */
+
+	sscanf(buf, "%d", &enabled);
+
+	switch(enabled) { /* Accept only if 0 or 1 */
+		case 0:
+		case 1:
+			led_enable_fade = enabled;
+		default:
+			return count;
+	}
+}
+
+static ssize_t show_an30259a_led_intensity(struct device *dev,
+                    struct device_attribute *attr, char *buf)
+{
+	switch(led_intensity) {
+		case  0:	return sprintf(buf, "%d - CM stock LED intensity\n", led_intensity);
+		case 40:	return sprintf(buf, "%d - Samsung stock LED intensity\n", led_intensity);
+		default:	if (led_intensity < 40) 
+					return sprintf(buf, "%d - LED intesity darker by %d steps\n", led_intensity, 40-led_intensity);
+				else
+					return sprintf(buf, "%d - LED intesity brighter by %d steps\n", led_intensity, led_intensity-40);
+	}
+}
+
+static ssize_t store_an30259a_led_intensity(struct device *dev,
+					struct device_attribute *devattr,
+					const char *buf, size_t count)
+{
+	int new_intensity = -1; /* default to not set a new value */
+
+	sscanf(buf, "%d", &new_intensity);
+
+	/* Only values between 0 and 255 are accepted */
+	if (new_intensity >= 0 && new_intensity <= 255)
+
+		led_intensity = (u8)new_intensity;
+
+	return count;
+
+}
+
 static ssize_t store_led_r(struct device *dev,
 	struct device_attribute *devattr, const char *buf, size_t count)
 {
@@ -735,6 +868,10 @@
 					store_an30259a_led_pattern);
 static DEVICE_ATTR(led_blink, 0664, NULL, \
 					store_an30259a_led_blink);
+static DEVICE_ATTR(led_fade, 0664, show_an30259a_led_fade, \
+					store_an30259a_led_fade);
+static DEVICE_ATTR(led_intensity, 0664, show_an30259a_led_intensity, \
+					store_an30259a_led_intensity);
 static DEVICE_ATTR(led_br_lev, 0664, NULL, \
 					store_an30259a_led_br_lev);
 static DEVICE_ATTR(led_lowpower, 0664, NULL, \
@@ -760,6 +897,8 @@
 	&dev_attr_led_b.attr,
 	&dev_attr_led_pattern.attr,
 	&dev_attr_led_blink.attr,
+	&dev_attr_led_fade.attr,
+	&dev_attr_led_intensity.attr,
 	&dev_attr_led_br_lev.attr,
 	&dev_attr_led_lowpower.attr,
 	NULL,
@@ -925,6 +1064,8 @@
 #endif
 
 #ifdef SEC_LED_SPECIFIC
+	led_enable_fade = 0;  /* default to stock behaviour = blink */
+	led_intensity = 0;   /* default to CM behaviour */
 	led_dev = device_create(sec_class, NULL, 0, data, "led");
 	if (IS_ERR(led_dev)) {
 		dev_err(&client->dev,
@@ -956,6 +1097,22 @@
 	struct an30259a_data *data = i2c_get_clientdata(client);
 	int i;
 	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	// this is not an ugly hack to shutdown led.
+	data->shadow_reg[AN30259A_REG_LEDON] &= ~(LED_ON << 0);
+	data->shadow_reg[AN30259A_REG_LEDON] &= ~(LED_ON << 1);
+	data->shadow_reg[AN30259A_REG_LEDON] &= ~(LED_ON << 2);
+	data->shadow_reg[AN30259A_REG_LED1CNT2 + 0 * 4] &= ~AN30259A_MASK_DELAY;
+	data->shadow_reg[AN30259A_REG_LED1CNT2 + 1 * 4] &= ~AN30259A_MASK_DELAY;
+	data->shadow_reg[AN30259A_REG_LED1CNT2 + 2 * 4] &= ~AN30259A_MASK_DELAY;
+	data->shadow_reg[AN30259A_REG_LEDON] &= ~(LED_SLOPE_MODE << 0);
+	data->shadow_reg[AN30259A_REG_LEDON] &= ~(LED_SLOPE_MODE << 1);
+	data->shadow_reg[AN30259A_REG_LEDON] &= ~(LED_SLOPE_MODE << 2);
+	data->shadow_reg[AN30259A_REG_LED1CC + 0] = 0;
+	data->shadow_reg[AN30259A_REG_LED1CC + 1] = 0;
+	data->shadow_reg[AN30259A_REG_LED1CC + 2] = 0;
+	msleep(200);
+
 #ifdef SEC_LED_SPECIFIC
 	sysfs_remove_group(&led_dev->kobj, &sec_led_attr_group);
 #endif
diff -ruBb android_kernel_samsung_msm8974/drivers/leds/Makefile tuned-kernel-LOS-s5/drivers/leds/Makefile
--- android_kernel_samsung_msm8974/drivers/leds/Makefile	2018-03-05 17:54:33.979660468 -0300
+++ tuned-kernel-LOS-s5/drivers/leds/Makefile	2017-10-20 13:09:48.575721435 -0300
@@ -74,3 +74,6 @@
 obj-$(CONFIG_LEDS_TRIGGER_GPIO)		+= ledtrig-gpio.o
 obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
 obj-$(CONFIG_LEDS_TRIGGER_SLEEP)	+= ledtrig-sleep.o
+
+# Boeffla touch key control
+obj-$(CONFIG_BOEFFLA_TOUCH_KEY_CONTROL)		+= boeffla_touchkey_control.o
diff -ruBb android_kernel_samsung_msm8974/drivers/media/platform/msm/camera_ll/jpeg_10/msm_jpeg_sync.c tuned-kernel-LOS-s5/drivers/media/platform/msm/camera_ll/jpeg_10/msm_jpeg_sync.c
--- android_kernel_samsung_msm8974/drivers/media/platform/msm/camera_ll/jpeg_10/msm_jpeg_sync.c	2018-03-05 17:54:34.135661395 -0300
+++ tuned-kernel-LOS-s5/drivers/media/platform/msm/camera_ll/jpeg_10/msm_jpeg_sync.c	2017-11-10 10:46:01.909368010 -0300
@@ -84,7 +84,7 @@
 	return 0;
 }
 
-inline int msm_jpeg_q_in_buf(struct msm_jpeg_q *q_p,
+static inline int msm_jpeg_q_in_buf(struct msm_jpeg_q *q_p,
 	struct msm_jpeg_core_buf *buf)
 {
 	struct msm_jpeg_core_buf *buf_p;
@@ -102,7 +102,7 @@
 	return 0;
 }
 
-inline int msm_jpeg_q_wait(struct msm_jpeg_q *q_p)
+static inline int msm_jpeg_q_wait(struct msm_jpeg_q *q_p)
 {
 	int tm = MAX_SCHEDULE_TIMEOUT; /* 500ms */
 	int rc;
diff -ruBb android_kernel_samsung_msm8974/drivers/media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c tuned-kernel-LOS-s5/drivers/media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c
--- android_kernel_samsung_msm8974/drivers/media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c	2018-03-05 17:54:34.151661491 -0300
+++ tuned-kernel-LOS-s5/drivers/media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c	2017-11-27 23:26:11.488382655 -0300
@@ -27,7 +27,7 @@
 #define JPEG_DEC_ID     2
 #define UINT32_MAX (0xFFFFFFFFU)
 
-inline void msm_jpeg_q_init(char const *name, struct msm_jpeg_q *q_p)
+static inline void msm_jpeg_q_init(char const *name, struct msm_jpeg_q *q_p)
 {
 	JPEG_DBG("%s:%d] %s\n", __func__, __LINE__, name);
 	q_p->name = name;
@@ -37,7 +37,7 @@
 	q_p->unblck = 0;
 }
 
-inline void *msm_jpeg_q_out(struct msm_jpeg_q *q_p)
+static inline void *msm_jpeg_q_out(struct msm_jpeg_q *q_p)
 {
 	unsigned long flags;
 	struct msm_jpeg_q_entry *q_entry_p = NULL;
@@ -63,7 +63,7 @@
 	return data;
 }
 
-inline int msm_jpeg_q_in(struct msm_jpeg_q *q_p, void *data)
+static inline int msm_jpeg_q_in(struct msm_jpeg_q *q_p, void *data)
 {
 	unsigned long flags;
 
@@ -85,7 +85,7 @@
 	return 0;
 }
 
-inline int msm_jpeg_q_in_buf(struct msm_jpeg_q *q_p,
+static inline int msm_jpeg_q_in_buf(struct msm_jpeg_q *q_p,
 			     struct msm_jpeg_core_buf *buf)
 {
 	struct msm_jpeg_core_buf *buf_p;
@@ -103,7 +103,7 @@
 	return 0;
 }
 
-inline int msm_jpeg_q_wait(struct msm_jpeg_q *q_p)
+static inline int msm_jpeg_q_wait(struct msm_jpeg_q *q_p)
 {
 	int tm = MAX_SCHEDULE_TIMEOUT; /* 500ms */
 	int rc;
@@ -131,14 +131,14 @@
 	return rc;
 }
 
-inline int msm_jpeg_q_wakeup(struct msm_jpeg_q *q_p)
+static inline int msm_jpeg_q_wakeup(struct msm_jpeg_q *q_p)
 {
 	JPEG_DBG("%s:%d] %s\n", __func__, __LINE__, q_p->name);
 	wake_up(&q_p->wait);
 	return 0;
 }
 
-inline int msm_jpeg_q_unblock(struct msm_jpeg_q *q_p)
+static inline int msm_jpeg_q_unblock(struct msm_jpeg_q *q_p)
 {
 	JPEG_DBG("%s:%d] %s\n", __func__, __LINE__, q_p->name);
 	q_p->unblck = 1;
@@ -146,7 +146,7 @@
 	return 0;
 }
 
-inline void msm_jpeg_outbuf_q_cleanup(struct msm_jpeg_device *pgmn_dev,
+static inline void msm_jpeg_outbuf_q_cleanup(struct msm_jpeg_device *pgmn_dev,
 				      struct msm_jpeg_q *q_p, int domain_num)
 {
 	struct msm_jpeg_core_buf *buf_p;
@@ -164,7 +164,7 @@
 	q_p->unblck = 0;
 }
 
-inline void msm_jpeg_q_cleanup(struct msm_jpeg_q *q_p)
+static inline void msm_jpeg_q_cleanup(struct msm_jpeg_q *q_p)
 {
 	void *data;
 
@@ -239,14 +239,14 @@
 	return 0;
 }
 
-int msm_jpeg_evt_get_unblock(struct msm_jpeg_device *pgmn_dev)
+static inline int msm_jpeg_evt_get_unblock(struct msm_jpeg_device *pgmn_dev)
 {
 	JPEG_DBG("%s:%d] Enter\n", __func__, __LINE__);
 	msm_jpeg_q_unblock(&pgmn_dev->evt_q);
 	return 0;
 }
 
-void msm_jpeg_reset_ack_irq(struct msm_jpeg_device *pgmn_dev)
+static inline void msm_jpeg_reset_ack_irq(struct msm_jpeg_device *pgmn_dev)
 {
 	JPEG_DBG("%s:%d]\n", __func__, __LINE__);
 }
@@ -341,7 +341,7 @@
 	return 0;
 }
 
-int msm_jpeg_output_get_unblock(struct msm_jpeg_device *pgmn_dev)
+static inline int msm_jpeg_output_get_unblock(struct msm_jpeg_device *pgmn_dev)
 {
 	JPEG_DBG("%s:%d] Enter\n", __func__, __LINE__);
 	msm_jpeg_q_unblock(&pgmn_dev->output_rtn_q);
diff -ruBb android_kernel_samsung_msm8974/drivers/media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c tuned-kernel-LOS-s5/drivers/media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c
--- android_kernel_samsung_msm8974/drivers/media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c	2018-03-05 17:54:34.151661491 -0300
+++ tuned-kernel-LOS-s5/drivers/media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c	2017-11-10 10:39:50.330755403 -0300
@@ -155,11 +155,11 @@
 static const struct v4l2_subdev_ops msm_buf_mngr_subdev_ops = {
 	.core	= &msm_buf_mngr_subdev_core_ops,
 };
-
+/*
 static const struct of_device_id msm_buf_mngr_dt_match[] = {
 	{ .compatible = "qcom,msm_buf_mngr" },
 };
-
+*/
 static int __init msm_buf_mngr_init(void)
 {
 	int rc = 0;
diff -ruBb android_kernel_samsung_msm8974/drivers/media/platform/msm/vidc/msm_v4l2_vidc.c tuned-kernel-LOS-s5/drivers/media/platform/msm/vidc/msm_v4l2_vidc.c
--- android_kernel_samsung_msm8974/drivers/media/platform/msm/vidc/msm_v4l2_vidc.c	2018-03-05 17:54:34.199661776 -0300
+++ tuned-kernel-LOS-s5/drivers/media/platform/msm/vidc/msm_v4l2_vidc.c	2017-12-21 20:32:07.175205446 -0300
@@ -258,10 +258,10 @@
 	.vidioc_g_parm = msm_v4l2_g_parm,
 	.vidioc_enum_framesizes = msm_v4l2_enum_framesizes,
 };
-
+/*
 static const struct v4l2_ioctl_ops msm_v4l2_enc_ioctl_ops = {
 };
-
+*/
 static unsigned int msm_v4l2_poll(struct file *filp,
 	struct poll_table_struct *pt)
 {
diff -ruBb android_kernel_samsung_msm8974/drivers/mmc/core/core.c tuned-kernel-LOS-s5/drivers/mmc/core/core.c
--- android_kernel_samsung_msm8974/drivers/mmc/core/core.c	2018-03-05 17:54:34.423663108 -0300
+++ tuned-kernel-LOS-s5/drivers/mmc/core/core.c	2017-10-20 13:09:49.335729074 -0300
@@ -76,7 +76,7 @@
  * performance cost, and for other reasons may not always be desired.
  * So we allow it it to be disabled.
  */
-bool use_spi_crc = 1;
+bool use_spi_crc = 0;
 module_param(use_spi_crc, bool, 0);
 
 /*
diff -ruBb android_kernel_samsung_msm8974/drivers/motor/msm_vibrator.c tuned-kernel-LOS-s5/drivers/motor/msm_vibrator.c
--- android_kernel_samsung_msm8974/drivers/motor/msm_vibrator.c	2018-03-05 17:54:34.439663204 -0300
+++ tuned-kernel-LOS-s5/drivers/motor/msm_vibrator.c	2017-10-30 12:25:34.493758450 -0300
@@ -41,7 +41,7 @@
 
 static void set_vibrator(int motor_en, int on)
 {
-	pr_info("[VIB] %s, on=%d\n",__func__, on);
+//	pr_info("[VIB] %s, on=%d\n",__func__, on);
 
 	gpio_set_value(motor_en, on);
 }
@@ -55,15 +55,15 @@
 	hrtimer_cancel(&vib->vib_timer);
 
 	if (value == 0) {
-		pr_info("[VIB] OFF\n");
+//		pr_info("[VIB] OFF\n");
 		vib->state = 0;
 	}
 	else {
-		pr_info("[VIB] ON, Duration : %d msec\n" , value);
+//		pr_info("[VIB] ON, Duration : %d msec\n" , value);
 		vib->state = 1;
 
 		if (value == 0x7fffffff){
-			pr_info("[VIB] No Use Timer %d \n", value);
+//			pr_info("[VIB] No Use Timer %d \n", value);
 		}
 		else	{
 			value = (value > vib->timeout ?
@@ -114,7 +114,7 @@
 {
 	struct msm_vib *vib = dev_get_drvdata(dev);
 
-	pr_info("[VIB] %s\n",__func__);
+//	pr_info("[VIB] %s\n",__func__);
 
 	hrtimer_cancel(&vib->vib_timer);
 	cancel_work_sync(&vib->work);
diff -ruBb android_kernel_samsung_msm8974/drivers/net/usb/usbnet.c tuned-kernel-LOS-s5/drivers/net/usb/usbnet.c
--- android_kernel_samsung_msm8974/drivers/net/usb/usbnet.c	2018-03-05 17:54:34.743665012 -0300
+++ tuned-kernel-LOS-s5/drivers/net/usb/usbnet.c	2017-11-10 11:49:25.767312237 -0300
@@ -84,7 +84,7 @@
 // randomly generated ethernet address
 static u8	node_id [ETH_ALEN];
 
-static const char driver_name [] = "usbnet";
+//static const char driver_name [] = "usbnet";
 
 struct workqueue_struct	*usbnet_wq;
 
diff -ruBb android_kernel_samsung_msm8974/drivers/net/wireless/bcmdhd/dhd.h tuned-kernel-LOS-s5/drivers/net/wireless/bcmdhd/dhd.h
--- android_kernel_samsung_msm8974/drivers/net/wireless/bcmdhd/dhd.h	2018-03-05 17:54:34.823665487 -0300
+++ tuned-kernel-LOS-s5/drivers/net/wireless/bcmdhd/dhd.h	2017-10-20 14:20:45.406971646 -0300
@@ -854,16 +854,16 @@
 #ifndef CUSTOM_GLOM_SETTING
 #define CUSTOM_GLOM_SETTING 	DEFAULT_GLOM_VALUE
 #endif
-#define WL_AUTO_ROAM_TRIGGER -75
+#define WL_AUTO_ROAM_TRIGGER -60 //was 75
 /* hooks for custom Roaming Trigger  setting via Makefile */
-#define DEFAULT_ROAM_TRIGGER_VALUE -75 /* dBm default roam trigger all band */
+#define DEFAULT_ROAM_TRIGGER_VALUE -60 /* dBm default roam trigger all band */
 #define DEFAULT_ROAM_TRIGGER_SETTING 	-1
 #ifndef CUSTOM_ROAM_TRIGGER_SETTING
 #define CUSTOM_ROAM_TRIGGER_SETTING 	DEFAULT_ROAM_TRIGGER_VALUE
 #endif
 
 /* hooks for custom Roaming Romaing  setting via Makefile */
-#define DEFAULT_ROAM_DELTA_VALUE  10 /* dBm default roam delta all band */
+#define DEFAULT_ROAM_DELTA_VALUE  16 /* dBm default roam delta all band. was 10 */
 #define DEFAULT_ROAM_DELTA_SETTING 	-1
 #ifndef CUSTOM_ROAM_DELTA_SETTING
 #define CUSTOM_ROAM_DELTA_SETTING 	DEFAULT_ROAM_DELTA_VALUE
diff -ruBb android_kernel_samsung_msm8974/drivers/platform/msm/qpnp-power-on.c tuned-kernel-LOS-s5/drivers/platform/msm/qpnp-power-on.c
--- android_kernel_samsung_msm8974/drivers/platform/msm/qpnp-power-on.c	2018-03-05 17:54:35.035666748 -0300
+++ tuned-kernel-LOS-s5/drivers/platform/msm/qpnp-power-on.c	2017-10-20 13:09:50.015735907 -0300
@@ -26,6 +26,7 @@
 #ifdef CONFIG_SEC_DEBUG
 #include <mach/sec_debug.h>
 #endif
+#include <linux/kt_wake_funcs.h>
 
 #define PMIC_VER_8941           0x01
 #define PMIC_VERSION_REG        0x0105
@@ -143,15 +144,16 @@
 	bool use_bark;
 };
 
-struct qpnp_pon {
-	struct spmi_device *spmi;
-	struct input_dev *pon_input;
-	struct qpnp_pon_config *pon_cfg;
-	int num_pon_config;
-	int powerkey_state;
-	u16 base;
-	struct delayed_work bark_work;
-};
+// AP: this has been moved to qpnp-power-on.h
+//struct qpnp_pon {
+//	struct spmi_device *spmi;
+//	struct input_dev *pon_input;
+//	struct qpnp_pon_config *pon_cfg;
+//	int num_pon_config;
+//	int powerkey_state;
+//	u16 base;
+//	struct delayed_work bark_work;
+//};
 
 static struct qpnp_pon *sys_reset_dev;
 #ifdef CONFIG_SEC_PM_DEBUG
@@ -195,6 +197,8 @@
 	[15] = "Triggered from STAGE3 (Stage 3 reset)",
 };
 
+extern void screenwake_setdev(struct qpnp_pon * pon);
+
 static int
 qpnp_pon_masked_write(struct qpnp_pon *pon, u16 addr, u8 mask, u8 val)
 {
@@ -1604,6 +1608,7 @@
 			dev_attr_sec_powerkey_pressed.attr.name);
 	}
 	dev_set_drvdata(sec_powerkey, pon);
+	screenwake_setdev(pon);
 
 	return rc;
 }
diff -ruBb android_kernel_samsung_msm8974/drivers/regulator/max77804k-regulator.c tuned-kernel-LOS-s5/drivers/regulator/max77804k-regulator.c
--- android_kernel_samsung_msm8974/drivers/regulator/max77804k-regulator.c	2018-03-05 17:54:35.075666986 -0300
+++ tuned-kernel-LOS-s5/drivers/regulator/max77804k-regulator.c	2017-11-10 10:40:07.846881332 -0300
@@ -52,11 +52,11 @@
 static const struct voltage_map_desc charger_current_map_desc = {
 	.min = 60, .max = 2580, .step = 20, .n_bits = 7,
 };
-
+/*
 static const struct voltage_map_desc topoff_current_map_desc = {
 	.min = 50, .max = 200, .step = 10, .n_bits = 4,
 };
-
+*/
 static const struct voltage_map_desc *reg_voltage_map[] = {
 	[MAX77804K_ESAFEOUT1] = NULL,
 	[MAX77804K_ESAFEOUT2] = NULL,
diff -ruBb android_kernel_samsung_msm8974/drivers/sensorhub/atmel/ssp.h tuned-kernel-LOS-s5/drivers/sensorhub/atmel/ssp.h
--- android_kernel_samsung_msm8974/drivers/sensorhub/atmel/ssp.h	2018-03-05 17:54:35.331668509 -0300
+++ tuned-kernel-LOS-s5/drivers/sensorhub/atmel/ssp.h	2017-11-21 15:50:28.538854700 -0300
@@ -45,7 +45,7 @@
 #include "ssp_sensorhub.h"
 #endif
 
-#define SSP_DBG		1
+#define SSP_DBG		0
 
 #define SUCCESS		1
 #define FAIL		0
diff -ruBb android_kernel_samsung_msm8974/drivers/sensorhub/stm/factory/prox_max88920.c tuned-kernel-LOS-s5/drivers/sensorhub/stm/factory/prox_max88920.c
--- android_kernel_samsung_msm8974/drivers/sensorhub/stm/factory/prox_max88920.c	2018-03-05 17:54:35.331668509 -0300
+++ tuned-kernel-LOS-s5/drivers/sensorhub/stm/factory/prox_max88920.c	2017-10-20 13:09:50.423740006 -0300
@@ -13,6 +13,7 @@
  *
  */
 #include "../ssp.h"
+#include <linux/kt_wake_funcs.h>
 
 #ifdef CONFIG_SENSORS_SSP_TMG399X
 #define	VENDOR		"AMS"
@@ -498,6 +499,7 @@
 {
 	sensors_register(data->prox_device, data,
 		prox_attrs, "proximity_sensor");
+	main_prox_data = data;
 }
 
 void remove_prox_factorytest(struct ssp_data *data)
diff -ruBb android_kernel_samsung_msm8974/drivers/sensorhub/stm/ssp_i2c.c tuned-kernel-LOS-s5/drivers/sensorhub/stm/ssp_i2c.c
--- android_kernel_samsung_msm8974/drivers/sensorhub/stm/ssp_i2c.c	2018-03-05 17:54:35.335668533 -0300
+++ tuned-kernel-LOS-s5/drivers/sensorhub/stm/ssp_i2c.c	2017-10-20 13:09:50.423740006 -0300
@@ -13,6 +13,7 @@
  *
  */
 #include "ssp.h"
+#include <linux/kt_wake_funcs.h>
 
 #define LIMIT_DELAY_CNT		200
 #define RECEIVEBUFFERSIZE	12
@@ -279,6 +280,13 @@
 		return FAIL;
 	}
 
+	// On Call Hook
+	if (uInst == ADD_SENSOR && uSensorType == PROXIMITY_SENSOR)
+	{
+		wake_funcs_set_prox(false);
+		set_call_in_progress(true);
+	}
+
 	switch (uInst) {
 	case REMOVE_SENSOR:
 		command = MSG2SSP_INST_BYPASS_SENSOR_REMOVE;
@@ -329,6 +337,13 @@
 
 	iRet = ssp_spi_async(data, msg);
 
+	// Call ended hook
+	if (uInst == REMOVE_SENSOR && uSensorType == PROXIMITY_SENSOR)
+	{
+		wake_funcs_set_prox(true);
+		set_call_in_progress(false);
+	}
+
 	if (iRet != SUCCESS) {
 		pr_err("[SSP]: %s - Instruction CMD Fail %d\n", __func__, iRet);
 		return ERROR;
diff -ruBb android_kernel_samsung_msm8974/drivers/staging/android/lowmemorykiller.c tuned-kernel-LOS-s5/drivers/staging/android/lowmemorykiller.c
--- android_kernel_samsung_msm8974/drivers/staging/android/lowmemorykiller.c	2018-03-05 17:54:35.371668747 -0300
+++ tuned-kernel-LOS-s5/drivers/staging/android/lowmemorykiller.c	2018-02-28 11:27:01.441101162 -0300
@@ -33,33 +33,20 @@
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/module.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/oom.h>
 #include <linux/sched.h>
 #include <linux/swap.h>
 #include <linux/rcupdate.h>
+#include <linux/profile.h>
 #include <linux/notifier.h>
-#include <linux/mutex.h>
 #include <linux/delay.h>
-#include <linux/swap.h>
-#include <linux/fs.h>
-#include <linux/cpuset.h>
-#include <linux/show_mem_notifier.h>
-#include <linux/vmpressure.h>
-#include <linux/zcache.h>
-
-#define CREATE_TRACE_POINTS
-#include <trace/events/almk.h>
-
-#ifdef CONFIG_HIGHMEM
-#define _ZONE ZONE_HIGHMEM
-#else
-#define _ZONE ZONE_NORMAL
-#endif
 
 static uint32_t lowmem_debug_level = 1;
-static int lowmem_adj[6] = {
+static short lowmem_adj[6] = {
 	0,
 	1,
 	6,
@@ -73,9 +60,7 @@
 	16 * 1024,	/* 64MB */
 };
 static int lowmem_minfree_size = 4;
-static int lmk_fast_run = 1;
-
-static unsigned long lowmem_deathpending_timeout;
+static uint32_t lowmem_lmkcount = 0;
 
 #define lowmem_print(level, x...)			\
 	do {						\
@@ -83,499 +68,171 @@
 			pr_info(x);			\
 	} while (0)
 
-static atomic_t shift_adj = ATOMIC_INIT(0);
-static short adj_max_shift = 353;
-
-/* User knob to enable/disable adaptive lmk feature */
-static int enable_adaptive_lmk;
-module_param_named(enable_adaptive_lmk, enable_adaptive_lmk, int,
-	S_IRUGO | S_IWUSR);
-
-/*
- * This parameter controls the behaviour of LMK when vmpressure is in
- * the range of 90-94. Adaptive lmk triggers based on number of file
- * pages wrt vmpressure_file_min, when vmpressure is in the range of
- * 90-94. Usually this is a pseudo minfree value, higher than the
- * highest configured value in minfree array.
- */
-static int vmpressure_file_min;
-module_param_named(vmpressure_file_min, vmpressure_file_min, int,
-	S_IRUGO | S_IWUSR);
-
-enum {
-	VMPRESSURE_NO_ADJUST = 0,
-	VMPRESSURE_ADJUST_ENCROACH,
-	VMPRESSURE_ADJUST_NORMAL,
-};
-
-int adjust_minadj(short *min_score_adj)
-{
-	int ret = VMPRESSURE_NO_ADJUST;
-
-	if (!enable_adaptive_lmk)
-		return 0;
-
-	if (atomic_read(&shift_adj) &&
-		(*min_score_adj > adj_max_shift)) {
-		if (*min_score_adj == OOM_SCORE_ADJ_MAX + 1)
-			ret = VMPRESSURE_ADJUST_ENCROACH;
-		else
-			ret = VMPRESSURE_ADJUST_NORMAL;
-		*min_score_adj = adj_max_shift;
-	}
-	atomic_set(&shift_adj, 0);
-
-	return ret;
-}
-
-static int lmk_vmpressure_notifier(struct notifier_block *nb,
-			unsigned long action, void *data)
-{
-	int other_free = 0, other_file = 0;
-	unsigned long pressure = action;
-	int array_size = ARRAY_SIZE(lowmem_adj);
-
-	if (!enable_adaptive_lmk)
-		return 0;
-
-	if (pressure >= 95) {
-		other_file = global_page_state(NR_FILE_PAGES) -
-			global_page_state(NR_SHMEM) -
-			global_page_state(NR_UNEVICTABLE) -
-			total_swapcache_pages();
-		other_free = global_page_state(NR_FREE_PAGES);
-
-		atomic_set(&shift_adj, 1);
-		trace_almk_vmpressure(pressure, other_free, other_file);
-	} else if (pressure >= 90) {
-		if (lowmem_adj_size < array_size)
-			array_size = lowmem_adj_size;
-		if (lowmem_minfree_size < array_size)
-			array_size = lowmem_minfree_size;
-
-		other_file = global_page_state(NR_FILE_PAGES) -
-			global_page_state(NR_SHMEM) -
-			global_page_state(NR_UNEVICTABLE) -
-			total_swapcache_pages();
-
-		other_free = global_page_state(NR_FREE_PAGES);
-
-		if ((other_free < lowmem_minfree[array_size - 1]) &&
-			(other_file < vmpressure_file_min)) {
-				atomic_set(&shift_adj, 1);
-				trace_almk_vmpressure(pressure, other_free,
-					other_file);
-		}
-	} else if (atomic_read(&shift_adj)) {
-		/*
-		 * shift_adj would have been set by a previous invocation
-		 * of notifier, which is not followed by a lowmem_shrink yet.
-		 * Since vmpressure has improved, reset shift_adj to avoid
-		 * false adaptive LMK trigger.
-		 */
-		trace_almk_vmpressure(pressure, other_free, other_file);
-		atomic_set(&shift_adj, 0);
-	}
-
-	return 0;
-}
-
-static struct notifier_block lmk_vmpr_nb = {
-	.notifier_call = lmk_vmpressure_notifier,
-};
-
-static int test_task_flag(struct task_struct *p, int flag)
-{
-	struct task_struct *t;
-
-	for_each_thread(p, t) {
-		task_lock(t);
-		if (test_tsk_thread_flag(t, flag)) {
-			task_unlock(t);
-			return 1;
-		}
-		task_unlock(t);
-	}
-
-	return 0;
-}
-
-static DEFINE_MUTEX(scan_mutex);
-
-int can_use_cma_pages(gfp_t gfp_mask)
-{
-	int can_use = 0;
-	int mtype = allocflags_to_migratetype(gfp_mask);
-	int i = 0;
-	int *mtype_fallbacks = get_migratetype_fallbacks(mtype);
-
-	if (is_migrate_cma(mtype)) {
-		can_use = 1;
-	} else {
-		for (i = 0;; i++) {
-			int fallbacktype = mtype_fallbacks[i];
-
-			if (is_migrate_cma(fallbacktype)) {
-				can_use = 1;
-				break;
-			}
-
-			if (fallbacktype == MIGRATE_RESERVE)
-				break;
-		}
-	}
-	return can_use;
-}
-
-void tune_lmk_zone_param(struct zonelist *zonelist, int classzone_idx,
-					int *other_free, int *other_file,
-					int use_cma_pages)
-{
-	struct zone *zone;
-	struct zoneref *zoneref;
-	int zone_idx;
-
-	for_each_zone_zonelist(zone, zoneref, zonelist, MAX_NR_ZONES) {
-		zone_idx = zonelist_zone_idx(zoneref);
-		if (zone_idx == ZONE_MOVABLE) {
-			if (!use_cma_pages && other_free)
-				*other_free -=
-				    zone_page_state(zone, NR_FREE_CMA_PAGES);
-			continue;
-		}
-
-		if (zone_idx > classzone_idx) {
-			if (other_free != NULL)
-				*other_free -= zone_page_state(zone,
-							       NR_FREE_PAGES);
-			if (other_file != NULL)
-				*other_file -= zone_page_state(zone,
-							       NR_FILE_PAGES)
-					- zone_page_state(zone, NR_SHMEM)
-					- zone_page_state(zone, NR_SWAPCACHE);
-		} else if (zone_idx < classzone_idx) {
-			if (zone_watermark_ok(zone, 0, 0, classzone_idx, 0) &&
-			    other_free) {
-				if (!use_cma_pages) {
-					*other_free -= min(
-					  zone->lowmem_reserve[classzone_idx] +
-					  zone_page_state(
-					    zone, NR_FREE_CMA_PAGES),
-					  zone_page_state(
-					    zone, NR_FREE_PAGES));
-				} else {
-					*other_free -=
-					  zone->lowmem_reserve[classzone_idx];
-				}
-			} else {
-				if (other_free)
-					*other_free -=
-					  zone_page_state(zone, NR_FREE_PAGES);
-			}
-		}
-	}
-}
-
-#ifdef CONFIG_HIGHMEM
-void adjust_gfp_mask(gfp_t *gfp_mask)
-{
-	struct zone *preferred_zone;
-	struct zonelist *zonelist;
-	enum zone_type high_zoneidx;
-
-	if (current_is_kswapd()) {
-		zonelist = node_zonelist(0, *gfp_mask);
-		high_zoneidx = gfp_zone(*gfp_mask);
-		first_zones_zonelist(zonelist, high_zoneidx, NULL,
-				&preferred_zone);
-
-		if (high_zoneidx == ZONE_NORMAL) {
-			if (zone_watermark_ok_safe(preferred_zone, 0,
-					high_wmark_pages(preferred_zone), 0,
-					0))
-				*gfp_mask |= __GFP_HIGHMEM;
-		} else if (high_zoneidx == ZONE_HIGHMEM) {
-			*gfp_mask |= __GFP_HIGHMEM;
-		}
-	}
-}
-#else
-void adjust_gfp_mask(gfp_t *unused)
-{
-}
+#if defined(CONFIG_ZSWAP)
+extern u64 zswap_pool_pages;
+extern atomic_t zswap_stored_pages;
 #endif
-
-void tune_lmk_param(int *other_free, int *other_file, struct shrink_control *sc)
+extern bool displayon;
+static int lowmem_shrink(void)
 {
-	gfp_t gfp_mask;
-	struct zone *preferred_zone;
-	struct zonelist *zonelist;
-	enum zone_type high_zoneidx, classzone_idx;
-	unsigned long balance_gap;
-	int use_cma_pages;
-
-	gfp_mask = sc->gfp_mask;
-	adjust_gfp_mask(&gfp_mask);
-
-	zonelist = node_zonelist(0, gfp_mask);
-	high_zoneidx = gfp_zone(gfp_mask);
-	first_zones_zonelist(zonelist, high_zoneidx, NULL, &preferred_zone);
-	classzone_idx = zone_idx(preferred_zone);
-	use_cma_pages = can_use_cma_pages(gfp_mask);
-
-	balance_gap = min(low_wmark_pages(preferred_zone),
-			  (preferred_zone->present_pages +
-			   KSWAPD_ZONE_BALANCE_GAP_RATIO-1) /
-			   KSWAPD_ZONE_BALANCE_GAP_RATIO);
-
-	if (likely(current_is_kswapd() && zone_watermark_ok(preferred_zone, 0,
-			  high_wmark_pages(preferred_zone) + SWAP_CLUSTER_MAX +
-			  balance_gap, 0, 0))) {
-		if (lmk_fast_run)
-			tune_lmk_zone_param(zonelist, classzone_idx, other_free,
-				       other_file, use_cma_pages);
-		else
-			tune_lmk_zone_param(zonelist, classzone_idx, other_free,
-				       NULL, use_cma_pages);
-
-		if (zone_watermark_ok(preferred_zone, 0, 0, _ZONE, 0)) {
-			if (!use_cma_pages) {
-				*other_free -= min(
-				  preferred_zone->lowmem_reserve[_ZONE]
-				  + zone_page_state(
-				    preferred_zone, NR_FREE_CMA_PAGES),
-				  zone_page_state(
-				    preferred_zone, NR_FREE_PAGES));
-			} else {
-				*other_free -=
-				  preferred_zone->lowmem_reserve[_ZONE];
-			}
-		} else {
-			*other_free -= zone_page_state(preferred_zone,
-						      NR_FREE_PAGES);
-		}
-
-		lowmem_print(4, "lowmem_shrink of kswapd tunning for highmem "
-			     "ofree %d, %d\n", *other_free, *other_file);
-	} else {
-		tune_lmk_zone_param(zonelist, classzone_idx, other_free,
-			       other_file, use_cma_pages);
-
-		if (!use_cma_pages) {
-			*other_free -=
-			  zone_page_state(preferred_zone, NR_FREE_CMA_PAGES);
-		}
-
-		lowmem_print(4, "lowmem_shrink tunning for others ofree %d, "
-			     "%d\n", *other_free, *other_file);
-	}
-}
-
-static int lowmem_shrink(struct shrinker *s, struct shrink_control *sc)
-{
-	struct task_struct *tsk;
+	struct task_struct *tsk, *tokill[16], *p;
 	struct task_struct *selected = NULL;
-	int rem = 0;
-	int tasksize;
-	int i;
-	int ret = 0;
+	unsigned long rem = 0;
+	int i, selected_oom_score;
 	short min_score_adj = OOM_SCORE_ADJ_MAX + 1;
-	int minfree = 0;
-	int selected_tasksize = 0;
-	int selected_oom_score_adj;
+	int minfree = 0, oom_score, tki;
 	int array_size = ARRAY_SIZE(lowmem_adj);
-	int other_free;
-	int other_file;
-	unsigned long nr_to_scan = sc->nr_to_scan;
-
-	if (nr_to_scan > 0) {
-		if (mutex_lock_interruptible(&scan_mutex) < 0)
-			return 0;
-	}
-
-	other_free = global_page_state(NR_FREE_PAGES) - totalreserve_pages;
-
-	if (global_page_state(NR_SHMEM) + total_swapcache_pages() <
-		global_page_state(NR_FILE_PAGES) + zcache_pages())
-		other_file = global_page_state(NR_FILE_PAGES) + zcache_pages() -
+	int other_free = global_page_state(NR_FREE_PAGES) - totalreserve_pages;
+	int other_file = global_page_state(NR_FILE_PAGES) -
 						global_page_state(NR_SHMEM) -
-						global_page_state(NR_UNEVICTABLE) -
 						total_swapcache_pages();
-	else
-		other_file = 0;
 
-	tune_lmk_param(&other_free, &other_file, sc);
+        long cache_size, cache_limit, free;
+	static unsigned int expire=0, count=0;
+
+	if (other_free < 0) other_free = 0;
 
 	if (lowmem_adj_size < array_size)
 		array_size = lowmem_adj_size;
 	if (lowmem_minfree_size < array_size)
 		array_size = lowmem_minfree_size;
-	for (i = 0; i < array_size; i++) {
+	for (i = array_size-1; i >=0; i--) {
 		minfree = lowmem_minfree[i];
 		if (other_free < minfree && other_file < minfree) {
 			min_score_adj = lowmem_adj[i];
 			break;
 		}
 	}
-	if (nr_to_scan > 0) {
-		ret = adjust_minadj(&min_score_adj);
-		lowmem_print(3, "lowmem_shrink %lu, %x, ofree %d %d, ma %hd\n",
-				nr_to_scan, sc->gfp_mask, other_free,
-				other_file, min_score_adj);
-	}
-
-	rem = global_page_state(NR_ACTIVE_ANON) +
-		global_page_state(NR_ACTIVE_FILE) +
-		global_page_state(NR_INACTIVE_ANON) +
-		global_page_state(NR_INACTIVE_FILE);
-	if (nr_to_scan <= 0 || min_score_adj == OOM_SCORE_ADJ_MAX + 1) {
-		lowmem_print(5, "lowmem_shrink %lu, %x, return %d\n",
-			     nr_to_scan, sc->gfp_mask, rem);
-
-		if (nr_to_scan > 0)
-			mutex_unlock(&scan_mutex);
-
-		if ((min_score_adj == OOM_SCORE_ADJ_MAX + 1) &&
-			(nr_to_scan > 0))
-			trace_almk_shrink(0, ret, other_free, other_file, 0);
 
-		return rem;
-	}
-	selected_oom_score_adj = min_score_adj;
+	if (++expire > 10) { expire=0; count=0; }
 
+	if (i < 0) {
+		lowmem_print(3, "i < 0. min_score_adj = %d. We still have %u pages in cache", min_score_adj, other_file);
+		return 0;
+	}
+	else {
+           free = other_free * (long)(PAGE_SIZE / 1024);
+           cache_size = other_file * (long)(PAGE_SIZE / 1024);
+	   lowmem_print(2, "############### LOW MEMORY KILLER: %ldKb less than hiddenapps minimum: %ldKb. And free: %ldKb",
+			cache_size, minfree*(long)(PAGE_SIZE / 1024), free);
+	}
 	rcu_read_lock();
+
+	restart:
+	tki = -1;
+	selected = NULL;
+	selected_oom_score = min_score_adj;
+
+	cache_limit = minfree * (long)(PAGE_SIZE / 1024);
+
 	for_each_process(tsk) {
-		struct task_struct *p;
-		int oom_score_adj;
+		oom_score = 0;
 
 		if (tsk->flags & PF_KTHREAD)
 			continue;
 
-		/* if task no longer has any memory ignore it */
-		if (test_task_flag(tsk, TIF_MM_RELEASED))
+		if (same_thread_group(tsk, current))
 			continue;
 
-		if (time_before_eq(jiffies, lowmem_deathpending_timeout)) {
-			if (test_task_flag(tsk, TIF_MEMDIE)) {
-				rcu_read_unlock();
-				/* give the system time to free up the memory */
-				msleep_interruptible(20);
-				mutex_unlock(&scan_mutex);
-				return 0;
-			}
-		}
-
 		p = find_lock_task_mm(tsk);
 		if (!p)
 			continue;
 
-		oom_score_adj = p->signal->oom_score_adj;
-		if (oom_score_adj < min_score_adj) {
+		oom_score = p->signal->oom_score_adj;
 			task_unlock(p);
+
+                if (oom_score < min_score_adj) {
+                                lowmem_print(5,"%s score: %d < min_score_adj: %d", p->comm, oom_score, min_score_adj);
 			continue;
 		}
-		tasksize = get_mm_rss(p->mm);
-		task_unlock(p);
-		if (tasksize <= 0)
-			continue;
+
+
 		if (selected) {
-			if (oom_score_adj < selected_oom_score_adj)
-				continue;
-			if (oom_score_adj == selected_oom_score_adj &&
-			    tasksize <= selected_tasksize)
+			if (oom_score < selected_oom_score) {
+				lowmem_print(5,"%s score (%d) is lower than %s's (%d)", p->comm, oom_score, selected->comm, selected_oom_score);
 				continue;
 		}
+			else if ((oom_score == selected_oom_score) && (tki < 16)) {
+					tki++;
+					lowmem_print(4,"### adding %s with score %d to pos %d of tokill", p->comm, oom_score, tki);
+					tokill[tki] = p;
+			}
+			else if (oom_score > selected_oom_score) {
+					tki=0;
+					lowmem_print(4,"### oops, adding %s with score %d to pos %d of tokill", p->comm, oom_score, tki);
+					tokill[tki] = p;
+			}
+		}
 		selected = p;
-		selected_tasksize = tasksize;
-		selected_oom_score_adj = oom_score_adj;
-		lowmem_print(3, "select '%s' (%d), adj %hd, size %d, to kill\n",
-			     p->comm, p->pid, oom_score_adj, tasksize);
+		selected_oom_score = oom_score;
+
 	}
-	if (selected) {
-		lowmem_print(1, "Killing '%s' (%d), adj %d,\n" \
-				"   to free %ldkB on behalf of '%s' (%d) because\n"
+
+	while (tki >= 0) {
+		set_tsk_thread_flag(tokill[tki], TIF_MEMDIE);
+                send_sig(SIGKILL, tokill[tki], 0);
+
+                lowmem_print(1, "Killing '%s' (%d) on behalf of '%s' (%d) because\n" \
 				"   cache %ldkB is below limit %ldkB for oom_score_adj %hd\n" \
-				"   Free memory is %ldkB above reserved.\n" \
-				"   Free CMA is %ldkB\n" \
-				"   Total reserve is %ldkB\n" \
-				"   Total free pages is %ldkB\n" \
-				"   Total file cache is %ldkB\n" \
-				"   Total zcache is %ldkB\n" \
-				"   Slab Reclaimable is %ldkB\n" \
-				"   Slab UnReclaimable is %ldkB\n" \
-				"   Total Slab is %ldkB\n" \
-				"   GFP mask is 0x%x\n",
-				selected->comm, selected->pid,
-				selected_oom_score_adj,
-				selected_tasksize * (long)(PAGE_SIZE / 1024),
-				current->comm, current->pid,
-				other_file * (long)(PAGE_SIZE / 1024),
-				minfree * (long)(PAGE_SIZE / 1024),
-				min_score_adj,
-				other_free * (long)(PAGE_SIZE / 1024),
-				global_page_state(NR_FREE_CMA_PAGES) *
-				   (long)(PAGE_SIZE / 1024),
-				totalreserve_pages * (long)(PAGE_SIZE / 1024),
-				global_page_state(NR_FREE_PAGES) *
-				   (long)(PAGE_SIZE / 1024),
-				global_page_state(NR_FILE_PAGES) *
-				   (long)(PAGE_SIZE / 1024),
-				(long)zcache_pages() * (long)(PAGE_SIZE / 1024),
-				global_page_state(NR_SLAB_RECLAIMABLE) *
-				   (long)(PAGE_SIZE / 1024),
-				global_page_state(NR_SLAB_UNRECLAIMABLE) *
-				   (long)(PAGE_SIZE / 1024),
-				global_page_state(NR_SLAB_RECLAIMABLE) *
-				   (long)(PAGE_SIZE / 1024) +
-				global_page_state(NR_SLAB_UNRECLAIMABLE) *
-				   (long)(PAGE_SIZE / 1024),
-				sc->gfp_mask);
-
-		if (lowmem_debug_level >= 2 && selected_oom_score_adj == 0) {
-			show_mem(SHOW_MEM_FILTER_NODES);
-			dump_tasks(NULL, NULL);
-			show_mem_call_notifiers();
-		}
-
-		lowmem_deathpending_timeout = jiffies + HZ;
-		set_tsk_thread_flag(selected, TIF_MEMDIE);
-		send_sig(SIGKILL, selected, 0);
-		rem -= selected_tasksize;
-		rcu_read_unlock();
-		/* give the system time to free up the memory */
-		msleep_interruptible(20);
-		trace_almk_shrink(selected_tasksize, ret,
-			other_free, other_file, selected_oom_score_adj);
-	} else {
-		trace_almk_shrink(1, ret, other_free, other_file, 0);
-		rcu_read_unlock();
+                                "   Free memory is %ldkB above reserved\n",
+                             tokill[tki]->comm, tokill[tki]->pid,
+                             current->comm, current->pid, cache_size, cache_limit, min_score_adj, free);
+                rem++;
+                lowmem_lmkcount++;
+		tki--;
 	}
 
-	lowmem_print(4, "lowmem_shrink %lu, %x, return %d\n",
-		     nr_to_scan, sc->gfp_mask, rem);
-	mutex_unlock(&scan_mutex);
-	return rem;
+        if (!rem && i>0) {
+           min_score_adj = lowmem_adj[--i];
+	   minfree = lowmem_minfree[i];
+	   cache_limit = minfree * (long)(PAGE_SIZE / 1024);
+           lowmem_print(2, "Nothing to kill? min_score_adj decreased to: %d", min_score_adj);
+	   goto restart;
+        }
+
+	if (rem) {
+	   if (++count > 4) {
+		lowmem_print(1, "I think you have too many apps running in background. Please try to disable their auto-start on boot!");
+		min_score_adj = lowmem_adj[3];
+		minfree = lowmem_minfree[3];
+		count=0;
+		goto restart;
+	   }
+	   lowmem_print(1, "Killed %d processes", rem);
+	}
+
+	rcu_read_unlock();
+	return 0;
 }
 
-static struct shrinker lowmem_shrinker = {
-	.shrink = lowmem_shrink,
-	.seeks = DEFAULT_SEEKS * 16
-};
+static void timelylmk(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+
+	lowmem_shrink();
+
+	if (displayon)
+		queue_delayed_work(system_nrt_wq, dwork, 400);
+	else
+		queue_delayed_work(system_nrt_wq, dwork, 1600);
+}
 
 static int __init lowmem_init(void)
 {
-	register_shrinker(&lowmem_shrinker);
-	vmpressure_notifier_register(&lmk_vmpr_nb);
+	struct delayed_work *dwork;
+	dwork = kmalloc(sizeof(*dwork), GFP_KERNEL);
+	INIT_DELAYED_WORK_DEFERRABLE(dwork, timelylmk);
+	queue_delayed_work(system_nrt_wq, dwork, 20000);
+
 	return 0;
 }
 
 static void __exit lowmem_exit(void)
 {
-	unregister_shrinker(&lowmem_shrinker);
 }
 
 #ifdef CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES
-static int lowmem_oom_adj_to_oom_score_adj(int oom_adj)
+static short lowmem_oom_adj_to_oom_score_adj(short oom_adj)
 {
 	if (oom_adj == OOM_ADJUST_MAX)
 		return OOM_SCORE_ADJ_MAX;
@@ -586,8 +243,8 @@
 static void lowmem_autodetect_oom_adj_values(void)
 {
 	int i;
-	int oom_adj;
-	int oom_score_adj;
+	short oom_adj;
+	short oom_score_adj;
 	int array_size = ARRAY_SIZE(lowmem_adj);
 
 	if (lowmem_adj_size < array_size)
@@ -645,27 +302,29 @@
 static const struct kparam_array __param_arr_adj = {
 	.max = ARRAY_SIZE(lowmem_adj),
 	.num = &lowmem_adj_size,
-	.ops = &param_ops_int,
+	.ops = &param_ops_short,
 	.elemsize = sizeof(lowmem_adj[0]),
 	.elem = lowmem_adj,
 };
 #endif
 
-module_param_named(cost, lowmem_shrinker.seeks, int, S_IRUGO | S_IWUSR);
+/*
+ * not really modular, but the easiest way to keep compat with existing
+ * bootargs behaviour is to continue using module_param here.
+ */
 #ifdef CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES
-__module_param_call(MODULE_PARAM_PREFIX, adj,
-		    &lowmem_adj_array_ops,
+module_param_cb(adj, &lowmem_adj_array_ops,
 		    .arr = &__param_arr_adj,
-		    S_IRUGO | S_IWUSR, -1);
-__MODULE_PARM_TYPE(adj, "array of int");
+		S_IRUGO | S_IWUSR);
+__MODULE_PARM_TYPE(adj, "array of short");
 #else
-module_param_array_named(adj, lowmem_adj, int, &lowmem_adj_size,
+module_param_array_named(adj, lowmem_adj, short, &lowmem_adj_size,
 			 S_IRUGO | S_IWUSR);
 #endif
 module_param_array_named(minfree, lowmem_minfree, uint, &lowmem_minfree_size,
 			 S_IRUGO | S_IWUSR);
 module_param_named(debug_level, lowmem_debug_level, uint, S_IRUGO | S_IWUSR);
-module_param_named(lmk_fast_run, lmk_fast_run, int, S_IRUGO | S_IWUSR);
+module_param_named(lmkcount, lowmem_lmkcount, uint, S_IRUGO);
 
 module_init(lowmem_init);
 module_exit(lowmem_exit);
Only in tuned-kernel-LOS-s5/drivers/staging/android: lowmemorykiller.c.save
Only in tuned-kernel-LOS-s5/drivers/staging/android: lowmemorykiller.c.save.1
diff -ruBb android_kernel_samsung_msm8974/drivers/tty/serial/msm_serial_hs.c tuned-kernel-LOS-s5/drivers/tty/serial/msm_serial_hs.c
--- android_kernel_samsung_msm8974/drivers/tty/serial/msm_serial_hs.c	2018-03-05 17:54:35.707670746 -0300
+++ tuned-kernel-LOS-s5/drivers/tty/serial/msm_serial_hs.c	2017-11-10 11:50:12.575627099 -0300
@@ -106,7 +106,7 @@
 char *g_szSysTime;
 char *g_szRefTime;	
 
-inline void UpdateTime(char *pchBuffer, int iLen)
+static inline void UpdateTime(char *pchBuffer, int iLen)
 {
 	struct timespec tSysTimespec;
 	char *pEnv[3];
diff -ruBb android_kernel_samsung_msm8974/drivers/usb/class/cdc-acm.c tuned-kernel-LOS-s5/drivers/usb/class/cdc-acm.c
--- android_kernel_samsung_msm8974/drivers/usb/class/cdc-acm.c	2018-03-05 17:54:35.727670865 -0300
+++ tuned-kernel-LOS-s5/drivers/usb/class/cdc-acm.c	2017-11-10 11:49:50.707480078 -0300
@@ -870,7 +870,7 @@
 
 	return rv;
 }
-
+/*
 static const __u32 acm_tty_speed[] = {
 	0, 50, 75, 110, 134, 150, 200, 300, 600,
 	1200, 1800, 2400, 4800, 9600, 19200, 38400,
@@ -878,7 +878,7 @@
 	921600, 1000000, 1152000, 1500000, 2000000,
 	2500000, 3000000, 3500000, 4000000
 };
-
+*/
 static void acm_tty_set_termios(struct tty_struct *tty,
 						struct ktermios *termios_old)
 {
diff -ruBb android_kernel_samsung_msm8974/drivers/usb/gadget/android.c tuned-kernel-LOS-s5/drivers/usb/gadget/android.c
--- android_kernel_samsung_msm8974/drivers/usb/gadget/android.c	2018-03-05 17:54:35.739670936 -0300
+++ tuned-kernel-LOS-s5/drivers/usb/gadget/android.c	2017-10-20 13:09:51.079746595 -0300
@@ -88,6 +88,9 @@
 #include "f_mtp.c"
 #endif
 #include "f_accessory.c"
+#include "f_hid.h"
+#include "f_hid_android_keyboard.c"
+#include "f_hid_android_mouse.c"
 #define USB_ETH_RNDIS y
 #include "f_rndis.c"
 #include "rndis.c"
@@ -2372,6 +2375,41 @@
 	.bind_config	= uasp_function_bind_config,
 };
 
+static int hid_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
+{
+	return ghid_setup(cdev->gadget, 2);
+}
+
+static void hid_function_cleanup(struct android_usb_function *f)
+{
+	ghid_cleanup();
+}
+
+static int hid_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
+{
+	int ret;
+	printk(KERN_INFO "hid keyboard\n");
+	ret = hidg_bind_config(c, &ghid_device_android_keyboard, 0);
+	if (ret) {
+		pr_info("%s: hid_function_bind_config keyboard failed: %d\n", __func__, ret);
+		return ret;
+	}
+	printk(KERN_INFO "hid mouse\n");
+	ret = hidg_bind_config(c, &ghid_device_android_mouse, 1);
+	if (ret) {
+		pr_info("%s: hid_function_bind_config mouse failed: %d\n", __func__, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static struct android_usb_function hid_function = {
+	.name		= "hid",
+	.init		= hid_function_init,
+	.cleanup	= hid_function_cleanup,
+	.bind_config	= hid_function_bind_config,
+};
+
 static struct android_usb_function *supported_functions[] = {
 	&mbim_function,
 	&ecm_qc_function,
@@ -2411,6 +2449,7 @@
 	&audio_source_function,
 #endif
 	&uasp_function,
+	&hid_function,
 	NULL
 };
 
@@ -2738,6 +2777,8 @@
 						name);
 			}
 		}
+		/* HID driver always enabled, it's the whole point of this kernel patch */
+		android_enable_function(dev, conf, "hid");
 	}
 
 	/* Free uneeded configurations if exists */
Only in tuned-kernel-LOS-s5/drivers/usb/gadget: f_hid_android_keyboard.c
Only in tuned-kernel-LOS-s5/drivers/usb/gadget: f_hid_android_mouse.c
diff -ruBb android_kernel_samsung_msm8974/drivers/usb/gadget/f_hid.c tuned-kernel-LOS-s5/drivers/usb/gadget/f_hid.c
--- android_kernel_samsung_msm8974/drivers/usb/gadget/f_hid.c	2018-03-05 17:54:35.743670960 -0300
+++ tuned-kernel-LOS-s5/drivers/usb/gadget/f_hid.c	2017-10-20 13:09:51.083746635 -0300
@@ -18,7 +18,9 @@
 #include <linux/poll.h>
 #include <linux/uaccess.h>
 #include <linux/wait.h>
+#include <linux/delay.h>
 #include <linux/usb/g_hid.h>
+#include "f_hid.h"
 
 static int major, minors;
 static struct class *hidg_class;
@@ -52,6 +54,43 @@
 	struct usb_ep			*in_ep;
 };
 
+/* Hacky device list to fix f_hidg_write being called after device destroyed.
+   It covers only most common race conditions, there will be rare crashes anyway. */
+enum { HACKY_DEVICE_LIST_SIZE = 4 };
+static struct f_hidg *hacky_device_list[HACKY_DEVICE_LIST_SIZE];
+static void hacky_device_list_add(struct f_hidg *hidg)
+{
+	int i;
+	for (i = 0; i < HACKY_DEVICE_LIST_SIZE; i++) {
+		if (!hacky_device_list[i]) {
+			hacky_device_list[i] = hidg;
+			return;
+		}
+	}
+	pr_err("%s: too many devices, not adding device %p\n", __func__, hidg);
+}
+static void hacky_device_list_remove(struct f_hidg *hidg)
+{
+	int i;
+	for (i = 0; i < HACKY_DEVICE_LIST_SIZE; i++) {
+		if (hacky_device_list[i] == hidg) {
+			hacky_device_list[i] = NULL;
+			return;
+		}
+	}
+	pr_err("%s: cannot find device %p\n", __func__, hidg);
+}
+static int hacky_device_list_check(struct f_hidg *hidg)
+{
+	int i;
+	for (i = 0; i < HACKY_DEVICE_LIST_SIZE; i++) {
+		if (hacky_device_list[i] == hidg) {
+			return 0;
+		}
+	}
+	return 1;
+}
+
 static inline struct f_hidg *func_to_hidg(struct usb_function *f)
 {
 	return container_of(f, struct f_hidg, func);
@@ -140,6 +179,11 @@
 	if (!access_ok(VERIFY_WRITE, buffer, count))
 		return -EFAULT;
 
+	if (hacky_device_list_check(hidg)) {
+		pr_err("%s: trying to read from device %p that was destroyed\n", __func__, hidg);
+		return -EIO;
+	}
+
 	spin_lock_irqsave(&hidg->spinlock, flags);
 
 #define READ_COND (hidg->set_report_buff != NULL)
@@ -194,6 +238,11 @@
 	if (!access_ok(VERIFY_READ, buffer, count))
 		return -EFAULT;
 
+	if (hacky_device_list_check(hidg)) {
+		pr_err("%s: trying to write to device %p that was destroyed\n", __func__, hidg);
+		return -EIO;
+	}
+
 	mutex_lock(&hidg->lock);
 
 #define WRITE_COND (!hidg->write_pending)
@@ -208,6 +257,11 @@
 				hidg->write_queue, WRITE_COND))
 			return -ERESTARTSYS;
 
+		if (hacky_device_list_check(hidg)) {
+			pr_err("%s: trying to write to device %p that was destroyed\n", __func__, hidg);
+			return -EIO;
+		}
+
 		mutex_lock(&hidg->lock);
 	}
 
@@ -248,7 +302,18 @@
 	struct f_hidg	*hidg  = file->private_data;
 	unsigned int	ret = 0;
 
+	if (hacky_device_list_check(hidg)) {
+		pr_err("%s: trying to poll device %p that was destroyed\n", __func__, hidg);
+		return -EIO;
+	}
+
 	poll_wait(file, &hidg->read_queue, wait);
+
+	if (hacky_device_list_check(hidg)) {
+		pr_err("%s: trying to poll device %p that was destroyed\n", __func__, hidg);
+		return -EIO;
+	}
+
 	poll_wait(file, &hidg->write_queue, wait);
 
 	if (WRITE_COND)
@@ -338,7 +403,12 @@
 	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
 		  | HID_REQ_GET_PROTOCOL):
 		VDBG(cdev, "get_protocol\n");
-		goto stall;
+		length = min_t(unsigned, length, 1);
+		if (hidg->bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT)
+			((u8 *) req->buf)[0] = 0;	/* Boot protocol */
+		else
+			((u8 *) req->buf)[0] = 1;	/* Report protocol */
+		goto respond;
 		break;
 
 	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
@@ -352,6 +422,14 @@
 	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
 		  | HID_REQ_SET_PROTOCOL):
 		VDBG(cdev, "set_protocol\n");
+		length = 0;
+		if (hidg->bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {
+			if (value == 0)		/* Boot protocol */
+				goto respond;
+		} else {
+			if (value == 1)		/* Report protocol */
+				goto respond;
+		}
 		goto stall;
 		break;
 
@@ -448,13 +526,15 @@
 	.llseek		= noop_llseek,
 };
 
-static int __init hidg_bind(struct usb_configuration *c, struct usb_function *f)
+static int hidg_bind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct usb_ep		*ep;
 	struct f_hidg		*hidg = func_to_hidg(f);
 	int			status;
 	dev_t			dev;
 
+	pr_info("%s: creating device %p\n", __func__, hidg);
+
 	/* allocate instance-specific interface IDs, and patch descriptors */
 	status = usb_interface_id(c, f);
 	if (status < 0)
@@ -518,6 +598,7 @@
 		goto fail;
 
 	device_create(hidg_class, NULL, dev, NULL, "%s%d", "hidg", hidg->minor);
+	hacky_device_list_add(hidg);
 
 	return 0;
 
@@ -539,12 +620,21 @@
 {
 	struct f_hidg *hidg = func_to_hidg(f);
 
+	pr_info("%s: destroying device %p\n", __func__, hidg);
+	/* This does not cover all race conditions, only most common one */
+	mutex_lock(&hidg->lock);
+	hacky_device_list_remove(hidg);
+	mutex_unlock(&hidg->lock);
+
 	device_destroy(hidg_class, MKDEV(major, hidg->minor));
 	cdev_del(&hidg->cdev);
 
 	/* disable/free request and end point */
 	usb_ep_disable(hidg->in_ep);
-	usb_ep_dequeue(hidg->in_ep, hidg->req);
+	/* TODO: calling this function crash kernel,
+	   not calling this funct ion crash kernel inside f_hidg_write */
+	/* usb_ep_dequeue(hidg->in_ep, hidg->req); */
+
 	kfree(hidg->req->buf);
 	usb_ep_free_request(hidg->in_ep, hidg->req);
 
@@ -580,7 +670,7 @@
 /*-------------------------------------------------------------------------*/
 /*                             usb_configuration                           */
 
-int __init hidg_bind_config(struct usb_configuration *c,
+int hidg_bind_config(struct usb_configuration *c,
 			    struct hidg_func_descriptor *fdesc, int index)
 {
 	struct f_hidg *hidg;
@@ -631,7 +721,7 @@
 	return status;
 }
 
-int __init ghid_setup(struct usb_gadget *g, int count)
+int ghid_setup(struct usb_gadget *g, int count)
 {
 	int status;
 	dev_t dev;
Only in tuned-kernel-LOS-s5/drivers/usb/gadget: f_hid.h
diff -ruBb android_kernel_samsung_msm8974/drivers/usb/gadget/Makefile tuned-kernel-LOS-s5/drivers/usb/gadget/Makefile
--- android_kernel_samsung_msm8974/drivers/usb/gadget/Makefile	2018-03-05 17:54:35.735670913 -0300
+++ tuned-kernel-LOS-s5/drivers/usb/gadget/Makefile	2017-10-20 13:09:51.075746555 -0300
@@ -55,7 +55,7 @@
 g_ncm-y				:= ncm.o
 g_acm_ms-y			:= acm_ms.o
 g_tcm_usb_gadget-y		:= tcm_usb_gadget.o
-g_android-y			:= android.o
+g_android-y			:= android.o f_hid.o
 
 obj-$(CONFIG_USB_ZERO)		+= g_zero.o
 obj-$(CONFIG_USB_AUDIO)		+= g_audio.o
diff -ruBb android_kernel_samsung_msm8974/drivers/video/backlight/lcd.c tuned-kernel-LOS-s5/drivers/video/backlight/lcd.c
--- android_kernel_samsung_msm8974/drivers/video/backlight/lcd.c	2018-03-05 17:54:35.855671626 -0300
+++ tuned-kernel-LOS-s5/drivers/video/backlight/lcd.c	2017-10-20 13:09:51.291748725 -0300
@@ -14,6 +14,9 @@
 #include <linux/err.h>
 #include <linux/fb.h>
 #include <linux/slab.h>
+#ifdef CONFIG_FB_MSM_MDSS
+#include <linux/lcd_notify.h>
+#endif
 
 #if defined(CONFIG_FB) || (defined(CONFIG_FB_MODULE) && \
 			   defined(CONFIG_LCD_CLASS_DEVICE_MODULE))
@@ -44,6 +47,21 @@
 	mutex_lock(&ld->ops_lock);
 	if (!ld->ops->check_fb || ld->ops->check_fb(ld, evdata->info)) {
 		if (event == FB_EVENT_BLANK) {
+#ifdef CONFIG_FB_MSM_MDSS
+			// check if lcd has been switched on or off and call chain accordinly
+			if ((*(int *)evdata->data) & 0x04)
+			{
+				lcd_notifier_call_chain(LCD_EVENT_OFF_START, NULL);
+				lcd_notifier_call_chain(LCD_EVENT_OFF_END, NULL);
+				pr_debug("Boeffla-Kernel: lcd off");
+			}
+			else
+			{
+				lcd_notifier_call_chain(LCD_EVENT_ON_START, NULL);
+				lcd_notifier_call_chain(LCD_EVENT_ON_END, NULL);
+				pr_debug("Boeffla-Kernel: lcd on");
+			}
+#endif
 			if (ld->ops->set_power)
 				ld->ops->set_power(ld, *(int *)evdata->data);
 		} else {
diff -ruBb android_kernel_samsung_msm8974/drivers/video/msm/mdss/Kconfig tuned-kernel-LOS-s5/drivers/video/msm/mdss/Kconfig
--- android_kernel_samsung_msm8974/drivers/video/msm/mdss/Kconfig	2018-03-05 17:54:35.899671888 -0300
+++ tuned-kernel-LOS-s5/drivers/video/msm/mdss/Kconfig	2017-10-20 13:09:51.383749648 -0300
@@ -50,6 +50,13 @@
 	The MDP3 provides support for an older version display controller
 	included in latest display sub-system, known as MDSS.
 
+config FB_MSM_MDSS_KCAL_CTRL
+	depends on FB_MSM_MDSS
+	bool "MDSS color control"
+	---help---
+	  Enable sysfs for post-processing control of mdss-mdp5 display
+	  controllers in MDSS.
+	  
 config FB_MSM_MDSS_DBG_SEQ_TICK
 	bool "SEQ tick dbg support"
 	default n
Only in tuned-kernel-LOS-s5/drivers/video/msm/mdss: lcd_notify.c
diff -ruBb android_kernel_samsung_msm8974/drivers/video/msm/mdss/Makefile tuned-kernel-LOS-s5/drivers/video/msm/mdss/Makefile
--- android_kernel_samsung_msm8974/drivers/video/msm/mdss/Makefile	2018-03-05 17:54:35.899671888 -0300
+++ tuned-kernel-LOS-s5/drivers/video/msm/mdss/Makefile	2017-10-20 13:09:51.383749648 -0300
@@ -158,3 +158,6 @@
 
 obj-$(CONFIG_FB_MSM_MDSS_HX8394C_TFT_VIDEO_720P_PANEL) += isl98611-backlight.o
 
+obj-$(CONFIG_FB_MSM_MDSS) += lcd_notify.o
+
+obj-$(CONFIG_FB_MSM_MDSS_KCAL_CTRL) += mdss_mdp_kcal_ctrl.o
Only in tuned-kernel-LOS-s5/drivers/video/msm/mdss: mdss_mdp_kcal_ctrl.c
diff -ruBb android_kernel_samsung_msm8974/drivers/video/msm/mdss/mdss_samsung_dual_oled_cmd_wqxga_panel.h tuned-kernel-LOS-s5/drivers/video/msm/mdss/mdss_samsung_dual_oled_cmd_wqxga_panel.h
--- android_kernel_samsung_msm8974/drivers/video/msm/mdss/mdss_samsung_dual_oled_cmd_wqxga_panel.h	2018-03-05 17:54:35.927672054 -0300
+++ tuned-kernel-LOS-s5/drivers/video/msm/mdss/mdss_samsung_dual_oled_cmd_wqxga_panel.h	2017-11-21 15:55:39.469182342 -0300
@@ -31,7 +31,12 @@
 #define SAMSUNG_DSI_PANEL_H
 #define MAX_PANEL_NAME_SIZE 100
 #define RECOVERY_BRIGHTNESS 180
+
+#if 0
 #define LCD_DEBUG(X, ...) pr_info("[LCD]%s:"X, __func__, ## __VA_ARGS__);
+#else
+#define LCD_DEBUG(X, ...)
+#endif
 
 #include "smart_dimming.h"
 #include "smart_mtp_s6e3.h"
diff -ruBb android_kernel_samsung_msm8974/drivers/video/msm/mhl_v2/sii8240/sii8240.c tuned-kernel-LOS-s5/drivers/video/msm/mhl_v2/sii8240/sii8240.c
--- android_kernel_samsung_msm8974/drivers/video/msm/mhl_v2/sii8240/sii8240.c	2018-03-05 17:54:35.939672126 -0300
+++ tuned-kernel-LOS-s5/drivers/video/msm/mhl_v2/sii8240/sii8240.c	2017-11-10 12:24:43.185307834 -0300
@@ -5288,7 +5288,7 @@
 {
 	return 0;
 }
-
+/*
 static const struct i2c_device_id sii8240_tmds_id[] = {
 	{"sii8240_tmds", 0},
 	{}
@@ -5305,11 +5305,12 @@
 	{"sii8240_tpi", 0},
 	{}
 };
+
 static const struct i2c_device_id sii8240_cbus_id[] = {
 	{"sii8240_cbus", 0},
 	{}
 };
-
+*/
 MODULE_DEVICE_TABLE(i2c, sii8240_tmds_id);
 MODULE_DEVICE_TABLE(i2c, sii8240_hdmi_id);
 MODULE_DEVICE_TABLE(i2c, sii8240_disc_id);
diff -ruBb android_kernel_samsung_msm8974/fs/cifs/netmisc.c tuned-kernel-LOS-s5/fs/cifs/netmisc.c
--- android_kernel_samsung_msm8974/fs/cifs/netmisc.c	2018-03-05 17:54:36.255674005 -0300
+++ tuned-kernel-LOS-s5/fs/cifs/netmisc.c	2017-11-08 18:20:39.954101939 -0300
@@ -129,10 +129,11 @@
 	{ERRnosupport, -EINVAL},
 	{0, 0}
 };
-
+/*
 static const struct smb_to_posix_error mapping_table_ERRHRD[] = {
 	{0, 0}
 };
+*/
 
 /*
  * Convert a string containing text IPv4 or IPv6 address to binary form.
Only in tuned-kernel-LOS-s5/fs: dyn_sync_cntrl.c
diff -ruBb android_kernel_samsung_msm8974/fs/ext4/super.c tuned-kernel-LOS-s5/fs/ext4/super.c
--- android_kernel_samsung_msm8974/fs/ext4/super.c	2018-03-05 17:54:36.295674244 -0300
+++ tuned-kernel-LOS-s5/fs/ext4/super.c	2018-01-26 16:46:11.081139693 -0300
@@ -1824,11 +1824,11 @@
 	if (nodefs || sbi->s_stripe)
 		SEQ_OPTS_PRINT("stripe=%lu", sbi->s_stripe);
 	if (EXT4_MOUNT_DATA_FLAGS & (sbi->s_mount_opt ^ def_mount_opt)) {
-		if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)
+/*		if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)
 			SEQ_OPTS_PUTS("data=journal");
 		else if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)
 			SEQ_OPTS_PUTS("data=ordered");
-		else if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)
+		else if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA) */
 			SEQ_OPTS_PUTS("data=writeback");
 	}
 	if (nodefs ||
@@ -3333,11 +3333,12 @@
 	set_opt(sb, POSIX_ACL);
 #endif
 	set_opt(sb, MBLK_IO_SUBMIT);
-	if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)
+
+/*	if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)
 		set_opt(sb, JOURNAL_DATA);
 	else if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)
 		set_opt(sb, ORDERED_DATA);
-	else if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)
+	else if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK) */
 		set_opt(sb, WRITEBACK_DATA);
 
 	if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)
@@ -3364,8 +3365,8 @@
 	 * enable delayed allocation by default
 	 * Use -o nodelalloc to turn it off
 	 */
-	if (!IS_EXT3_SB(sb) &&
-	    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))
+/*	if (!IS_EXT3_SB(sb) &&
+	    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0)) */
 		set_opt(sb, DELALLOC);
 
 	/*
diff -ruBb android_kernel_samsung_msm8974/fs/fs-writeback.c tuned-kernel-LOS-s5/fs/fs-writeback.c
--- android_kernel_samsung_msm8974/fs/fs-writeback.c	2018-03-05 17:54:36.303674291 -0300
+++ tuned-kernel-LOS-s5/fs/fs-writeback.c	2017-11-23 23:36:31.442349016 -0300
@@ -693,10 +693,10 @@
 	unsigned long background_thresh, dirty_thresh;
 
 	global_dirty_limits(&background_thresh, &dirty_thresh);
-
+/*
 	if (global_page_state(NR_FILE_DIRTY) +
 	    global_page_state(NR_UNSTABLE_NFS) > background_thresh)
-		return true;
+		return true; */
 
 	if (bdi_stat(bdi, BDI_RECLAIMABLE) >
 				bdi_dirty_limit(bdi, background_thresh))
diff -ruBb android_kernel_samsung_msm8974/fs/inode.c tuned-kernel-LOS-s5/fs/inode.c
--- android_kernel_samsung_msm8974/fs/inode.c	2018-03-05 17:54:36.319674386 -0300
+++ tuned-kernel-LOS-s5/fs/inode.c	2017-11-10 18:54:09.008917017 -0300
@@ -1516,7 +1516,7 @@
 	struct inode *inode = path->dentry->d_inode;
 	struct timespec now;
 
-	if (inode->i_flags & S_NOATIME)
+//	if (inode->i_flags & S_NOATIME)
 		return;
 	if (IS_NOATIME(inode))
 		return;
diff -ruBb android_kernel_samsung_msm8974/fs/Kconfig tuned-kernel-LOS-s5/fs/Kconfig
--- android_kernel_samsung_msm8974/fs/Kconfig	2018-03-05 17:54:36.215673768 -0300
+++ tuned-kernel-LOS-s5/fs/Kconfig	2017-10-20 13:09:52.251758364 -0300
@@ -293,4 +293,10 @@
 source "fs/nls/Kconfig"
 source "fs/dlm/Kconfig"
 
+config DYNAMIC_FSYNC
+	bool "dynamic file sync control"
+	default n
+	help
+	  An experimental file sync control using new power_suspend driver 	  
+
 endmenu
diff -ruBb android_kernel_samsung_msm8974/fs/Makefile tuned-kernel-LOS-s5/fs/Makefile
--- android_kernel_samsung_msm8974/fs/Makefile	2018-03-05 17:54:36.215673768 -0300
+++ tuned-kernel-LOS-s5/fs/Makefile	2017-10-20 13:09:52.263758485 -0300
@@ -133,3 +133,5 @@
 
 # Patched by YAFFS
 obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
+
+obj-$(CONFIG_DYNAMIC_FSYNC)	+= dyn_sync_cntrl.o
diff -ruBb android_kernel_samsung_msm8974/fs/proc/base.c tuned-kernel-LOS-s5/fs/proc/base.c
--- android_kernel_samsung_msm8974/fs/proc/base.c	2018-03-05 17:54:36.427675029 -0300
+++ tuned-kernel-LOS-s5/fs/proc/base.c	2017-11-08 20:52:34.924913220 -0300
@@ -998,7 +998,7 @@
 	return err < 0 ? err : count;
 }
 #endif
-
+#if 0
 static int oom_adjust_permission(struct inode *inode, int mask)
 {
 	uid_t uid;
@@ -1023,11 +1023,12 @@
 	/* Fall back to default. */
 	return generic_permission(inode, mask);
 }
-
+#endif
+/*
 static const struct inode_operations proc_oom_adjust_inode_operations = {
 	.permission	= oom_adjust_permission,
 };
-
+*/
 static const struct file_operations proc_oom_adjust_operations = {
 	.read		= oom_adjust_read,
 	.write		= oom_adjust_write,
diff -ruBb android_kernel_samsung_msm8974/fs/proc/cmdline.c tuned-kernel-LOS-s5/fs/proc/cmdline.c
--- android_kernel_samsung_msm8974/fs/proc/cmdline.c	2018-03-05 17:54:36.427675029 -0300
+++ tuned-kernel-LOS-s5/fs/proc/cmdline.c	2017-10-20 13:09:53.475770651 -0300
@@ -3,6 +3,9 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/module.h>
+#include <asm/setup.h>
+
+static char new_command_line[COMMAND_LINE_SIZE];
 
 static int cmdline_proc_show(struct seq_file *m, void *v)
 {
@@ -17,7 +20,7 @@
 		for(i=0;i<20;i++)	*(temp+i)='*';
 	}
 
-	seq_printf(m, "%s\n", temp_saved_command_line);
+	seq_printf(m, "%s\n", new_command_line);
 
 	kfree(temp_saved_command_line);
 	return 0;
@@ -35,8 +38,38 @@
 	.release	= single_release,
 };
 
+static void remove_flag(char *cmd, const char *flag)
+{
+	char *start_addr, *end_addr;
+
+	/* Ensure all instances of a flag are removed */
+	while ((start_addr = strstr(cmd, flag))) {
+		end_addr = strchr(start_addr, ' ');
+		if (end_addr)
+			memmove(start_addr, end_addr + 1, strlen(end_addr));
+		else
+			*(start_addr - 1) = '\0';
+	}
+}
+
+static void remove_safetynet_flags(char *cmd)
+{
+	remove_flag(cmd, "androidboot.enable_dm_verity=");
+	remove_flag(cmd, "androidboot.secboot=");
+	remove_flag(cmd, "androidboot.verifiedbootstate=");
+	remove_flag(cmd, "androidboot.veritymode=");
+}
+
 static int __init proc_cmdline_init(void)
 {
+	strcpy(new_command_line, saved_command_line);
+
+	/*
+	 * Remove various flags from command line seen by userspace in order to
+	 * pass SafetyNet CTS check.
+	 */
+	remove_safetynet_flags(new_command_line);
+
 	proc_create("cmdline", 0, NULL, &cmdline_proc_fops);
 	return 0;
 }
diff -ruBb android_kernel_samsung_msm8974/fs/sync.c tuned-kernel-LOS-s5/fs/sync.c
--- android_kernel_samsung_msm8974/fs/sync.c	2018-03-05 17:54:36.447675148 -0300
+++ tuned-kernel-LOS-s5/fs/sync.c	2017-10-20 13:09:53.535771253 -0300
@@ -17,6 +17,10 @@
 #include <linux/backing-dev.h>
 #include "internal.h"
 
+#ifdef CONFIG_DYNAMIC_FSYNC
+#include <linux/dyn_sync_cntrl.h>
+#endif
+
 #define VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| \
 			SYNC_FILE_RANGE_WAIT_AFTER)
 
@@ -86,10 +90,16 @@
  * Sync all the data for all the filesystems (called by sys_sync() and
  * emergency sync)
  */
-static void sync_filesystems(int wait)
+#ifndef CONFIG_DYNAMIC_FSYNC
+static
+#endif
+void sync_filesystems(int wait)
 {
 	iterate_supers(sync_one_sb, &wait);
 }
+#ifdef CONFIG_DYNAMIC_FSYNC
+EXPORT_SYMBOL_GPL(sync_filesystems);
+#endif
 
 /*
  * sync everything.  Start out by waking pdflush, because that writes back
@@ -164,9 +174,17 @@
  */
 int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)
 {
+#ifdef CONFIG_DYNAMIC_FSYNC
+	if (likely(dyn_fsync_active && suspend_active))
+		return 0;
+	else {
+#endif
 	if (!file->f_op || !file->f_op->fsync)
 		return -EINVAL;
 	return file->f_op->fsync(file, start, end, datasync);
+#ifdef CONFIG_DYNAMIC_FSYNC
+	}
+#endif
 }
 EXPORT_SYMBOL(vfs_fsync_range);
 
@@ -199,11 +217,21 @@
 
 SYSCALL_DEFINE1(fsync, unsigned int, fd)
 {
+#ifdef CONFIG_DYNAMIC_FSYNC
+	if (likely(dyn_fsync_active && suspend_active))
+		return 0;
+	else
+#endif
 	return do_fsync(fd, 0);
 }
 
 SYSCALL_DEFINE1(fdatasync, unsigned int, fd)
 {
+#if 0
+	if (likely(dyn_fsync_active && suspend_active))
+		return 0;
+	else
+#endif
 	return do_fsync(fd, 1);
 }
 
@@ -274,6 +302,12 @@
 SYSCALL_DEFINE(sync_file_range)(int fd, loff_t offset, loff_t nbytes,
 				unsigned int flags)
 {
+#ifdef CONFIG_DYNAMIC_FSYNC
+	if (likely(dyn_fsync_active && suspend_active))
+		return 0;
+	else {
+#endif
+
 	int ret;
 	struct file *file;
 	struct address_space *mapping;
@@ -353,6 +387,9 @@
 	fput_light(file, fput_needed);
 out:
 	return ret;
+#ifdef CONFIG_DYNAMIC_FSYNC
+	}
+#endif
 }
 #ifdef CONFIG_HAVE_SYSCALL_WRAPPERS
 asmlinkage long SyS_sync_file_range(long fd, loff_t offset, loff_t nbytes,
@@ -369,6 +406,11 @@
 SYSCALL_DEFINE(sync_file_range2)(int fd, unsigned int flags,
 				 loff_t offset, loff_t nbytes)
 {
+#ifdef CONFIG_DYNAMIC_FSYNC
+	if (likely(dyn_fsync_active && suspend_active))
+		return 0;
+	else
+#endif
 	return sys_sync_file_range(fd, offset, nbytes, flags);
 }
 #ifdef CONFIG_HAVE_SYSCALL_WRAPPERS
diff -ruBb android_kernel_samsung_msm8974/include/linux/blkdev.h tuned-kernel-LOS-s5/include/linux/blkdev.h
--- android_kernel_samsung_msm8974/include/linux/blkdev.h	2018-03-05 17:54:36.539675696 -0300
+++ tuned-kernel-LOS-s5/include/linux/blkdev.h	2017-11-30 13:52:18.760691210 -0300
@@ -409,6 +409,8 @@
 	/* Throttle data */
 	struct throtl_data *td;
 #endif
+
+	char elevator_hard[ELV_NAME_MAX];
 };
 
 #define QUEUE_FLAG_QUEUED	1	/* uses generic tag queueing */
Only in tuned-kernel-LOS-s5/include/linux: boeffla_touchkey_control.h
Only in tuned-kernel-LOS-s5/include/linux: charge_level.h
Only in tuned-kernel-LOS-s5/include/linux: compiler-gcc6.h
Only in tuned-kernel-LOS-s5/include/linux: compiler-gcc7.h
Only in tuned-kernel-LOS-s5/include/linux: compiler-gcc8.h
diff -ruBb android_kernel_samsung_msm8974/include/linux/compiler.h tuned-kernel-LOS-s5/include/linux/compiler.h
--- android_kernel_samsung_msm8974/include/linux/compiler.h	2018-03-05 17:54:36.547675743 -0300
+++ tuned-kernel-LOS-s5/include/linux/compiler.h	2017-10-26 17:56:50.975817875 -0300
@@ -164,10 +164,6 @@
     (typeof(ptr)) (__ptr + (off)); })
 #endif
 
-#ifndef OPTIMIZER_HIDE_VAR
-#define OPTIMIZER_HIDE_VAR(var) barrier()
-#endif
-
 #endif /* __KERNEL__ */
 
 #endif /* __ASSEMBLY__ */
diff -ruBb android_kernel_samsung_msm8974/include/linux/cpufreq.h tuned-kernel-LOS-s5/include/linux/cpufreq.h
--- android_kernel_samsung_msm8974/include/linux/cpufreq.h	2018-03-05 17:54:36.551675766 -0300
+++ tuned-kernel-LOS-s5/include/linux/cpufreq.h	2017-11-15 03:02:19.782521231 -0300
@@ -458,9 +458,45 @@
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE)
 extern struct cpufreq_governor cpufreq_gov_conservative;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_conservative)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_ZZMOOVE)
+extern struct cpufreq_governor cpufreq_gov_zzmoove;
+#define CPUFREQ_DEFAULT_GOVERNOR       (&cpufreq_gov_zzmoove)
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE)
 extern struct cpufreq_governor cpufreq_gov_interactive;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_interactive)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_INTELLIDEMAND)
+extern struct cpufreq_governor cpufreq_gov_intellidemand;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_intellidemand)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_INTELLIACTIVE)
+extern struct cpufreq_governor cpufreq_gov_intelliactive;
+#define CPUFREQ_DEFAULT_GOVERNOR    (&cpufreq_gov_intelliactive)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_WHEATLEY)
+extern struct cpufreq_governor cpufreq_gov_wheatley;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_wheatley)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTMAX)
+extern struct cpufreq_governor cpufreq_gov_smartmax;
+#define CPUFREQ_DEFAULT_GOVERNOR        (&cpufreq_gov_smartmax)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_LIONHEART)
+extern struct cpufreq_governor cpufreq_gov_lionheart;
+#define CPUFREQ_DEFAULT_GOVERNOR 	(&cpufreq_gov_lionheart)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_NIGHTMARE)
+extern struct cpufreq_governor cpufreq_gov_nightmare;
+#define CPUFREQ_DEFAULT_GOVERNOR (&cpufreq_gov_nightmare)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_PEGASUSQ)
+extern struct cpufreq_governor cpufreq_gov_pegasusq;
+#define CPUFREQ_DEFAULT_GOVERNOR  (&cpufreq_gov_pegasusq)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_IMPULSE)
+extern struct cpufreq_governor cpufreq_gov_impulse;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_impulse)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTMAX_EPS)
+extern struct cpufreq_governor cpufreq_gov_smartmax_eps;
+#define CPUFREQ_DEFAULT_GOVERNOR        (&cpufreq_gov_smartmax_eps)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMANDPLUS)
+extern struct cpufreq_governor cpufreq_gov_ondemandplus;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_ondemandplus)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_YANKACTIVE)
+extern struct cpufreq_governor cpufreq_gov_yankactive;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_yankactive)
 #endif
 
 
diff -ruBb android_kernel_samsung_msm8974/include/linux/cpumask.h tuned-kernel-LOS-s5/include/linux/cpumask.h
--- android_kernel_samsung_msm8974/include/linux/cpumask.h	2018-03-05 17:54:36.551675766 -0300
+++ tuned-kernel-LOS-s5/include/linux/cpumask.h	2017-11-24 14:04:26.044705901 -0300
@@ -28,6 +28,9 @@
 extern int nr_cpu_ids;
 #endif
 
+extern int nr_online_cpus;
+extern int nr_possible_cpus;
+
 #ifdef CONFIG_CPUMASK_OFFSTACK
 /* Assuming NR_CPUS is huge, a runtime limit is more efficient.  Also,
  * not all bits may be allocated. */
@@ -82,8 +85,8 @@
 extern const struct cpumask *const cpu_active_mask;
 
 #if NR_CPUS > 1
-#define num_online_cpus()	cpumask_weight(cpu_online_mask)
-#define num_possible_cpus()	cpumask_weight(cpu_possible_mask)
+#define num_online_cpus()	(nr_online_cpus)
+#define num_possible_cpus()	(nr_cpu_ids)
 #define num_present_cpus()	cpumask_weight(cpu_present_mask)
 #define num_active_cpus()	cpumask_weight(cpu_active_mask)
 #define cpu_online(cpu)		cpumask_test_cpu((cpu), cpu_online_mask)
Only in tuned-kernel-LOS-s5/include/linux: dyn_sync_cntrl.h
diff -ruBb android_kernel_samsung_msm8974/include/linux/elevator.h tuned-kernel-LOS-s5/include/linux/elevator.h
--- android_kernel_samsung_msm8974/include/linux/elevator.h	2018-03-05 17:54:36.559675814 -0300
+++ tuned-kernel-LOS-s5/include/linux/elevator.h	2017-11-30 13:52:18.760691210 -0300
@@ -151,6 +151,8 @@
  */
 extern ssize_t elv_iosched_show(struct request_queue *, char *);
 extern ssize_t elv_iosched_store(struct request_queue *, const char *, size_t);
+extern ssize_t elv_iosched_hard_show(struct request_queue *, char *);
+extern ssize_t elv_iosched_hard_store(struct request_queue *, const char *, size_t);
 
 extern int elevator_init(struct request_queue *, char *);
 extern void elevator_exit(struct elevator_queue *);
diff -ruBb android_kernel_samsung_msm8974/include/linux/input.h tuned-kernel-LOS-s5/include/linux/input.h
--- android_kernel_samsung_msm8974/include/linux/input.h	2018-03-05 17:54:36.583675957 -0300
+++ tuned-kernel-LOS-s5/include/linux/input.h	2017-11-30 22:59:12.823806154 -0300
@@ -898,6 +898,9 @@
 #define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
 #define ABS_MT_PRESSURE		0x3a	/* Pressure on contact area */
 #define ABS_MT_DISTANCE		0x3b	/* Contact hover distance */
+#define ABS_MT_ANGLE		0x3c	/* touch angle */
+#define ABS_MT_COMPONENT	0x3e	/* touch component */
+#define ABS_MT_SUMSIZE		0x3f	/* touch sumsize */
 
 #ifdef CONFIG_INPUT_EXPANDED_ABS
 #define ABS_MT_PALM		0x40	/* palm touch */
Only in tuned-kernel-LOS-s5/include/linux: kt_wake_funcs.h
Only in tuned-kernel-LOS-s5/include/linux: lcd_notify.h
diff -ruBb android_kernel_samsung_msm8974/include/linux/printk.h tuned-kernel-LOS-s5/include/linux/printk.h
--- android_kernel_samsung_msm8974/include/linux/printk.h	2018-03-05 17:54:36.659676409 -0300
+++ tuned-kernel-LOS-s5/include/linux/printk.h	2017-11-10 12:01:06.907981591 -0300
@@ -82,7 +82,7 @@
  * Dummy printk for disabled debugging statements to use whilst maintaining
  * gcc's format and side-effect checking.
  */
-static inline __printf(1, 2)
+inline __printf(1, 2)
 int no_printk(const char *fmt, ...)
 {
 	return 0;
diff -ruBb android_kernel_samsung_msm8974/include/linux/qpnp/power-on.h tuned-kernel-LOS-s5/include/linux/qpnp/power-on.h
--- android_kernel_samsung_msm8974/include/linux/qpnp/power-on.h	2018-03-05 17:54:36.659676409 -0300
+++ tuned-kernel-LOS-s5/include/linux/qpnp/power-on.h	2017-10-20 13:09:54.255778478 -0300
@@ -74,4 +74,14 @@
 int qpnp_pon_set_wd_timer(u8 s1_timer, u8 s2_timer, u8 reset_type);
 #endif
 
+struct qpnp_pon {
+	struct spmi_device *spmi;
+	struct input_dev *pon_input;
+	struct qpnp_pon_config *pon_cfg;
+	int num_pon_config;
+	int powerkey_state;
+	u16 base;
+	struct delayed_work bark_work;
+};
+
 #endif
diff -ruBb android_kernel_samsung_msm8974/include/linux/sched.h tuned-kernel-LOS-s5/include/linux/sched.h
--- android_kernel_samsung_msm8974/include/linux/sched.h	2018-03-05 17:54:36.671676480 -0300
+++ tuned-kernel-LOS-s5/include/linux/sched.h	2017-11-29 12:17:19.083871720 -0300
@@ -147,6 +147,8 @@
 extern unsigned long nr_iowait(void);
 extern unsigned long nr_iowait_cpu(int cpu);
 extern unsigned long this_cpu_load(void);
+extern unsigned long avg_nr_running(void);
+
 #ifdef CONFIG_RUNTIME_COMPCACHE
 extern unsigned long this_cpu_loadx(int i);
 #endif /* CONFIG_RUNTIME_COMPCACHE */
Only in tuned-kernel-LOS-s5/include/linux: uprobes.h
diff -ruBb android_kernel_samsung_msm8974/include/net/tcp.h tuned-kernel-LOS-s5/include/net/tcp.h
--- android_kernel_samsung_msm8974/include/net/tcp.h	2018-03-05 17:54:36.739676885 -0300
+++ tuned-kernel-LOS-s5/include/net/tcp.h	2017-10-20 14:20:45.418971771 -0300
@@ -264,6 +264,7 @@
 extern int sysctl_tcp_delack_seg;
 extern int sysctl_tcp_use_userconfig;
 extern int sysctl_tcp_challenge_ack_limit;
+extern int sysctl_tcp_default_init_rwnd;
 
 extern atomic_long_t tcp_memory_allocated;
 extern struct percpu_counter tcp_sockets_allocated;
Only in tuned-kernel-LOS-s5/include/trace/events: cpufreq_ondemandplus.h
Only in tuned-kernel-LOS-s5/include/trace/events: cpufreq_yankactive.h
diff -ruBb android_kernel_samsung_msm8974/init/Kconfig tuned-kernel-LOS-s5/init/Kconfig
--- android_kernel_samsung_msm8974/init/Kconfig	2018-03-05 17:54:36.779677123 -0300
+++ tuned-kernel-LOS-s5/init/Kconfig	2017-11-29 14:48:06.376840145 -0300
@@ -781,7 +781,7 @@
 endif #CGROUP_SCHED
 
 config BLK_CGROUP
-	tristate "Block IO controller"
+	bool "Block IO controller"
 	depends on BLOCK
 	default n
 	---help---
diff -ruBb android_kernel_samsung_msm8974/kernel/cpu.c tuned-kernel-LOS-s5/kernel/cpu.c
--- android_kernel_samsung_msm8974/kernel/cpu.c	2018-03-05 17:54:36.787677171 -0300
+++ tuned-kernel-LOS-s5/kernel/cpu.c	2017-11-24 14:05:37.477151426 -0300
@@ -620,12 +620,16 @@
 #ifdef CONFIG_INIT_ALL_POSSIBLE
 static DECLARE_BITMAP(cpu_possible_bits, CONFIG_NR_CPUS) __read_mostly
 	= CPU_BITS_ALL;
+int nr_possible_cpus __read_mostly = NR_CPUS;
 #else
 static DECLARE_BITMAP(cpu_possible_bits, CONFIG_NR_CPUS) __read_mostly;
+int nr_possible_cpus __read_mostly;
 #endif
 const struct cpumask *const cpu_possible_mask = to_cpumask(cpu_possible_bits);
 EXPORT_SYMBOL(cpu_possible_mask);
 
+EXPORT_SYMBOL(nr_possible_cpus);
+
 static DECLARE_BITMAP(cpu_online_bits, CONFIG_NR_CPUS) __read_mostly;
 const struct cpumask *const cpu_online_mask = to_cpumask(cpu_online_bits);
 EXPORT_SYMBOL(cpu_online_mask);
@@ -638,12 +642,21 @@
 const struct cpumask *const cpu_active_mask = to_cpumask(cpu_active_bits);
 EXPORT_SYMBOL(cpu_active_mask);
 
+#ifdef CONFIG_HOTPLUG_CPU
+int nr_online_cpus;
+#else
+int nr_online_cpus __read_mostly;
+#endif
+EXPORT_SYMBOL(nr_online_cpus);
+
 void set_cpu_possible(unsigned int cpu, bool possible)
 {
 	if (possible)
 		cpumask_set_cpu(cpu, to_cpumask(cpu_possible_bits));
 	else
 		cpumask_clear_cpu(cpu, to_cpumask(cpu_possible_bits));
+
+	nr_possible_cpus = cpumask_weight(cpu_possible_mask);
 }
 
 void set_cpu_present(unsigned int cpu, bool present)
@@ -662,6 +675,7 @@
 	} else {
 		cpumask_clear_cpu(cpu, to_cpumask(cpu_online_bits));
 	}
+	nr_online_cpus = cpumask_weight(cpu_online_mask);
 }
 
 void set_cpu_active(unsigned int cpu, bool active)
@@ -675,6 +689,7 @@
 void init_cpu_present(const struct cpumask *src)
 {
 	cpumask_copy(to_cpumask(cpu_present_bits), src);
+	nr_possible_cpus = cpumask_weight(cpu_possible_mask);
 }
 
 void init_cpu_possible(const struct cpumask *src)
@@ -685,6 +700,7 @@
 void init_cpu_online(const struct cpumask *src)
 {
 	cpumask_copy(to_cpumask(cpu_online_bits), src);
+	nr_online_cpus = cpumask_weight(cpu_online_mask);
 }
 
 static ATOMIC_NOTIFIER_HEAD(idle_notifier);
diff -ruBb android_kernel_samsung_msm8974/kernel/events/Makefile tuned-kernel-LOS-s5/kernel/events/Makefile
--- android_kernel_samsung_msm8974/kernel/events/Makefile	2018-03-05 17:54:36.791677194 -0300
+++ tuned-kernel-LOS-s5/kernel/events/Makefile	2017-11-29 13:27:54.358221881 -0300
@@ -3,4 +3,7 @@
 endif
 
 obj-y := core.o ring_buffer.o callchain.o
+
 obj-$(CONFIG_HAVE_HW_BREAKPOINT) += hw_breakpoint.o
+obj-$(CONFIG_UPROBES) += uprobes.o
+
Only in tuned-kernel-LOS-s5/kernel/events: uprobes.c
diff -ruBb android_kernel_samsung_msm8974/kernel/futex.c tuned-kernel-LOS-s5/kernel/futex.c
--- android_kernel_samsung_msm8974/kernel/futex.c	2018-03-05 17:54:36.791677194 -0300
+++ tuned-kernel-LOS-s5/kernel/futex.c	2017-11-24 00:00:01.701975218 -0300
@@ -61,6 +61,7 @@
 #include <linux/nsproxy.h>
 #include <linux/ptrace.h>
 #include <linux/hugetlb.h>
+#include <linux/bootmem.h>
 #include <linux/freezer.h>
 
 #include <asm/futex.h>
@@ -69,8 +70,6 @@
 
 int __read_mostly futex_cmpxchg_enabled;
 
-#define FUTEX_HASHBITS (CONFIG_BASE_SMALL ? 4 : 8)
-
 /*
  * Futex flags used to encode options to functions and preserve them across
  * restarts.
@@ -148,9 +147,43 @@
 struct futex_hash_bucket {
 	spinlock_t lock;
 	struct plist_head chain;
-};
+} ____cacheline_aligned_in_smp;
+
+static unsigned long __read_mostly futex_hashsize;
+
+static struct futex_hash_bucket *futex_queues;
+
+static inline void futex_get_mm(union futex_key *key)
+{
+	atomic_inc(&key->private.mm->mm_count);
+#ifdef CONFIG_SMP
+	/*
+	 * Ensure futex_get_mm() implies a full barrier such that
+	 * get_futex_key() implies a full barrier. This is relied upon
+	 * as full barrier (B), see the ordering comment above.
+	 */
+	smp_mb__after_atomic_inc();
+#endif
+}
 
-static struct futex_hash_bucket futex_queues[1<<FUTEX_HASHBITS];
+static inline bool hb_waiters_pending(struct futex_hash_bucket *hb)
+{
+#ifdef CONFIG_SMP
+	/*
+	 * Tasks trying to enter the critical region are most likely
+	 * potential waiters that will be added to the plist. Ensure
+	 * that wakers won't miss to-be-slept tasks in the window between
+	 * the wait call and the actual plist_add.
+	 */
+	if (spin_is_locked(&hb->lock))
+		return true;
+	smp_rmb(); /* Make sure we check the lock state first */
+
+	return !plist_head_empty(&hb->chain);
+#else
+	return true;
+#endif
+}
 
 /*
  * We hash on the keys returned from get_futex_key (see below).
@@ -160,7 +193,7 @@
 	u32 hash = jhash2((u32*)&key->both.word,
 			  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,
 			  key->both.offset);
-	return &futex_queues[hash & ((1 << FUTEX_HASHBITS)-1)];
+	return &futex_queues[hash & (futex_hashsize - 1)];
 }
 
 /*
@@ -186,10 +219,10 @@
 
 	switch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {
 	case FUT_OFF_INODE:
-		ihold(key->shared.inode);
+		ihold(key->shared.inode); /* implies MB (B) */
 		break;
 	case FUT_OFF_MMSHARED:
-		atomic_inc(&key->private.mm->mm_count);
+		futex_get_mm(key); /* implies MB (B) */
 		break;
 	}
 }
@@ -263,7 +296,7 @@
 			return -EFAULT;
 		key->private.mm = mm;
 		key->private.address = address;
-		get_futex_key_refs(key);
+		get_futex_key_refs(key);  /* implies MB (B) */
 		return 0;
 	}
 
@@ -288,7 +321,7 @@
 		put_page(page);
 		/* serialize against __split_huge_page_splitting() */
 		local_irq_disable();
-		if (likely(__get_user_pages_fast(address, 1, !ro, &page) == 1)) {
+		if (likely(__get_user_pages_fast(address, 1, 1, &page) == 1)) {
 			page_head = compound_head(page);
 			/*
 			 * page_head is valid pointer but we must pin
@@ -367,7 +400,7 @@
 	} else {
 		key->both.offset |= FUT_OFF_INODE; /* inode-based key */
 		key->shared.inode = page_head->mapping->host;
-		key->shared.pgoff = basepage_index(page);
+		key->shared.pgoff = page_head->index;
 	}
 
 	get_futex_key_refs(key);
@@ -652,13 +685,10 @@
 {
 	struct futex_pi_state *pi_state = NULL;
 	struct futex_q *this, *next;
-	struct plist_head *head;
 	struct task_struct *p;
 	pid_t pid = uval & FUTEX_TID_MASK;
 
-	head = &hb->chain;
-
-	plist_for_each_entry_safe(this, next, head, list) {
+	plist_for_each_entry_safe(this, next, &hb->chain, list) {
 		if (match_futex(&this->key, key)) {
 			/*
 			 * Sanity check the waiter before increasing
@@ -820,7 +850,7 @@
 				struct futex_pi_state **ps,
 				struct task_struct *task, int set_waiters)
 {
-	int lock_taken, ret, force_take = 0;
+	int lock_taken, ret, ownerdied = 0;
 	u32 uval, newval, curval, vpid = task_pid_vnr(task);
 
 retry:
@@ -867,15 +897,17 @@
 	newval = curval | FUTEX_WAITERS;
 
 	/*
-	 * Should we force take the futex? See below.
-	 */
-	if (unlikely(force_take)) {
-		/*
-		 * Keep the OWNER_DIED and the WAITERS bit and set the
-		 * new TID value.
+	 * There are two cases, where a futex might have no owner (the
+	 * owner TID is 0): OWNER_DIED. We take over the futex in this
+	 * case. We also do an unconditional take over, when the owner
+	 * of the futex died.
+	 *
+	 * This is safe as we are protected by the hash bucket lock !
 		 */
+	if (unlikely(ownerdied || !(curval & FUTEX_TID_MASK))) {
+		/* Keep the OWNER_DIED bit */
 		newval = (curval & ~FUTEX_TID_MASK) | vpid;
-		force_take = 0;
+		ownerdied = 0;
 		lock_taken = 1;
 	}
 
@@ -885,7 +917,7 @@
 		goto retry;
 
 	/*
-	 * We took the lock due to forced take over.
+	 * We took the lock due to owner died take over.
 	 */
 	if (unlikely(lock_taken))
 		return 1;
@@ -900,25 +932,20 @@
 		switch (ret) {
 		case -ESRCH:
 			/*
-			 * We failed to find an owner for this
-			 * futex. So we have no pi_state to block
-			 * on. This can happen in two cases:
-			 *
-			 * 1) The owner died
-			 * 2) A stale FUTEX_WAITERS bit
-			 *
-			 * Re-read the futex value.
+			 * No owner found for this futex. Check if the
+			 * OWNER_DIED bit is set to figure out whether
+			 * this is a robust futex or not.
 			 */
 			if (get_futex_value_locked(&curval, uaddr))
 				return -EFAULT;
 
 			/*
-			 * If the owner died or we have a stale
-			 * WAITERS bit the owner TID in the user space
-			 * futex is 0.
+			 * We simply start over in case of a robust
+			 * futex. The code above will take the futex
+			 * and return happy.
 			 */
-			if (!(curval & FUTEX_TID_MASK)) {
-				force_take = 1;
+			if (curval & FUTEX_OWNER_DIED) {
+				ownerdied = 1;
 				goto retry;
 			}
 		default:
@@ -955,9 +982,6 @@
 {
 	struct task_struct *p = q->task;
 
-	if (WARN(q->pi_state || q->rt_waiter, "refusing to wake PI futex\n"))
-		return;
-
 	/*
 	 * We set q->lock_ptr = NULL _before_ we wake up the task. If
 	 * a non-futex wake up happens on another CPU then the task
@@ -1090,7 +1114,6 @@
 {
 	struct futex_hash_bucket *hb;
 	struct futex_q *this, *next;
-	struct plist_head *head;
 	union futex_key key = FUTEX_KEY_INIT;
 	int ret;
 
@@ -1102,10 +1125,14 @@
 		goto out;
 
 	hb = hash_futex(&key);
+
+	/* Make sure we really have tasks to wakeup */
+	if (!hb_waiters_pending(hb))
+		goto out_put_key;
+
 	spin_lock(&hb->lock);
-	head = &hb->chain;
 
-	plist_for_each_entry_safe(this, next, head, list) {
+	plist_for_each_entry_safe(this, next, &hb->chain, list) {
 		if (match_futex (&this->key, &key)) {
 			if (this->pi_state || this->rt_waiter) {
 				ret = -EINVAL;
@@ -1123,6 +1150,7 @@
 	}
 
 	spin_unlock(&hb->lock);
+out_put_key:
 	put_futex_key(&key);
 out:
 	return ret;
@@ -1138,7 +1166,6 @@
 {
 	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
 	struct futex_hash_bucket *hb1, *hb2;
-	struct plist_head *head;
 	struct futex_q *this, *next;
 	int ret, op_ret;
 
@@ -1186,14 +1213,8 @@
 		goto retry;
 	}
 
-	head = &hb1->chain;
-
-	plist_for_each_entry_safe(this, next, head, list) {
+	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
 		if (match_futex (&this->key, &key1)) {
-			if (this->pi_state || this->rt_waiter) {
-				ret = -EINVAL;
-				goto out_unlock;
-			}
 			wake_futex(this);
 			if (++ret >= nr_wake)
 				break;
@@ -1201,15 +1222,9 @@
 	}
 
 	if (op_ret > 0) {
-		head = &hb2->chain;
-
 		op_ret = 0;
-		plist_for_each_entry_safe(this, next, head, list) {
+		plist_for_each_entry_safe(this, next, &hb2->chain, list) {
 			if (match_futex (&this->key, &key2)) {
-				if (this->pi_state || this->rt_waiter) {
-					ret = -EINVAL;
-					goto out_unlock;
-				}
 				wake_futex(this);
 				if (++op_ret >= nr_wake2)
 					break;
@@ -1218,7 +1233,6 @@
 		ret += op_ret;
 	}
 
-out_unlock:
 	double_unlock_hb(hb1, hb2);
 out_put_keys:
 	put_futex_key(&key2);
@@ -1376,7 +1390,6 @@
 	int drop_count = 0, task_count = 0, ret;
 	struct futex_pi_state *pi_state = NULL;
 	struct futex_hash_bucket *hb1, *hb2;
-	struct plist_head *head1;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
@@ -1518,8 +1531,7 @@
 		}
 	}
 
-	head1 = &hb1->chain;
-	plist_for_each_entry_safe(this, next, head1, list) {
+	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
 		if (task_count - nr_wake >= nr_requeue)
 			break;
 
@@ -1529,13 +1541,9 @@
 		/*
 		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
 		 * be paired with each other and no other futex ops.
-		 *
-		 * We should never be requeueing a futex_q with a pi_state,
-		 * which is awaiting a futex_unlock_pi().
 		 */
 		if ((requeue_pi && !this->rt_waiter) ||
-		    (!requeue_pi && this->rt_waiter) ||
-		    this->pi_state) {
+		    (!requeue_pi && this->rt_waiter)) {
 			ret = -EINVAL;
 			break;
 		}
@@ -1613,12 +1621,12 @@
 	hb = hash_futex(&q->key);
 	q->lock_ptr = &hb->lock;
 
-	spin_lock(&hb->lock);
+	spin_lock(&hb->lock); /* implies MB (A) */
 	return hb;
 }
 
 static inline void
-queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)
+queue_unlock(struct futex_hash_bucket *hb)
 	__releases(&hb->lock)
 {
 	spin_unlock(&hb->lock);
@@ -1991,7 +1999,7 @@
 	ret = get_futex_value_locked(&uval, uaddr);
 
 	if (ret) {
-		queue_unlock(q, *hb);
+		queue_unlock(*hb);
 
 		ret = get_user(uval, uaddr);
 		if (ret)
@@ -2005,7 +2013,7 @@
 	}
 
 	if (uval != val) {
-		queue_unlock(q, *hb);
+		queue_unlock(*hb);
 		ret = -EWOULDBLOCK;
 	}
 
@@ -2153,7 +2161,7 @@
 			 * Task is exiting and we just wait for the
 			 * exit to complete.
 			 */
-			queue_unlock(&q, hb);
+			queue_unlock(hb);
 			put_futex_key(&q.key);
 			cond_resched();
 			goto retry;
@@ -2205,7 +2213,7 @@
 	goto out_put_key;
 
 out_unlock_put_key:
-	queue_unlock(&q, hb);
+	queue_unlock(hb);
 
 out_put_key:
 	put_futex_key(&q.key);
@@ -2215,7 +2223,7 @@
 	return ret != -EINTR ? ret : -ERESTARTNOINTR;
 
 uaddr_faulted:
-	queue_unlock(&q, hb);
+	queue_unlock(hb);
 
 	ret = fault_in_user_writeable(uaddr);
 	if (ret)
@@ -2237,7 +2245,6 @@
 {
 	struct futex_hash_bucket *hb;
 	struct futex_q *this, *next;
-	struct plist_head *head;
 	union futex_key key = FUTEX_KEY_INIT;
 	u32 uval, vpid = task_pid_vnr(current);
 	int ret;
@@ -2278,9 +2285,7 @@
 	 * Ok, other tasks may need to be woken up - check waiters
 	 * and do the wakeup if necessary:
 	 */
-	head = &hb->chain;
-
-	plist_for_each_entry_safe(this, next, head, list) {
+	plist_for_each_entry_safe(this, next, &hb->chain, list) {
 		if (!match_futex (&this->key, &key))
 			continue;
 		ret = wake_futex_pi(uaddr, uval, this);
@@ -2378,11 +2383,11 @@
  * @uaddr2:	the pi futex we will take prior to returning to user-space
  *
  * The caller will wait on uaddr and will be requeued by futex_requeue() to
- * uaddr2 which must be PI aware and unique from uaddr.  Normal wakeup will wake
- * on uaddr2 and complete the acquisition of the rt_mutex prior to returning to
- * userspace.  This ensures the rt_mutex maintains an owner when it has waiters;
- * without one, the pi logic would not know which task to boost/deboost, if
- * there was a need to.
+ * uaddr2 which must be PI aware.  Normal wakeup will wake on uaddr2 and
+ * complete the acquisition of the rt_mutex prior to returning to userspace.
+ * This ensures the rt_mutex maintains an owner when it has waiters; without
+ * one, the pi logic wouldn't know which task to boost/deboost, if there was a
+ * need to.
  *
  * We call schedule in futex_wait_queue_me() when we enqueue and return there
  * via the following:
@@ -2419,9 +2424,6 @@
 	struct futex_q q = futex_q_init;
 	int res, ret;
 
-	if (uaddr == uaddr2)
-		return -EINVAL;
-
 	if (!bitset)
 		return -EINVAL;
 
@@ -2463,7 +2465,7 @@
 	 * shared futexes. We need to compare the keys:
 	 */
 	if (match_futex(&q.key, &key2)) {
-		queue_unlock(&q, hb);
+		queue_unlock(hb);
 		ret = -EINVAL;
 		goto out_put_keys;
 	}
@@ -2503,7 +2505,7 @@
 		 * signal.  futex_unlock_pi() will not destroy the lock_ptr nor
 		 * the pi_state.
 		 */
-		WARN_ON(!q.pi_state);
+		WARN_ON(!&q.pi_state);
 		pi_mutex = &q.pi_state->pi_mutex;
 		ret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);
 		debug_rt_mutex_free_waiter(&rt_waiter);
@@ -2530,7 +2532,7 @@
 	 * fault, unlock the rt_mutex and return the fault to userspace.
 	 */
 	if (ret == -EFAULT) {
-		if (pi_mutex && rt_mutex_owner(pi_mutex) == current)
+		if (rt_mutex_owner(pi_mutex) == current)
 			rt_mutex_unlock(pi_mutex);
 	} else if (ret == -EINTR) {
 		/*
@@ -2609,6 +2611,8 @@
 	if (!futex_cmpxchg_enabled)
 		return -ENOSYS;
 
+	WARN_ONCE(1, "deprecated: get_robust_list will be deleted in 2013.\n");
+
 	rcu_read_lock();
 
 	ret = -ESRCH;
@@ -2868,7 +2872,18 @@
 static int __init futex_init(void)
 {
 	u32 curval;
-	int i;
+	unsigned long i;
+
+#if CONFIG_BASE_SMALL
+	futex_hashsize = 16;
+#else
+	futex_hashsize = roundup_pow_of_two(256 * num_possible_cpus());
+#endif
+
+	futex_queues = alloc_large_system_hash("futex", sizeof(*futex_queues),
+					       futex_hashsize, 0,
+					       futex_hashsize < 256 ? HASH_SMALL : 0,
+					       NULL, NULL, futex_hashsize);
 
 	/*
 	 * This will fail and we want it. Some arch implementations do
@@ -2883,7 +2898,7 @@
 	if (cmpxchg_futex_value_locked(&curval, NULL, 0, 0) == -EFAULT)
 		futex_cmpxchg_enabled = 1;
 
-	for (i = 0; i < ARRAY_SIZE(futex_queues); i++) {
+	for (i = 0; i < futex_hashsize; i++) {
 		plist_head_init(&futex_queues[i].chain);
 		spin_lock_init(&futex_queues[i].lock);
 	}
Only in tuned-kernel-LOS-s5/kernel: futex.c.orig
diff -ruBb android_kernel_samsung_msm8974/kernel/Makefile tuned-kernel-LOS-s5/kernel/Makefile
--- android_kernel_samsung_msm8974/kernel/Makefile	2018-03-05 17:54:36.783677147 -0300
+++ tuned-kernel-LOS-s5/kernel/Makefile	2017-11-29 13:27:54.466221881 -0300
@@ -2,7 +2,7 @@
 # Makefile for the linux kernel.
 #
 
-obj-y     = fork.o exec_domain.o panic.o printk.o \
+obj-y     = fork.o exec_domain.o panic.o printk.o printk_interface.o \
 	    cpu.o exit.o itimer.o time.o softirq.o resource.o \
 	    sysctl.o sysctl_binary.o capability.o ptrace.o timer.o user.o \
 	    signal.o sys.o kmod.o workqueue.o pid.o \
diff -ruBb android_kernel_samsung_msm8974/kernel/printk.c tuned-kernel-LOS-s5/kernel/printk.c
--- android_kernel_samsung_msm8974/kernel/printk.c	2018-03-05 17:54:36.803677266 -0300
+++ tuned-kernel-LOS-s5/kernel/printk.c	2017-10-20 13:09:54.691782852 -0300
@@ -41,6 +41,7 @@
 #include <linux/cpu.h>
 #include <linux/notifier.h>
 #include <linux/rculist.h>
+#include "printk_interface.h"
 
 #include <asm/uaccess.h>
 #ifdef CONFIG_SEC_DEBUG
@@ -1021,12 +1022,17 @@
 {
 	va_list args;
 	int r;
+
 #ifdef CONFIG_MSM_RTB
 	void *caller = __builtin_return_address(0);
 
 	uncached_logk_pc(LOGK_LOGBUF, caller, (void *)log_end);
 #endif
 
+	// if printk mode is disabled, terminate instantly
+	if (printk_mode == 0)
+		return 0;
+
 #ifdef CONFIG_KGDB_KDB
 	if (unlikely(kdb_trap_printk)) {
 		va_start(args, fmt);
@@ -1124,6 +1130,10 @@
 	size_t plen;
 	char special;
 
+	// if printk mode is disabled, terminate instantly
+	if (printk_mode == 0)
+			return 0;
+
 	boot_delay_msec();
 	printk_delay();
 
Only in tuned-kernel-LOS-s5/kernel: printk_interface.c
Only in tuned-kernel-LOS-s5/kernel: printk_interface.h
diff -ruBb android_kernel_samsung_msm8974/kernel/sched/core.c tuned-kernel-LOS-s5/kernel/sched/core.c
--- android_kernel_samsung_msm8974/kernel/sched/core.c	2018-03-05 17:54:36.807677290 -0300
+++ tuned-kernel-LOS-s5/kernel/sched/core.c	2017-11-29 11:58:54.264506376 -0300
@@ -2163,6 +2163,32 @@
 	finish_task_switch(this_rq(), prev);
 }
 
+unsigned long avg_nr_running(void)
+{
+       unsigned long i, sum = 0;
+       unsigned int seqcnt, ave_nr_running;
+
+       for_each_online_cpu(i) {
+               struct rq *q = cpu_rq(i);
+
+               /*
+                * Update average to avoid reading stalled value if there were
+                * no run-queue changes for a long time. On the other hand if
+                * the changes are happening right now, just read current value
+                * directly.
+                */
+               seqcnt = read_seqcount_begin(&q->ave_seqcnt);
+               ave_nr_running = do_avg_nr_running(q);
+               if (read_seqcount_retry(&q->ave_seqcnt, seqcnt)) {
+                       read_seqcount_begin(&q->ave_seqcnt);
+                       ave_nr_running = q->ave_nr_running;
+               }
+
+               sum += ave_nr_running;
+       }
+       return sum;
+}
+
 /*
  * nr_running, nr_uninterruptible and nr_context_switches:
  *
diff -ruBb android_kernel_samsung_msm8974/kernel/sched/fair.c tuned-kernel-LOS-s5/kernel/sched/fair.c
--- android_kernel_samsung_msm8974/kernel/sched/fair.c	2018-03-05 17:54:36.811677313 -0300
+++ tuned-kernel-LOS-s5/kernel/sched/fair.c	2017-11-28 19:05:06.583530881 -0300
@@ -95,7 +95,7 @@
 unsigned int sysctl_sched_wakeup_granularity = 1000000UL;
 unsigned int normalized_sysctl_sched_wakeup_granularity = 1000000UL;
 
-const_debug unsigned int sysctl_sched_migration_cost = 500000UL;
+const_debug unsigned int sysctl_sched_migration_cost = 1500000UL;
 
 /*
  * The exponential sliding  window over which load is averaged for shares
diff -ruBb android_kernel_samsung_msm8974/kernel/sysctl.c tuned-kernel-LOS-s5/kernel/sysctl.c
--- android_kernel_samsung_msm8974/kernel/sysctl.c	2018-03-05 17:54:36.815677338 -0300
+++ tuned-kernel-LOS-s5/kernel/sysctl.c	2017-11-30 23:34:05.467835103 -0300
@@ -121,6 +121,8 @@
 #ifdef CONFIG_LOCKUP_DETECTOR
 static int sixty = 60;
 static int neg_one = -1;
+#else
+static int sixty = 60;
 #endif
 
 static int zero;
@@ -129,9 +131,9 @@
 static int __maybe_unused three = 3;
 static unsigned long one_ul = 1;
 static int one_hundred = 100;
-#ifdef CONFIG_INCREASE_MAXIMUM_SWAPPINESS
+//#ifdef CONFIG_INCREASE_MAXIMUM_SWAPPINESS
 extern int max_swappiness;
-#endif
+//#endif
 #ifdef CONFIG_PRINTK
 static int ten_thousand = 10000;
 #endif
@@ -1080,7 +1082,7 @@
 		.procname	= "page-cluster", 
 		.data		= &page_cluster,
 		.maxlen		= sizeof(int),
-		.mode		= 0644,
+		.mode		= 0444,
 		.proc_handler	= proc_dointvec_minmax,
 		.extra1		= &zero,
 	},
@@ -1146,11 +1148,12 @@
 		.maxlen		= sizeof(vm_swappiness),
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= &zero,
 #ifdef CONFIG_INCREASE_MAXIMUM_SWAPPINESS
+		.extra1		= &max_swappiness,
 		.extra2		= &max_swappiness,
 #else
-		.extra2		= &one_hundred,
+                .extra1         = &zero,
+		.extra2		= &sixty,
 #endif
 	},
 #ifdef CONFIG_HUGETLB_PAGE
diff -ruBb android_kernel_samsung_msm8974/lib/int_sqrt.c tuned-kernel-LOS-s5/lib/int_sqrt.c
--- android_kernel_samsung_msm8974/lib/int_sqrt.c	2018-03-05 17:54:36.839677480 -0300
+++ tuned-kernel-LOS-s5/lib/int_sqrt.c	2017-11-23 23:34:11.849604347 -0300
@@ -1,3 +1,9 @@
+/*
+ * Copyright (C) 2013 Davidlohr Bueso <davidlohr.bueso@hp.com>
+ *
+ *  Based on the shift-and-subtract algorithm for computing integer
+ *  square root from Guy L. Steele.
+ */
 
 #include <linux/kernel.h>
 #include <linux/export.h>
@@ -10,23 +16,23 @@
  */
 unsigned long int_sqrt(unsigned long x)
 {
-	unsigned long op, res, one;
+	unsigned long b, m, y = 0;
 
-	op = x;
-	res = 0;
+	if (x <= 1)
+		return x;
 
-	one = 1UL << (BITS_PER_LONG - 2);
-	while (one > op)
-		one >>= 2;
-
-	while (one != 0) {
-		if (op >= res + one) {
-			op = op - (res + one);
-			res = res +  2 * one;
+	m = 1UL << (BITS_PER_LONG - 2);
+	while (m != 0) {
+		b = y + m;
+		y >>= 1;
+
+		if (x >= b) {
+			x -= b;
+			y += m;
 		}
-		res /= 2;
-		one /= 4;
+		m >>= 2;
 	}
-	return res;
+
+	return y;
 }
 EXPORT_SYMBOL(int_sqrt);
diff -ruBb android_kernel_samsung_msm8974/lib/lz4/lz4defs.h tuned-kernel-LOS-s5/lib/lz4/lz4defs.h
--- android_kernel_samsung_msm8974/lib/lz4/lz4defs.h	2018-03-05 17:54:36.847677527 -0300
+++ tuned-kernel-LOS-s5/lib/lz4/lz4defs.h	2017-11-26 11:54:23.015920017 -0300
@@ -21,6 +21,7 @@
 /*
  * Architecture-specific macros
  */
+#define ARM_EFFICIENT_UNALIGNED_ACCESS
 #define BYTE	u8
 typedef struct _U16_S { u16 v; } U16_S;
 typedef struct _U32_S { u32 v; } U32_S;
diff -ruBb android_kernel_samsung_msm8974/Makefile tuned-kernel-LOS-s5/Makefile
--- android_kernel_samsung_msm8974/Makefile	2018-03-05 17:54:31.751647221 -0300
+++ tuned-kernel-LOS-s5/Makefile	2018-02-16 17:41:12.506499630 -0300
@@ -245,8 +245,8 @@
 
 HOSTCC       = gcc
 HOSTCXX      = g++
-HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
-HOSTCXXFLAGS = -O2
+HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O3
+HOSTCXXFLAGS = -O3
 
 # Decide whether to build built-in, modular, or both.
 # Normally, just do built-in.
@@ -356,13 +356,26 @@
 
 CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
 		  -Wbitwise -Wno-return-void $(CF)
+
+OPTS           = -ffast-math -fsplit-loops \
+		-fmodulo-sched -fmodulo-sched-allow-regmoves \
+		-fsingle-precision-constant -ftree-partial-pre -fpredictive-commoning \
+		-ftree-vectorize -fvect-cost-model=cheap -ftree-loop-ivcanon \
+		-fgcse-sm -fgcse-las -fira-hoist-pressure -fivopts -fgcse-after-reload -ftree-loop-distribute-patterns \
+		-fsched-spec-load -fweb -frename-registers -fipa-pta -ftree-loop-im -fsection-anchors -funsafe-loop-optimizations \
+		-frerun-cse-after-loop -ftracer -floop-unroll-and-jam
+
+GCC6WARNINGS   = -Wno-bool-compare -Wno-misleading-indentation -Wno-format -Wno-strict-aliasing -Wno-tautological-compare -Wno-discarded-array-qualifiers
+GCC7WARNINGS   = $(GCC6WARNINGS) -Wno-int-in-bool-context -Wno-memset-elt-size -Wno-parentheses -Wno-bool-operation -Wno-duplicate-decl-specifier -Wno-stringop-overflow \
+		-Wno-format-overflow -Wno-switch-unreachable -Wno-pointer-compare
+GCC8WARNINGS   = $(GCC7WARNINGS) -Wno-multistatement-macros -Wno-sizeof-pointer-div -Wno-logical-not-parentheses -Wno-packed-not-aligned -Wno-shift-overflow -Wno-switch-bool
+
 CFLAGS_MODULE   =
 AFLAGS_MODULE   =
 LDFLAGS_MODULE  =
-CFLAGS_KERNEL	=
+CFLAGS_KERNEL   = -mfpu=neon-vfpv4
 AFLAGS_KERNEL	=
-CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage
-
+CFLAGS_GCOV    =
 
 # Use LINUXINCLUDE when you must reference the include/ directory.
 # Needed to be compatible with the O= option
@@ -570,7 +583,9 @@
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
 KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)
 else
-KBUILD_CFLAGS	+= -O2
+KBUILD_CFLAGS	+= -O3 $(OPTS) -fno-unswitch-loops -fno-ipa-cp-clone -freorder-blocks-algorithm=simple -fno-prefetch-loop-arrays -fno-inline-functions $(GCC8WARNINGS)
+# -freorder-blocks-algorithm=simple -fno-unswitch-loops -fno-ipa-cp-clone -fno-prefetch-loop-arrays -fno-inline-functions $(GCC8WARNINGS)
+#$(OPTS) -fno-inline-functions $(GCC8WARNINGS)
 endif
 
 include $(srctree)/arch/$(SRCARCH)/Makefile
@@ -601,6 +616,23 @@
 endif
 endif
 
+# These flags need a special toolchain so split them off
+
+KBUILD_CFLAGS  += $(call cc-option,-mlow-precision-recip-sqrt,) \
+                  $(call cc-option,-mpc-relative-literal-loads,)
+
+
+# Disable format-truncation warnings
+KBUILD_CFLAGS   += $(call cc-disable-warning,format-truncation,)
+
+
+# Needed to unbreak GCC 7.x and above
+###KBUILD_CFLAGS   += $(call cc-option,-fno-store-merging,)
+
+
+# Tell gcc to never replace conditional load with a non-conditional one
+KBUILD_CFLAGS  += $(call cc-option,--param=allow-store-data-races=0)
+
 KBUILD_CFLAGS   += $(call cc-option, -fno-var-tracking-assignments)
 
 ifdef CONFIG_DEBUG_INFO
  * try_to_compact_pages - Direct compact to satisfy a high-order allocation
diff -ruBb android_kernel_samsung_msm8974/mm/mmap.c tuned-kernel-LOS-s5/mm/mmap.c
--- android_kernel_samsung_msm8974/mm/mmap.c	2018-03-05 17:54:36.895677813 -0300
+++ tuned-kernel-LOS-s5/mm/mmap.c	2017-11-29 13:27:53.898221881 -0300
@@ -31,6 +31,7 @@
 #include <linux/perf_event.h>
 #include <linux/audit.h>
 #include <linux/khugepaged.h>
+#include <linux/uprobes.h>
 
 #include <asm/uaccess.h>
 #include <asm/cacheflush.h>
@@ -663,6 +664,13 @@
 	if (mapping)
 		mutex_unlock(&mapping->i_mmap_mutex);
 
+	if (root) {
+		uprobe_mmap(vma);
+
+		if (adjust_next)
+			uprobe_mmap(next);
+	}
+
 	if (remove_next) {
 		if (file) {
 			fput(file);
@@ -684,6 +692,8 @@
 			goto again;
 		}
 	}
+	if (insert && file)
+		uprobe_mmap(insert);
 
 	validate_mm(mm);
 
@@ -1478,6 +1488,11 @@
 			mm->locked_vm += (len >> PAGE_SHIFT);
 	} else if ((flags & MAP_POPULATE) && !(flags & MAP_NONBLOCK))
 		make_pages_present(addr, addr + len);
+
+	if (file && uprobe_mmap(vma))
+		/* matching probes but cannot insert */
+		goto unmap_and_free_vma;
+
 	return addr;
 
 unmap_and_free_vma:
@@ -2545,6 +2560,10 @@
 	if ((vma->vm_flags & VM_ACCOUNT) &&
 	     security_vm_enough_memory_mm(mm, vma_pages(vma)))
 		return -ENOMEM;
+
+	if (vma->vm_file && uprobe_mmap(vma))
+		return -EINVAL;
+
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 	return 0;
 }
@@ -2615,6 +2634,10 @@
 			new_vma->vm_pgoff = pgoff;
 			if (new_vma->vm_file) {
 				get_file(new_vma->vm_file);
+
+				if (uprobe_mmap(new_vma))
+					goto out_free_mempol;
+
 				if (vma->vm_flags & VM_EXECUTABLE)
 					added_exe_file_vma(mm);
 			}
diff -ruBb android_kernel_samsung_msm8974/mm/mmzone.c tuned-kernel-LOS-s5/mm/mmzone.c
--- android_kernel_samsung_msm8974/mm/mmzone.c	2018-03-05 17:54:36.895677813 -0300
+++ tuned-kernel-LOS-s5/mm/mmzone.c	2017-10-20 13:09:54.779783736 -0300
@@ -8,6 +8,10 @@
 #include <linux/stddef.h>
 #include <linux/mm.h>
 #include <linux/mmzone.h>
+#include <linux/module.h>
+
+EXPORT_SYMBOL(is_cma_pageblock);
+
 
 struct pglist_data *first_online_pgdat(void)
 {
diff -ruBb android_kernel_samsung_msm8974/mm/page-writeback.c tuned-kernel-LOS-s5/mm/page-writeback.c
--- android_kernel_samsung_msm8974/mm/page-writeback.c	2018-03-05 17:54:36.903677861 -0300
+++ tuned-kernel-LOS-s5/mm/page-writeback.c	2017-11-23 23:47:52.858068372 -0300
@@ -42,7 +42,7 @@
 /*
  * Sleep at most 200ms at a time in balance_dirty_pages().
  */
-#define MAX_PAUSE		max(HZ/5, 1)
+#define MAX_PAUSE		200
 
 /*
  * Try to keep balance_dirty_pages() call intervals higher than this many pages
@@ -53,7 +53,7 @@
 /*
  * Estimate write bandwidth at 200ms intervals.
  */
-#define BANDWIDTH_INTERVAL	max(HZ/5, 1)
+#define BANDWIDTH_INTERVAL	200
 
 #define RATELIMIT_CALC_SHIFT	10
 
@@ -68,7 +68,7 @@
 /*
  * Start background writeback (via writeback threads) at this percentage
  */
-int dirty_background_ratio = 10;
+int dirty_background_ratio = 5;
 
 /*
  * dirty_background_bytes starts at 0 (disabled) so that it is a function of
@@ -85,7 +85,7 @@
 /*
  * The generator of dirty data starts writeback at this percentage
  */
-int vm_dirty_ratio = 20;
+int vm_dirty_ratio = 10;
 
 /*
  * vm_dirty_bytes starts at 0 (disabled) so that it is a function of
@@ -96,14 +96,14 @@
 /*
  * The interval between `kupdate'-style writebacks
  */
-unsigned int dirty_writeback_interval = 5 * 100; /* centiseconds */
+unsigned int dirty_writeback_interval = 60 * 100; /* centiseconds */
 
 EXPORT_SYMBOL_GPL(dirty_writeback_interval);
 
 /*
  * The longest time for which data is allowed to remain dirty
  */
-unsigned int dirty_expire_interval = 30 * 100; /* centiseconds */
+unsigned int dirty_expire_interval = 40 * 100; /* centiseconds */
 
 /*
  * Flag that makes the machine dump writes/reads and block dirtyings.
@@ -483,7 +483,7 @@
  * registered backing devices, which, for obvious reasons, can not
  * exceed 100%.
  */
-static unsigned int bdi_min_ratio;
+static unsigned int bdi_min_ratio = 5;
 
 int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)
 {
@@ -1610,10 +1610,16 @@
 }
 
 static int __cpuinit
-ratelimit_handler(struct notifier_block *self, unsigned long u, void *v)
+ratelimit_handler(struct notifier_block *self, unsigned long action, void *hcpu)
 {
+	switch (action & ~CPU_TASKS_FROZEN) {
+		case CPU_ONLINE:
+		case CPU_DEAD:
 	writeback_set_ratelimit();
+			return NOTIFY_OK;
+		default:
 	return NOTIFY_DONE;
+	}
 }
 
 static struct notifier_block __cpuinitdata ratelimit_nb = {
diff -ruBb android_kernel_samsung_msm8974/mm/rmap.c tuned-kernel-LOS-s5/mm/rmap.c
--- android_kernel_samsung_msm8974/mm/rmap.c	2018-03-05 17:54:36.915677932 -0300
+++ tuned-kernel-LOS-s5/mm/rmap.c	2017-11-08 18:42:07.863382628 -0300
@@ -613,7 +613,7 @@
  * Returns virtual address or -EFAULT if page's index/offset is not
  * within the range mapped the @vma.
  */
-inline unsigned long
+static inline unsigned long
 vma_address(struct page *page, struct vm_area_struct *vma)
 {
 	pgoff_t pgoff = page->index << (PAGE_CACHE_SHIFT - PAGE_SHIFT);
diff -ruBb android_kernel_samsung_msm8974/mm/swap.c tuned-kernel-LOS-s5/mm/swap.c
--- android_kernel_samsung_msm8974/mm/swap.c	2018-03-05 17:54:36.923677980 -0300
+++ tuned-kernel-LOS-s5/mm/swap.c	2017-11-30 23:36:22.704644340 -0300
@@ -35,7 +35,7 @@
 #include "internal.h"
 
 /* How many pages do we try to swap or page in/out together? */
-int page_cluster;
+int page_cluster = 8;
 
 static DEFINE_PER_CPU(struct pagevec[NR_LRU_LISTS], lru_add_pvecs);
 static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);
diff -ruBb android_kernel_samsung_msm8974/mm/vmscan.c tuned-kernel-LOS-s5/mm/vmscan.c
--- android_kernel_samsung_msm8974/mm/vmscan.c	2018-03-05 17:54:36.931678027 -0300
+++ tuned-kernel-LOS-s5/mm/vmscan.c	2017-11-14 12:34:40.249793506 -0300
@@ -153,7 +153,7 @@
 /*
  * From 0 .. 100.  Higher means more swappy.
  */
-int vm_swappiness = 60;
+int vm_swappiness = 20;
 long vm_total_pages;	/* The total number of pages which the VM controls */
 
 #ifdef CONFIG_RUNTIME_COMPCACHE
@@ -1361,9 +1361,11 @@
 		add_page_to_lru_list(zone, page, lru);
 
 		file = is_file_lru(lru);
+#ifdef CONFIG_ZCACHE
 		if (IS_ENABLED(CONFIG_ZCACHE))
 			if (file)
 				SetPageWasActive(page);
+#endif
 		if (is_active_lru(lru)) {
 			int numpages = hpage_nr_pages(page);
 			reclaim_stat->recent_rotated[file] += numpages;
@@ -1660,12 +1662,14 @@
 		}
 
 		ClearPageActive(page);	/* we are de-activating */
+#ifdef CONFIG_ZCACHE
 		if (IS_ENABLED(CONFIG_ZCACHE))
 			/*
 			 * For zcache to know whether the page is from active
 			 * file list
 			 */
 			SetPageWasActive(page);
+#endif
 		list_add(&page->lru, &l_inactive);
 	}
 
diff -ruBb android_kernel_samsung_msm8974/net/core/net-sysfs.c tuned-kernel-LOS-s5/net/core/net-sysfs.c
--- android_kernel_samsung_msm8974/net/core/net-sysfs.c	2018-03-05 17:54:37.011678503 -0300
+++ tuned-kernel-LOS-s5/net/core/net-sysfs.c	2017-11-08 20:40:13.187798550 -0300
@@ -28,7 +28,7 @@
 
 #ifdef CONFIG_SYSFS
 static const char fmt_hex[] = "%#x\n";
-static const char fmt_long_hex[] = "%#lx\n";
+//static const char fmt_long_hex[] = "%#lx\n";
 static const char fmt_dec[] = "%d\n";
 static const char fmt_udec[] = "%u\n";
 static const char fmt_ulong[] = "%lu\n";
diff -ruBb android_kernel_samsung_msm8974/net/ipv4/arp.c tuned-kernel-LOS-s5/net/ipv4/arp.c
--- android_kernel_samsung_msm8974/net/ipv4/arp.c	2018-03-05 17:54:37.071678860 -0300
+++ tuned-kernel-LOS-s5/net/ipv4/arp.c	2017-11-08 18:26:39.000751661 -0300
@@ -147,7 +147,7 @@
 	.output =		neigh_direct_output,
 	.connected_output =	neigh_direct_output,
 };
-
+/*
 static const struct neigh_ops arp_broken_ops = {
 	.family =		AF_INET,
 	.solicit =		arp_solicit,
@@ -155,7 +155,7 @@
 	.output =		neigh_compat_output,
 	.connected_output =	neigh_compat_output,
 };
-
+*/
 struct neigh_table arp_tbl = {
 	.family		= AF_INET,
 	.key_len	= 4,
diff -ruBb android_kernel_samsung_msm8974/net/ipv4/tcp_output.c tuned-kernel-LOS-s5/net/ipv4/tcp_output.c
--- android_kernel_samsung_msm8974/net/ipv4/tcp_output.c	2018-03-05 17:54:37.135679241 -0300
+++ tuned-kernel-LOS-s5/net/ipv4/tcp_output.c	2017-10-20 13:09:54.915785100 -0300
@@ -245,6 +245,9 @@
 			*rcv_wnd = min(*rcv_wnd, init_cwnd * mss);
 	}
 
+	/* Lock the initial TCP window size to 64K*/
+	*rcv_wnd = 64240;
+
 	/* Set the clamp no higher than max representable value */
 	(*window_clamp) = min(65535U << (*rcv_wscale), *window_clamp);
 }
diff -ruBb android_kernel_samsung_msm8974/security/selinux/avc.c tuned-kernel-LOS-s5/security/selinux/avc.c
--- android_kernel_samsung_msm8974/security/selinux/avc.c	2018-03-05 17:54:37.499681407 -0300
+++ tuned-kernel-LOS-s5/security/selinux/avc.c	2017-10-20 13:09:55.143787386 -0300
@@ -620,7 +620,7 @@
 	spin_lock_irqsave(&notif_lock, flag);
 	if (is_insert) {
 		if (seqno < avc_cache.latest_notif) {
-			printk(KERN_WARNING "SELinux: avc:  seqno %d < latest_notif %d\n",
+			pr_debug(KERN_WARNING "SELinux: avc:  seqno %d < latest_notif %d\n",
 			       seqno, avc_cache.latest_notif);
 			ret = -EAGAIN;
 		}
diff -ruBb android_kernel_samsung_msm8974/security/selinux/Makefile tuned-kernel-LOS-s5/security/selinux/Makefile
--- android_kernel_samsung_msm8974/security/selinux/Makefile	2018-03-05 17:54:37.499681407 -0300
+++ tuned-kernel-LOS-s5/security/selinux/Makefile	2017-12-29 10:43:57.947236109 -0300
@@ -4,7 +4,7 @@
 
 ifeq ($(SEC_BUILD_OPTION_PRODUCT_SHIP), true)
 ifeq ($(SEC_BUILD_OPTION_SELINUX_ENFORCE),true)
-EXTRA_CFLAGS += -DCONFIG_ALWAYS_ENFORCE=true
+EXTRA_CFLAGS += -DCONFIG_ALWAYS_ENFORCE=false
 endif
 endif
 
Only in tuned-kernel-LOS-s5/sound/soc/codecs: boeffla_sound.c
Only in tuned-kernel-LOS-s5/sound/soc/codecs: boeffla_sound.h
diff -ruBb android_kernel_samsung_msm8974/sound/soc/codecs/Kconfig tuned-kernel-LOS-s5/sound/soc/codecs/Kconfig
--- android_kernel_samsung_msm8974/sound/soc/codecs/Kconfig	2018-03-05 17:54:37.747682882 -0300
+++ tuned-kernel-LOS-s5/sound/soc/codecs/Kconfig	2017-10-20 13:09:55.451790475 -0300
@@ -544,3 +544,10 @@
 	help
 	HDMI audio drivers should be built only if the platform
         supports hdmi panel.
+        
+config BOEFFLA_SOUND
+	bool "Boeffla Sound engine"
+	default y
+	help
+		Boeffla sound engine by andip71 (aka Lord Boeffla)
+		
diff -ruBb android_kernel_samsung_msm8974/sound/soc/codecs/Makefile tuned-kernel-LOS-s5/sound/soc/codecs/Makefile
--- android_kernel_samsung_msm8974/sound/soc/codecs/Makefile	2018-03-05 17:54:37.747682882 -0300
+++ tuned-kernel-LOS-s5/sound/soc/codecs/Makefile	2017-10-20 13:09:55.451790475 -0300
@@ -230,6 +230,7 @@
 obj-$(CONFIG_SND_SOC_WM9713)	+= snd-soc-wm9713.o
 obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
 obj-$(CONFIG_SND_SOC_MSM_STUB)  += snd-soc-msm-stub.o
+obj-$(CONFIG_BOEFFLA_SOUND) 	+= boeffla_sound.o
 
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
diff -ruBb android_kernel_samsung_msm8974/sound/soc/codecs/wcd9320.c tuned-kernel-LOS-s5/sound/soc/codecs/wcd9320.c
--- android_kernel_samsung_msm8974/sound/soc/codecs/wcd9320.c	2018-03-05 17:54:37.827683359 -0300
+++ tuned-kernel-LOS-s5/sound/soc/codecs/wcd9320.c	2017-11-08 21:02:18.113120483 -0300
@@ -42,6 +42,10 @@
 #include "wcd9xxx-common.h"
 #include "wcdcal-hwdep.h"
 
+#ifdef CONFIG_BOEFFLA_SOUND
+#include "boeffla_sound.h"
+#endif
+
 #if defined(CONFIG_SND_SOC_ES705)
 #include "audience/es705-export.h"
 #elif defined(CONFIG_SND_SOC_ES325)
@@ -324,7 +328,7 @@
 static const DECLARE_TLV_DB_SCALE(line_gain, 0, 7, 1);
 static const DECLARE_TLV_DB_SCALE(analog_gain, 0, 25, 1);
 static struct snd_soc_dai_driver taiko_dai[];
-static const DECLARE_TLV_DB_SCALE(aux_pga_gain, 0, 2, 0);
+//static const DECLARE_TLV_DB_SCALE(aux_pga_gain, 0, 2, 0);
 
 /* Codec supports 2 IIR filters */
 enum {
@@ -1112,10 +1116,10 @@
 		SOC_ENUM_SINGLE_EXT(2, taiko_sub_mic_delay_text);
 #endif
 
-static const char *const tabla_ear_pa_gain_text[] = {"POS_6_DB", "POS_2_DB"};
-static const struct soc_enum tabla_ear_pa_gain_enum[] = {
+//static const char *const tabla_ear_pa_gain_text[] = {"POS_6_DB", "POS_2_DB"};
+/*static const struct soc_enum tabla_ear_pa_gain_enum[] = {
 		SOC_ENUM_SINGLE_EXT(2, tabla_ear_pa_gain_text),
-};
+};*/
 
 /*cut of frequency for high pass filter*/
 static const char * const cf_text[] = {
@@ -4302,8 +4306,43 @@
 	return 0;
 }
 
+#ifdef CONFIG_BOEFFLA_SOUND
+int taiko_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+#else
 static int taiko_write(struct snd_soc_codec *codec, unsigned int reg,
 	unsigned int value)
+#endif	
+{
+	int ret;
+	struct wcd9xxx *wcd9xxx = codec->control_data;
+
+	if (reg == SND_SOC_NOPM)
+		return 0;
+
+	BUG_ON(reg > TAIKO_MAX_REGISTER);
+	
+#ifdef CONFIG_BOEFFLA_SOUND
+	// Boeffla Sound write hook
+	value = boeffla_sound_hook_taiko_write(reg, value);
+#endif
+
+	if (!taiko_volatile(codec, reg)) {
+		ret = snd_soc_cache_write(codec, reg, value);
+		if (ret != 0)
+			dev_err(codec->dev, "Cache write to %x failed: %d\n",
+				reg, ret);
+	}
+
+	return wcd9xxx_reg_write(&wcd9xxx->core_res, reg, value);
+}
+#ifdef CONFIG_BOEFFLA_SOUND
+EXPORT_SYMBOL(taiko_write);
+#endif
+
+#ifdef CONFIG_BOEFFLA_SOUND
+int taiko_write_no_hook(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
 {
 	int ret;
 	struct wcd9xxx *wcd9xxx = codec->control_data;
@@ -4322,8 +4361,16 @@
 
 	return wcd9xxx_reg_write(&wcd9xxx->core_res, reg, value);
 }
+EXPORT_SYMBOL(taiko_write_no_hook);
+#endif
+
+#ifdef CONFIG_BOEFFLA_SOUND
+unsigned int taiko_read(struct snd_soc_codec *codec,
+				unsigned int reg)
+#else
 static unsigned int taiko_read(struct snd_soc_codec *codec,
 				unsigned int reg)
+#endif
 {
 	unsigned int val;
 	int ret;
@@ -4348,6 +4395,9 @@
 	val = wcd9xxx_reg_read(&wcd9xxx->core_res, reg);
 	return val;
 }
+#ifdef CONFIG_BOEFFLA_SOUND
+EXPORT_SYMBOL(taiko_read);
+#endif
 
 #ifdef CONFIG_SND_SOC_ES325
 static int taiko_startup(struct snd_pcm_substream *substream,
@@ -7659,6 +7709,12 @@
 	mutex_unlock(&dapm->codec->mutex);
 
 	codec->ignore_pmdown_time = 1;
+	
+#ifdef CONFIG_BOEFFLA_SOUND
+	// Boeffla Sound probe hook
+	boeffla_sound_hook_taiko_codec_probe(codec);
+#endif
+	
 	return ret;
 
 err_irq:
diff -ruBb android_kernel_samsung_msm8974/sound/soc/msm/apq8074.c tuned-kernel-LOS-s5/sound/soc/msm/apq8074.c
--- android_kernel_samsung_msm8974/sound/soc/msm/apq8074.c	2018-03-05 17:54:37.923683930 -0300
+++ tuned-kernel-LOS-s5/sound/soc/msm/apq8074.c	2017-11-10 10:16:38.924752112 -0300
@@ -668,11 +668,11 @@
 					"KHZ_192"};
 static const char *const proxy_rx_ch_text[] = {"One", "Two", "Three", "Four",
 	"Five",	"Six", "Seven", "Eight"};
-
+/*
 static const char *const btsco_rate_text[] = {"8000", "16000"};
 static const struct soc_enum msm_btsco_enum[] = {
 	SOC_ENUM_SINGLE_EXT(2, btsco_rate_text),
-};
+};*/
 
 static int slim0_rx_sample_rate_get(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
@@ -798,7 +798,7 @@
 	pr_debug("%s: msm_slim_0_tx_ch = %d\n", __func__, msm_slim_0_tx_ch);
 	return 1;
 }
-
+/*
 static int msm_btsco_rate_get(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)
 {
@@ -824,7 +824,7 @@
 	pr_debug("%s: msm_btsco_rate = %d\n", __func__, msm_btsco_rate);
 	return 0;
 }
-
+*/
 static int hdmi_rx_bit_format_get(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
@@ -888,12 +888,12 @@
 
 	return 1;
 }
-
+/*
 static const struct snd_kcontrol_new int_btsco_rate_mixer_controls[] = {
 	SOC_ENUM_EXT("Internal BTSCO SampleRate", msm_btsco_enum[0],
 		     msm_btsco_rate_get, msm_btsco_rate_put),
 };
-
+*/
 static int msm_btsco_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
 					struct snd_pcm_hw_params *params)
 {
diff -ruBb android_kernel_samsung_msm8974/sound/soc/msm/msm8974.c tuned-kernel-LOS-s5/sound/soc/msm/msm8974.c
--- android_kernel_samsung_msm8974/sound/soc/msm/msm8974.c	2018-03-05 17:54:37.931683978 -0300
+++ tuned-kernel-LOS-s5/sound/soc/msm/msm8974.c	2017-11-10 10:18:59.013759238 -0300
@@ -1265,12 +1265,12 @@
 
 	return 0;
 }
-
+/*
 static const struct snd_kcontrol_new int_btsco_rate_mixer_controls[] = {
 	SOC_ENUM_EXT("Internal BTSCO SampleRate", msm_btsco_enum[0],
 		     msm_btsco_rate_get, msm_btsco_rate_put),
 };
-
+*/
 static int msm_btsco_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
 					struct snd_pcm_hw_params *params)
 {
Only in tuned-kernel-LOS-s5: tools_boeffla
Only in tuned-kernel-LOS-s5: versions.txt
